# Instruction-Level Parallelism and Its Exploitation

Pipeline CPI
```
= Ideal pipeline CPI + Structural Stalls + Data stalls + Control stalls
= Ideal pipeline CPI + Structural Stalls + (RAW stalls + WAR stalls + WAW stalls) + Control stalls
```

## Pipeline Hazards
Pipeline 在下一個 clock 週期中下一條指令不能執行。這種情況叫做 Hazards。Pipeline Hazards包括以下三種：

### 1. structural hazard
如果有兩個不同的stage需要訪問同一個資源，那它倆就不能並行運行了，這時候有的就只能wait。這叫structural hazard。一個好點的解決方法就是create duplicate resource。

### 2. data hazard
因無法提供指令執行所需數據而導致指令不能在預定的時鐘週期內執行。也就是第二條指令需要第一條指令完成後才能運行（比如需要第一步算出來的結果）。這個也叫做data dependence。

有三種data dependence：
- Read after Write (RAW)
- Write after Read（比如r4=r1+r0 和r0=r3+4）
- Write after Write（2個指令write the same register）

只有第一種是true dependence，別的都可以通過一些方法解決（比如duplicate resource之類）。

對於Read after Write，就只能確保read指令必須要在write完成之後才能開始。對於存在這種依賴關係的指令，直接按照pipeline的方法執行肯定是不行的。以下面的例子為例：
```
add $s0, $t0, $t1         // s0:=t0+t1 
sub $t2, $s0, $t3         // t2:=s0-t3
```

第二種是Name dependence(Anti-dependence,WAR)。以下面的例子為例：
```
add r4,r1,r0 // r4=r1+r0 
add r0,r3,4  // r0=r3+4
```

第三種是Name dependence(output dependence,WAW)。以下面的例子為例：
```
I: sub r1,r4,r3
J: add r1,r2,r3
K: mul r6,r1,r7
```
### 3. Control hazards
發生在處理器被要求作branch時，要等到條件是否滿足才知道要取得的下一個指令在哪裡，而在pipeline的處理過程中可以先預測要取得的下一個指令，如果判斷錯誤造成的暫存器資料的改變，需要還原回來。
```
if p1:
  S1
if p2:
  S2
```
S1 is control dependent on p1 & S2 is control dependent on p2

## Dependency
- Data dependence (true dependence, RAW)
- Name dependence
    - Anti-dependence (WAR)
    - Output dependence (WAW)
- Control dependence

## Pipeline scheduling
調整指令位置，以達到在pipeline中 盡量不要出現stall的情況

### Loop Unrolling
Unrolling Loop可以進一步抽像出“並行粒度”的概念減少stall。Unrolled Loop That Minimizes Stalls

```c
# before
for (int i = 0; i < N; i++) {
		a[i] = i*2;
	}

# after
for (int i = 0; i < N; i = i + 2) {
		a[i] = i * 2;
		a[i + 1] = (i + 1) * 2;
	}
```



## Summary
#### structural hazard:
兩個 instructions 要用同一坨硬體。由於硬體資源不足時所造成的為害，因為要平行處理某些動作，如讀寫記憶體，但是該資源已經正在使用，所以造成衝突。

#### Data Hazards: 
發生在資料之間彼此有相關的地方，因為資料的讀取和寫入的先後順序而造成資料的讀取錯誤。
- RAW：前面的還沒寫，後面就讀出來（讀到舊資料），MIPS只有這個
- WAW：後面的先寫了（寫到舊資料）
- WAR：前面的還沒讀，後面的就先寫了（讀到新資料）

解決方法:
1. Compiler inserts NOP (軟件解法，變慢)
2. Stall (硬件解法，變慢)
3. Forward (硬件解法) 