<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <title>Error Detection Code Comparison</title>
  <STYLE TYPE="text/css">
  <!--
     .mediumNavyCenterBold {
       font-family:"Times New Roman", Arial, Helvetica, sans-serif;
       font-weight:bold;
       font-size:14px;
       color:navy;
       text-align:center;
     }
     .red {
       font-family:"Times New Roman", Arial, Helvetica, sans-serif;
       color:red;
       text-align:center;
     }
     .redBold {
       color:red;
       font-weight:bold;
     }
     .blackBold {
       color:green;
       font-weight:bold;
     }

  -->
  </STYLE>

<script language="javascript">
<!--

var dataword="";
var errorbits="";
var codelength;



// cyclic code variables
var ipoly=0;
var polynomial;
var polybin;
var polylen;
var cyclicCodeword;
var cyclicErrCodeword;
var cyclicErrDataword;
//var cyclicErrRemainder;
var cyclicRemainder;
//var cyclicRemainderErr;
var cyclicComboTotal=0;    // total cyclic bit error combinations
var cyclicComboDet=0;      // total cyclic bit error combinations detected

// residue code variables
var irdue=0;
var residueComboTotal=0;   // total residue bit error combinations
var residueComboDet=0;     // total residue bit error combinations detected
var residueCodeword;
var residueErrCodeword;
var residueErrDataword;
//var residueErrRemainder;
//var residueRemainder;
var residueError;


// hamming code variables
var ichks=0;
var hammingComboTotal=0;   // total hamming bit error combinations
var hammingComboDet=0;     // total hamming bit error combinations detected
var hammingCodeword;
var hammingErrCodeword;
var hammingErrDataword;
//var hammingErrParity;
//var hammingParity;
var hammingError;

var matrix32   = "0111";
var matrix31   = "1011";
var matrix30   = "1101";

var matrix43   = "01110110101";
var matrix42   = "10110011011";
var matrix41   = "11011001101";
var matrix40   = "11101100011";

var matrix54   = "11101101001000100101111110";
var matrix53   = "11011010101001001010111101";
var matrix52   = "10110110011010010011011011";
var matrix51   = "01110001111100011100010111";
var matrix50   = "00001111111111100000001111";

var matrix65   = "01010101110010100101111110101111";
var matrix64   = "01100100101011011010111101110011";
var matrix63   = "01011011001100010011111011011101";
var matrix62   = "10100111000101110100110111011011";
var matrix61   = "10011000010111001110101111110101";
var matrix60   = "10101010111000101001011111101111";


function mainMenu(id){
  var leftarrow = "<";
  var rightarrow = ">";
  var htmlheader1 = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n";
  var htmlheader2 = "<html><head><title>Decoder Compare</title>\n";
  var htmlheader3 = "</head><body>\n";
  var cssheader  = "<STYLE TYPE=\"text/css\">\n" +
                  leftarrow + "!--\n" +
                  "   .mediumNavyCenterBold {\n" +
                  "     font-family:\"Times New Roman\", Arial, Helvetica, sans-serif\;\n" +
                  "     font-weight:bold\;\n" +
                  "     font-size:14px\;\n" +
                  "     color:navy\;\n" +
                  "     text-align:center\;\n" +
                  "   }\n" +
                  "   .red {\n" +
                  "     font-family:\"Times New Roman\", Arial, Helvetica, sans-serif\;\n" +
                  "     color:red\;\n" +
                  "     text-align:center\;\n" +
                  "   }\n" +
                  "   .redBold {\n" +
                  "     color:red\;\n" +
                  "     font-weight:bold\;\n" +
                  "   }\n" +
                  "   .blackBold {\n" +
                  "     color:black\;\n" +
                  "     font-weight:bold\;\n" +
                  "   }\n" +
                  "   .redBoldCenter {\n" +
                  "     color:red\;\n" +
                  "     font-size:20px\;\n" +
                  "     font-weight:bold\;\n" +
                  "     text-align:center\;\n" +
                  "   }\n" +
                  "--" + rightarrow + "\n" +
                  "</STYLE>\n";
  var htmlclose = "\n</body> </html>\n";

    parent.ece655Content.document.open();
    parent.ece655Content.document.write(htmlheader1);
    parent.ece655Content.document.write(htmlheader2);
    parent.ece655Content.document.write(cssheader);
    parent.ece655Content.document.write(htmlheader3);

//  parent.ece655Content.document.write("<p>id = \"" + document.eceform1.dataword.value + "\" dataword</p>");
//  parent.ece655Content.document.write("<p>id = \"" + document.eceform1.poly.selectedIndex + "\" poly</p>");
//  parent.ece655Content.document.write("<p>id = \"" + document.eceform1.chkbit.selectedIndex + "\" chkbit</p>");
//  parent.ece655Content.document.write("<p>id = \"" + document.eceform1.duebit.selectedIndex + "\" duebit</p>");
//  parent.ece655Content.document.write("<p>id = \"" + document.eceform2.errlen.value + "\" errlen</p>");

    dataword = document.eceform1.dataword.value;
    ipoly    = document.eceform1.poly.selectedIndex;
    ichks    = document.eceform1.chkbit.selectedIndex;
    irdue    = document.eceform1.duebit.selectedIndex;
    errorbits  = document.eceform2.errlen.value;
    storeCookies(document);

    if (id=="analyze") {
      if (!chkDataword(parent.ece655Content.document))
      {
        // had a problem, display help
        displayHelp(parent.ece655Content.document);
      }
      else
      {
        if (!chkHammingRange(parent.ece655Content.document))
        {
          displayHelp(parent.ece655Content.document);
        }
        else
        {
          displayOverhead(parent.ece655Content.document);
        }
      }
    }
    else if (id=="biterror" || id=="bursterror") {
      if (!chkDataword(parent.ece655Content.document))
      {
        // had a problem, display help
        displayHelp(parent.ece655Content.document);
      }
      else
      {
        if (!chkHammingRange(parent.ece655Content.document))
        {
          displayHelp(parent.ece655Content.document);
        }
        else
        {
          displayOverhead(parent.ece655Content.document);
          if (!chkErrorbits(parent.ece655Content.document))
          {
            // had a problem, display help
            displayHelp(parent.ece655Content.document);
          }
          else if (id=="biterror")
            displayBitErrors(parent.ece655Content.document);
          else  // burst error
            displayBurstErrors(parent.ece655Content.document);
        }
      }
    }

    else if (id=="help") {
      displayHelp(parent.ece655Content.document);
    }
//  else if (id=="info") {
//    displayInfo(parent.ece655Content.document);
//  }
    else {
      displayHelp(parent.ece655Content.document);
    }

    parent.ece655Content.document.write(htmlclose);
    parent.ece655Content.document.close();
    return(true);
}

function displayOverhead(outputdoc) {

  var overhead;

  outputdoc.write("<p align=center><b>data word = " + dataword + "</b></p>\n");

  outputdoc.write("<table align=center width=\"100\%\" border=0>\n" +
      "<tr>\n" +
      "<th align=left>Cyclic Code</th>\n" +
      "<th align=left>Hamming Code</th>\n" +
      "<th align=left>Separable Residue Code</th>\n" +
      "</tr>\n");

  outputdoc.write("<tr>\n");

  makePolynomial();

  outputdoc.write("<td>(Using polynomial " + polynomial + ")\n");
  outputdoc.write("</td/></tr>\n");

  outputdoc.write("<tr>\n");
  cyclicCodeword = cyclicEncode(dataword,polybin);
  outputdoc.write("<td>data word cyclic encoded:<br><b>" + cyclicCodeword + "</b>\n");
  outputdoc.write("<br>data word cyclic decoded:<br><b>" + cyclicDecode(cyclicCodeword,polybin) + "</b>\n");
  if (cyclicRemainderErr != 0)
    outputdoc.write("<br>decoder detected an error due to non-zero remainder\n");
  outputdoc.write("</td>\n");

  hammingCodeword = hammingEncode(dataword,ichks);
  outputdoc.write("<td>data word Hamming encoded:<br><b>" + hammingCodeword + "</b>\n");
  outputdoc.write("<br>data word Hamming decoded:<br><b>" + hammingDecode(hammingCodeword,ichks) + "</b>\n");
  if (hammingError != 0)
    outputdoc.write("<br>decoder detected an error due to non-zero syndrome\n");
  outputdoc.write("</td>\n");

  residueCodeword = residueEncode(dataword,irdue);
  outputdoc.write("<td>data word Residue encoded:<br><b>" + residueCodeword + "</b>\n");
  outputdoc.write("<br>data word Residue decoded:<br><b>" + residueDecode(residueCodeword,irdue) + "</b>\n");
  if (residueError != 0)
    outputdoc.write("<br>decoder detected an error due to unexpected residue\n");
  outputdoc.write("</td>\n");

  outputdoc.write("</tr>\n");


  outputdoc.write("<tr>\n");

  overhead = cyclicCodeword.length - dataword.length;
  outputdoc.write("<td>Code OverHead = <b>" + percent_format(overhead,cyclicCodeword.length) + "</b>\n");
  outputdoc.write("</td>\n");

  overhead = hammingCodeword.length - dataword.length;
  outputdoc.write("<td>Code OverHead = <b>" + percent_format(overhead,hammingCodeword.length) + "</b>\n");
  outputdoc.write("</td>\n");

  overhead = residueCodeword.length - dataword.length;
  outputdoc.write("<td>Code OverHead = <b>" + percent_format(overhead,residueCodeword.length) + "</b>\n");
  outputdoc.write("</td>\n");

  outputdoc.write("</tr>\n");

  outputdoc.write("</table>\n");


  // codelength needs to be set to the smallest of the various code words in
  // order to limit the error size.
  codelength = cyclicCodeword.length;
  if (hammingCodeword.length < codelength)
        {codelength = hammingCodeword.length;}
  if (residueCodeword.length < codelength)
        {codelength = residueCodeword.length;}
}

function displayBitErrors(outputdoc) {

  outputdoc.write("<h2 align=center>Error analysis for " + errorbits + " bit errors</h2>\n");
  outputdoc.write("<h3 class=mediumNavyCenterBold>Please be patient.  This may take some time to calculate.</h3>\n");

  hammingComboTotal=0;   // total hamming bit error combinations
  hammingComboDet=0;     // total hamming bit error combinations detected
  residueComboTotal=0;   // total residue bit error combinations
  residueComboDet=0;     // total residue bit error combinations detected
  cyclicComboTotal=0;    // total cyclic bit error combinations
  cyclicComboDet=0;      // total cyclic bit error combinations detected

  combo(hammingCodeword, errorbits, 1);
  combo(residueCodeword, errorbits, 2);
  combo(cyclicCodeword, errorbits, 3);

  displayErrorResults(outputdoc);

}

function displayBurstErrors(outputdoc) {

  outputdoc.write("<h2 align=center>Error analysis for " + errorbits + " bit burst errors</h2>\n");

  hammingComboTotal=0;   // total hamming bit error combinations
  hammingComboDet=0;     // total hamming bit error combinations detected
  residueComboTotal=0;   // total residue bit error combinations
  residueComboDet=0;     // total residue bit error combinations detected
  cyclicComboTotal=0;    // total cyclic bit error combinations
  cyclicComboDet=0;      // total cyclic bit error combinations detected

  burst(hammingCodeword, errorbits, 1);
  burst(residueCodeword, errorbits, 2);
  burst(cyclicCodeword, errorbits, 3);

  displayErrorResults(outputdoc);

}

function getValues() {
  with (document.eceform1) {
    dataword.value = getCookie(document,"dataword") || 0;
    poly.selectedIndex = getCookie(document,"poly") || 0;
    chkbit.selectedIndex = getCookie(document,"chkbit") || 0;
    duebit.selectedIndex = getCookie(document,"duebit") || 0;
  }
  with (document.eceform2) {
    errlen.value = getCookie(document,"errlen") || 0;
  }
  return(true);
}


// store cookies from eceform1
// includes, dataword, polynomial, hamming, residue values
function storeCookies(menudoc){
  menudoc.cookie = "dataword=" + escape(dataword);
  menudoc.cookie = "poly=" + escape(ipoly);
  menudoc.cookie = "chkbit=" + escape(ichks);
  menudoc.cookie = "duebit=" + escape(irdue);
  menudoc.cookie = "errlen=" + escape(errorbits);
  return(true);
}

function percent_format (top, bot) {
    var n;
    n = (top * 100) / bot
    n = Math.round(n * 100) / 100;
    n = (n + 0.001) + '';
    return (n.substring(0, n.indexOf('.') + 3) + "%");
  }


// read cookies for eceform1
// includes, dataword, polynomial, hamming, residue values
function getCookie(menudoc,name){
  if (menudoc.cookie == '')
  {
     // there's no cookie, so go no further
     return false;
  }
  else
  {
    // there is a cookie
    var firstChar, lastChar;
    var theBigCookie = menudoc.cookie;

    // find the start of 'name'
    firstChar = theBigCookie.indexOf(name);
    if(firstChar != -1)  {
       // if you found the cookie
       firstChar += name.length + 1;
       // skip 'name' and '='
       lastChar = theBigCookie.indexOf(';', firstChar);
       // Find the end of the value string (i.e. the next ';').
       if(lastChar == -1) lastChar = theBigCookie.length;
       return unescape(theBigCookie.substring(firstChar, lastChar));
    }
    else
    {
      // If there was no cookie of that name, return false.
      return false;
    }
  }
}

//--------------------------------------------------------------
// make polynomial in long integer form and String form for html print
//----------------------------------------------------------------
function makePolynomial() {

      if (ipoly == 0)
      {
        polynomial="X<sup>3</sup> + X + 1";
        polybin="1011";
        polylen=3;
      }
      else if (ipoly == 1)
      {
        polynomial="X<sup>4</sup> + X + 1";
        polybin="10011";
        polylen=4;
      }
      else if (ipoly == 2)
      {
        polynomial="X<sup>5</sup> + X<sup>2</sup> + 1";
        polybin="100101";
        polylen=5;
      }
      else if (ipoly == 3)
      {
        polynomial="X<sup>6</sup> + X + 1";
        polybin="1000011";
        polylen=6;
      }
      else if (ipoly == 4)
      {
        polynomial="X<sup>7</sup> + X<sup>3</sup> + 1";
        polybin="10001001";
        polylen=7;
      }
      else if (ipoly == 5)
      {
        polynomial="X<sup>8</sup> + X<sup>4</sup> + X<sup>3</sup> + X<sup>2</sup> + 1";
        polybin="100011101";
        polylen=8;
      }
      else
      {
        polynomial="X<sup>3</sup> + X + 1";
        polybin="1011";
        polylen=3;
      }
 }

//--------------------------------------------------------------
//     encode the data stream using a cyclic encoder
//     return a binary string representing the encoded data
//--------------------------------------------------------------
function cyclicEncode(datastr, polystr) {

    var result = "0";
    var len = datastr.length;
    var lencode = len + polylen;
    var polystrx;

    // pad poly and result to be the same length as the encoded data word
    polystrx = PadZero(polystr, lencode);
    result   = PadZero(result, lencode);

    for (var i=0; i<len; i++)
    {
        // shift result left one position
        result = result.substr(1,lencode-1) + "0";
        // multiplier, starting at the msb
        if (datastr.charAt(i) == "1")
        {
          result = strXOR(result,polystrx);    // do the modulo 2 addition
        }
    }

    return result;

   }

//--------------------------------------------------------------
//     decode the data stream using a cyclic decoder
//     return a binary string representing the decoded data
//--------------------------------------------------------------
function cyclicDecode(codestr,polystr) {

    var result = "";
    var polystrx;
    var remainder = 0;
    var loopcnt = 0;
    var len = codestr.length;

     // to prepare for the division reverse the codeword and the polynomial
     // to make the division easier.
     remainder = reverseStr(codestr);
     polystrx  = reverseStr(polystr);
     polystrx = PadZero(polystrx, len);
     loopcnt = len - polylen;
     for (var i=0; i<loopcnt; i++)
     {
       if (i>0)
       {
         // shift result right one position
         remainder = "0" + remainder.substr(0,len-1);
       }
       // divider, using reversed string codeword and reversed polynomial string
       if (remainder.charAt(len-1) == "1")
       {
         result = result + "1";
         remainder = strXOR(remainder,polystrx);    // do the modulo 2 subtraction
       }
       else
       {
         result = result + "0";
       }
     }
     // if remainder not all 0's, then set the error bit
//   cyclicRemainder = remainder;  // store for later display
     if (!chkZero(remainder))
       cyclicRemainderErr = 1;
     else
       cyclicRemainderErr = 0;
     return result;  // return the string

   }


//--------------------------------------------------------------
// call decoder and apply the errors in locations given from passed array
//----------------------------------------------------------------
function cyclicDecodeErr(kcombo, a) {
  var errCodeword;
  var newbit;
  var len;
  var tmp;


     errCodeword = cyclicCodeword;
     len = errCodeword.length;
     // apply the errors in locations from the array a
     for (var i=0; i<kcombo; i++)
     {
       if (errCodeword.charAt(a[i]) == "0")
         newbit="1";
       else
         newbit="0";

       if (a[i] == 0)                          // replacing first character
         errCodeword = newbit + errCodeword.substr(1,len-1);
       else if (a[i] == len-1)                 // replacing last character
         errCodeword =  errCodeword.substr(0,len-1) + newbit;
       else                                    // repalcing middle character
         errCodeword =  errCodeword.substr(0,a[i]) + newbit + errCodeword.substr(a[i]+1,len-a[i]-1);
     }
     cyclicComboTotal++;   // total cyclic bit error combinations


     tmp=cyclicDecode(errCodeword,polybin);
     if (cyclicRemainderErr != 0)
     {
       cyclicComboDet++;     // total cyclic bit error combinations detected
     }
     else
     {
       cyclicErrCodeword = errCodeword;  // not detected
       cyclicErrDataword = tmp;          // incorrect decoded code word
//     cyclicErrRemainder = cyclicRemainder;  // incorrect remainder
     }

   }


function reverseStr(str) {
  var result="";
  var len = str.length;
  for (var i = len-1; i>=0; i--) {
      result = result + str.charAt(i);
   }
  return(result)
}

// check to see if string is all 0's
function chkZero(str) {
  var len=str.length;
  for (var i=0; i<len; i++)
  {
    if (str.charAt(i)!='0')
    {
      return(false);
    }
  }
  return(true);
}


// pads the string to len, using leading 0's
function PadZero(str,len)
{

 var PadLen;
 if (len <= str.length) // No padding necessary.
  return(str)
 PadLen = len - str.length
 for (var i=0; i < PadLen; i++)
  str = "0" + str
 return(str)
}



//--------------------------------------------------------------
// expects two binary strings of equal length and returns an
// XOR of the two binary strings
//--------------------------------------------------------------
function strXOR (str1,str2) {

    var result = "";
    // only need length of one string, since they are the same length, right!
    var len = str1.length;

    for (var i=0; i<len; i++)
    {
      if (str1.charAt(i) == str2.charAt(i))
      {
        result = result + "0";
      }
      else
      {
        result = result + "1";
      }
    }
    return result;

}


//--------------------------------------------------------------
// expects two binary strings of equal length and returns a formatted
// string for html output, where the differences are printed in red.
//--------------------------------------------------------------
function strDiff (str1,str2) {

    var result = "";
    // only need length of one string, since they are the same length, right!
    var len = str1.length;

    for (var i=0; i<len; i++)
    {
      if (str1.charAt(i) == str2.charAt(i))
      {
        // bits are the same, use either bit colored in the default color
        result = result + "<span class=\"blackBold\">" + str2.charAt(i) + "</span>";
      }
      else
      {
        // bits differ, use second bit colored in red
        result = result + "<span class=\"redBold\">" + str2.charAt(i) + "</span>";
      }
    }
    return result;

}



//--------------------------------------------------------------
//     chk the dataword input from the user
//     must be all 1's and 0's of length 4 to 16
//--------------------------------------------------------------
  function chkDataword(outputdoc) {

  var len = dataword.length;

  if (len < 4 || len > 16)
  {
    outputdoc.write("<p class=\"redBoldCenter\">Data word must be 0\'s and 1\'s of length between 4 and 16.</p>");
    return(false);
  }
  for (var i=0; i<len; i++)
  {
    if (dataword.charAt(i)!='0' && dataword.charAt(i)!='1')
    {
      outputdoc.write("<p class=\"redBoldCenter\">Data word must be 0\'s and 1\'s of length between 4 and 16.</p>");
      return(false);
    }
  }
  return(true);

  }

//--------------------------------------------------------------
//     chk the errorbits input from the user
//     must be all between 1 and codelength
//--------------------------------------------------------------
function chkErrorbits(outputdoc) {

  if (isNaN(errorbits))
  {
    outputdoc.write("<p class=\"redBoldCenter\">Error Bits must be a positive numeric number >0 and <= the shortest codeword length.</p>");
    return(false);
  }
  if (errorbits < 1 || errorbits > codelength)
  {
    outputdoc.write("<p class=\"redBoldCenter\">Error Bits must be a positive numeric number >0 and <= the shortest codeword length.</p>");
    return(false);
  }
  return(true);

}

//--------------------------------------------------------------
//     chk that the number of Hamming Code parity bits selected
//     is consistent with the length of the dataword
//--------------------------------------------------------------
function chkHammingRange(outputdoc) {

  var len = dataword.length;

      if (len != 4 && ichks == 0)
      {
        outputdoc.write("<p class=\"redBoldCenter\">Data words with more than 4 bits require more than 3 Hamming code parity bits.</p>");
        return(false);
      }
      if (len > 11 && ichks == 1)
      {
        outputdoc.write("<p class=\"redBoldCenter\">Data words with more than 11 bits require more than 4 Hamming code parity bits.</p>");
        return(false);
      }
      if (len > 26 && ichks == 2)
      {
        outputdoc.write("<p class=\"redBoldCenter\">Data words with more than 26 bits require more than 5 Hamming code parity bits.</p>");
        return(false);
      }
      return(true);

}

//--------------------------------------------------------------
//     encode the data stream using a hamming encoder
//     return a binary string representing the encoded data
//--------------------------------------------------------------
function hammingEncode(datastr,checkbits) {
    var len = datastr.length;

     var codeword, p5="", p4="", p3="", p2="0", p1="0", p0="0";
     var row0, row1, row2, row3="0", row4="0", row5="0";

     if (checkbits==0)
     {
        row0 = matrix30;
        row1 = matrix31;
        row2 = matrix32;
     }
     else if (checkbits==1)
     {
        row0 = matrix40;
        row1 = matrix41;
        row2 = matrix42;
        row3 = matrix43;
     }
     else if (checkbits==2)
     {
        row0 = matrix50;
        row1 = matrix51;
        row2 = matrix52;
        row3 = matrix53;
        row4 = matrix54;
     }
     else if (checkbits==3)
     {
        row0 = matrix60;
        row1 = matrix61;
        row2 = matrix62;
        row3 = matrix63;
        row4 = matrix64;
        row5 = matrix65;
     }

     if (checkbits == 3)
     {
        p5="0";
        for (var i=0; i<len; i++)
        {
          if (row5.charAt(i) == "1")
          {
            p5 = strXOR(p5,datastr.charAt(i)); // XOR data bit w/ p5
          }
        }
     }
     if (checkbits > 1)
     {
        p4="0";
        for (var i=0; i<len; i++)
        {
          if (row4.charAt(i) == "1")
          {
            p4 = strXOR(p4,datastr.charAt(i)); // XOR data bit w/ p4
          }
        }
     }
     if (checkbits > 0)
     {
        p3="0";
        for (var i=0; i<len; i++)
        {
          if (row3.charAt(i) == "1")
          {
            p3 = strXOR(p3,datastr.charAt(i)); // XOR data bit w/ p3
          }
        }
     }
     for (var i=0; i<len; i++)
     {
       if (row2.charAt(i) == "1")
       {
         p2 = strXOR(p2,datastr.charAt(i)); // XOR data bit w/ p2
       }
       if (row1.charAt(i) == "1")
       {
         p1 = strXOR(p1,datastr.charAt(i)); // XOR data bit w/ p1
       }
       if (row0.charAt(i) == "1")
       {
         p0 = strXOR(p0,datastr.charAt(i)); // XOR data bit w/ p0
       }
     }
     codeword = datastr + p5 + p4 + p3 + p2 + p1 + p0;
     return(codeword);

   }

//--------------------------------------------------------------
// decode the data stream using a hamming decoder
// return a binary string representing the decoded data
//--------------------------------------------------------------
function hammingDecode(codestr,checkbits) {
    var len = codestr.length - checkbits - 3;
    var parityindex = len;

     var datastr, p5="", p4="", p3="", p2="0", p1="0", p0="0";
     var row0, row1, row2, row3="0", row4="0", row5="0";

    hammingError = 0;

     if (checkbits==0)
     {
        row0 = matrix30;
        row1 = matrix31;
        row2 = matrix32;
     }
     else if (checkbits==1)
     {
        row0 = matrix40;
        row1 = matrix41;
        row2 = matrix42;
        row3 = matrix43;
     }
     else if (checkbits==2)
     {
        row0 = matrix50;
        row1 = matrix51;
        row2 = matrix52;
        row3 = matrix53;
        row4 = matrix54;
     }
     else if (checkbits==3)
     {
        row0 = matrix60;
        row1 = matrix61;
        row2 = matrix62;
        row3 = matrix63;
        row4 = matrix64;
        row5 = matrix65;
     }

     if (checkbits == 3)
     {
        p5="0";
        for (var i=0; i<len; i++)
        {
          if (row5.charAt(i) == "1")
          {
            p5 = strXOR(p5,codestr.charAt(i)); // XOR data bit w/ p5
          }
        }
     }
     if (checkbits > 1)
     {
        p4="0";
        for (var i=0; i<len; i++)
        {
          if (row4.charAt(i) == "1")
          {
            p4 = strXOR(p4,codestr.charAt(i)); // XOR data bit w/ p4
          }
        }
     }
     if (checkbits > 0)
     {
        p3="0";
        for (var i=0; i<len; i++)
        {
          if (row3.charAt(i) == "1")
          {
            p3 = strXOR(p3,codestr.charAt(i)); // XOR data bit w/ p3
          }
        }
     }
     for (var i=0; i<len; i++)
     {
       if (row2.charAt(i) == "1")
       {
         p2 = strXOR(p2,codestr.charAt(i)); // XOR data bit w/ p2
       }
       if (row1.charAt(i) == "1")
       {
         p1 = strXOR(p1,codestr.charAt(i)); // XOR data bit w/ p1
       }
       if (row0.charAt(i) == "1")
       {
         p0 = strXOR(p0,codestr.charAt(i)); // XOR data bit w/ p0
       }
     }


     // calculate syndrome bits by exclusive ORing parity bits with check bits
     // (could combine these with IF statements above or make subroutine calls)

     if (checkbits == 3) {
        p5 = strXOR(p5,codestr.charAt(parityindex));
        parityindex++;
     }
     if (checkbits > 1) {
        p4 = strXOR(p4,codestr.charAt(parityindex));
        parityindex++;
     }
     if (checkbits > 0) {
        p3 = strXOR(p3,codestr.charAt(parityindex));
        parityindex++;
     }
     p2 = strXOR(p2,codestr.charAt(parityindex));
     p1 = strXOR(p1,codestr.charAt(parityindex+1));
     p0 = strXOR(p0,codestr.charAt(parityindex+2));


//   hammingParity = p5 + p4 + p3 + p2 + p1 + p0;

     if (p0 == "1" || p1 == "1" || p2 == "1" ||
         p3 == "1" || p4 == "1" || p5 == "1")
        {hammingError = 1;}

     datastr = codestr.substr(0,len);
     return(datastr);
   }

//--------------------------------------------------------------
// call decoder and apply the errors in locations given from passed array
//----------------------------------------------------------------
function hammingDecodeErr(kcombo, a) {
  var errCodeword;
  var newbit;
  var len;
  var tmp;


     errCodeword = hammingCodeword;
     len = errCodeword.length;
     // apply the errors in locations from the array a
     for (var i=0; i<kcombo; i++)
     {
       if (errCodeword.charAt(a[i]) == "0")
         newbit="1";
       else
         newbit="0";

       if (a[i] == 0)                          // replacing first character
         errCodeword = newbit + errCodeword.substr(1,len-1);
       else if (a[i] == len-1)                 // replacing last character
         errCodeword =  errCodeword.substr(0,len-1) + newbit;
       else                                    // repalcing middle character
         errCodeword =  errCodeword.substr(0,a[i]) + newbit + errCodeword.substr(a[i]+1,len-a[i]-1);
     }
     hammingComboTotal++;   // total hamming bit error combinations


     tmp=hammingDecode(errCodeword,ichks);
     if (hammingError != 0)
     {
       hammingComboDet++;     // total hamming bit error combinations detected
     }
     else
     {
       hammingErrCodeword = errCodeword;  // not detected
       hammingErrDataword = tmp;          // incorrect decoded code word
//     hammingErrParity   = hammingParity;  // incorrect parity
     }

   }

//--------------------------------------------------------------
// encode the data stream using a residue encoder
// return a binary string representing the encoded data
//--------------------------------------------------------------
function residueEncode(datastr, residuebits) {
    var len = datastr.length;
    var codeword, residue, width, rlen;
    var dividend, divisor, remainder;

     width = residuebits + 3;

     if (residuebits == 0)
       {divisor = 7;}
     else if (residuebits == 1)
       {divisor = 15;}
     else if (residuebits == 2)
       {divisor = 31;}
     else if (residuebits == 3)
       {divisor = 63;}
     else
       {divisor = 7;}


     dividend = bin2dec(datastr);
     remainder = dividend % divisor;
     residue = dec2bin(remainder);

     rlen = residue.length;

     for (var i=1; i <= width-rlen; i++)
       {residue = "0" + residue;}
     codeword = datastr + residue;
     return(codeword);

   }

//--------------------------------------------------------------
// decode the codeword using a residue decoder
// return a binary string representing the decoded data
//--------------------------------------------------------------
function residueDecode(codeword, residuebits) {
    var datastr, residue, newrdue, width, rlen, clen, separate;
    var dividend, divisor, remainder;

     width = residuebits + 3;

     if (residuebits == 0)
       {divisor = 7;}
     else if (residuebits == 1)
       {divisor = 15;}
     else if (residuebits == 2)
       {divisor = 31;}
     else if (residuebits == 3)
       {divisor = 63;}
     else
       {divisor = 7;}

     clen = codeword.length;
     separate = clen - width;
     datastr = codeword.substr(0,separate);
     residue = codeword.substr(separate,width);

     dividend = bin2dec(datastr);
     remainder = dividend % divisor;
     newrdue = dec2bin(remainder);

     rlen = newrdue.length;

     for (var i=1; i <= width-rlen; i++)
       {newrdue = "0" + newrdue;}
//   residueRemainder = newrdue;     // incorrect remainder
     if (newrdue == residue)
        {residueError = 0;}
     else
        {residueError = 1;}
     return(datastr);

   }

//--------------------------------------------------------------
// call decoder and apply the errors in locations given from passed array
//----------------------------------------------------------------
function residueDecodeErr(kcombo, a) {
  var errCodeword;
  var newbit;
  var len;
  var tmp;


     errCodeword = residueCodeword;
     len = errCodeword.length;
     // apply the errors in locations from the array a
     for (var i=0; i<kcombo; i++)
     {
       if (errCodeword.charAt(a[i]) == "0")
         newbit="1";
       else
         newbit="0";

       if (a[i] == 0)                          // replacing first character
         errCodeword = newbit + errCodeword.substr(1,len-1);
       else if (a[i] == len-1)                 // replacing last character
         errCodeword =  errCodeword.substr(0,len-1) + newbit;
       else                                    // repalcing middle character
         errCodeword =  errCodeword.substr(0,a[i]) + newbit + errCodeword.substr(a[i]+1,len-a[i]-1);
     }
     residueComboTotal++;   // total residue bit error combinations


     tmp=residueDecode(errCodeword,irdue);
     if (residueError != 0)
     {
       residueComboDet++;     // total residue bit error combinations detected
     }
     else
     {
       residueErrCodeword = errCodeword;  // not detected
       residueErrDataword = tmp;          // incorrect decoded code word
//     residueErrRemainder = residueRemainder;  // incorrect remainder
     }

   }


function dec2bin(n) {
  var result="";
  var quot=n;
  var remainder;

  while(quot != 0)
  {
    remainder = quot % 2;
    result = remainder.toString() + result.toString();
    quot = Math.floor(quot / 2);
  }
   return(result);
}

function bin2dec(binstr) {
  var result=0;
  var mult=1;
  var len=binstr.length;

  for (var i=len-1; i>=0; i--)
  {
    result = result+(binstr.charAt(i) * mult);
    mult=mult*2;
  }

  return(result);
}


//--------------------------------------------------------------
//     display the error results
//--------------------------------------------------------------
function displayErrorResults(outputdoc) {

    outputdoc.write("<table align=center width=\"100%\" border=0>\n");
    outputdoc.write("<tr>\n");
    outputdoc.write("<th align=left>Cyclic Code</th>\n\n");
    outputdoc.write("<th align=left>Hamming Code</th>\n\n");
    outputdoc.write("<th align=left>Separable Residue Code</th>\n\n");
    outputdoc.write("</tr>\n");

    outputdoc.write("<tr>\n");
    outputdoc.write("<td>Cyclic code detected:<br><b>" + cyclicComboDet +
                        "</b> errors of <b>" + cyclicComboTotal + "</b> total combinations.</td>\n");
    outputdoc.write("<td>Hamming code detected:<br><b>" + hammingComboDet +
                        "</b> errors of <b>" + hammingComboTotal + "</b> total combinations.</td>\n");
    outputdoc.write("<td>Residue code detected:<br><b>" + residueComboDet +
                        "</b> errors of <b>" + residueComboTotal + "</b> total combinations.</td>\n");
    outputdoc.write("</tr>\n");


    outputdoc.write("<tr>\n");
    outputdoc.write("<td>Percent Detected = <b>" + percent_format(cyclicComboDet, cyclicComboTotal) + "</b></td>\n");
    outputdoc.write("<td>Percent Detected = <b>" + percent_format(hammingComboDet, hammingComboTotal) + "</b></td>\n");
    outputdoc.write("<td>Percent Detected = <b>" + percent_format(residueComboDet, residueComboTotal) + "</b></td>\n");
    outputdoc.write("</tr>\n");

    outputdoc.write("<tr>\n");

      // display a sample failure
      if (cyclicComboDet == cyclicComboTotal)  // no errors in this case
         {outputdoc.write("<td></td>\n");}
      else
         {outputdoc.write("<td><br><b>Sample undetected codeword:</b>\n" +
                "<br>Original code word:<br>" +
                "<b>" + cyclicCodeword + "</b>" +
                "<br>Code word with errors:<br>" +
                strDiff(cyclicCodeword,cyclicErrCodeword) +
                "<br>Incorrect decoded data:<br>" +
                "Data=" + strDiff(dataword,cyclicErrDataword) +
                "</td>\n");
         }

      if (hammingComboDet == hammingComboTotal)  // no errors in this case
         {outputdoc.write("<td></td>\n");}
      else
         {outputdoc.write("<td><br><b>Sample undetected codeword:</b>\n" +
                "<br>Original code word:<br>" +
                "<b>" + hammingCodeword + "</b>" +
                "<br>Code word with errors:<br>" +
                strDiff(hammingCodeword,hammingErrCodeword) +
                "<br>Incorrect decoded data:<br>" +
                "Data=" + strDiff(dataword,hammingErrDataword) +
                "</td>\n");
         }

      if (residueComboDet == residueComboTotal)  // no errors in this case
         {outputdoc.write("<td></td>\n");}
      else
         {outputdoc.write("<td><br><b>Sample undetected codeword:</b>\n" +
                "<br>Original code word:<br>" +
                "<b>" + residueCodeword + "</b>" +
                "<br>Code word with errors:<br>" +
                strDiff(residueCodeword,residueErrCodeword) +
                "<br>Incorrect decoded data word:<br>" +
                "Data=" + strDiff(dataword,residueErrDataword) +
                "</td>\n");
         }

//              "<br>Remainder=<span class=\"redBold\">" + cyclicErrRemainder + "</span>" +
//              "<br>Parity=<span class=\"redBold\">" + hammingErrParity + "</span>" +
//              "<br>Remainder=" + strDiff(residueCodeword.substr(residueCodeword.length-irdue-3,irdue+3),residueErrRemainder) +

      outputdoc.write("</tr>\n");
      outputdoc.write("</table>\n");
   }


//------------------------------------------------------------------------
//     Take combinations of ntotal items, kcombo items at a time.
//     This sets the indexes in an array that contains the selected items.
//     Can now call some other routine to do something with these indexes.
//------------------------------------------------------------------------
function combo(codeword, kcombo, codeID) {

     var a = new Array(kcombo);
     var done;
     var k,ntotal;

     ntotal = codeword.length;

     // initialize the results to the first combination
     for (var i=0; i<kcombo; i++)
       {a[i] = i;}

     // have the first index, can call the external routine now
     if (codeID == 1) {hammingDecodeErr(kcombo, a);}
     if (codeID == 2) {residueDecodeErr(kcombo, a);}
     if (codeID == 3) {cyclicDecodeErr(kcombo, a);}

     if (ntotal==kcombo) {done=1;}
     else {done=0;}
     while (done==0)
     {
       k = kcombo - 1;

       // if at end of list for right most index, start moving previous index out
       while (a[k] == ntotal - kcombo + k)
         {k = k - 1;}

       a[k] = a[k] + 1;

       // move current index out
       for (var j=k+1; j<kcombo; j++)
         {a[j] = a[k] + j - k;}

       // have new indexes, call output routine
       if (codeID == 1) {hammingDecodeErr(kcombo, a);}
       if (codeID == 2) {residueDecodeErr(kcombo, a);}
       if (codeID == 3) {cyclicDecodeErr(kcombo, a);}

       // check to see if done, i.e. at final combination
       done=1;
       for (var i=0; i<kcombo && done==1; i++)
         {if (a[i] != (ntotal - kcombo + i)) {done=0;}}

     }
   }

//--------------------------------------------------------------
// Take burst errors of ntotal items, kcombo items at a time.
// This sets the indexes in an array that contains the selected items.
// Can now call some other routine to do something with these indexes.
//----------------------------------------------------------------
function burst(codeword, kcombo, codeID) {

   var a = new Array(kcombo);
   var done;
   var ntotal;

     ntotal = codeword.length;

     // initialize the results to the first combination
     for (var i=0; i<kcombo; i++)
       {a[i] = i;}

     // have the first index, can call the external routine now
     if (codeID == 1) {hammingDecodeErr(kcombo, a);}
     if (codeID == 2) {residueDecodeErr(kcombo, a);}
     if (codeID == 3) {cyclicDecodeErr(kcombo, a);}

     if (ntotal==kcombo) {done=1;}
     else {done=0;}
     while (done==0)
     {
       // move current index out
       for (var i=0; i<kcombo; i++)
         {a[i] = a[i] + 1;}

       // have new indexes, call output routine
       if (codeID == 1) {hammingDecodeErr(kcombo, a);}
       if (codeID == 2) {residueDecodeErr(kcombo, a);}
       if (codeID == 3) {cyclicDecodeErr(kcombo, a);}

       // check to see if done, i.e. at final combination
       done=1;
       for (var i=0; i<kcombo && done==1; i++)
         {if (a[i] != (ntotal - kcombo + i)) {done=0;}}

     }
   }


  function displayInfo(outputdoc){
    var dispinfo;
    dispinfo="<h2>Information Regarding This Program</h2>" +
             "<ul>" +
             "<li>This program was written to allow the user an emperical " +
                      "way to compare the relative merits of these 3 types of Error " +
                      "Detection Codes (EDC)." +
             "<li>In particular, our program will help the " +
                      "user get a feel for the percentage of multiple-bit errors that " +
                      "can be expected to be detected or to go undetected." +
             "<li>The Cyclic code is strictly an EDC that is often used when data " +
                      "corrupted by transient errors can be retransmitted or reprocessed successfully." +
             "<li>The Hamming code is often used for single-bit error correction.  " +
                      "However, in this program, no data correction is attempted.  The condition: " +
                      "<b>2<sup>r</sup> >= r+d+1</b> is met." +
             "<li>The Residue code used is a separable arithmetic EDC that uses an A " +
                      "of the form:  <b>A = 2<sup>a</sup> - 1</b> where a is an integer >= 3 and <= 6. " +
                      " (The value of a equals the number of residue bits.)<br>" +
             "</ul>";
//           "<h4>Written and Submitted by Scott Schaffer & Steve Bentley.<br>" +
//                    "ECE655 Term Project   (Fall Semester, 2003)</h4>";
    outputdoc.write(dispinfo);
  }

function displayHelp(outputdoc){
  var disphelp;
  displayInfo(outputdoc);
  disphelp="<h2>How To Use This Tool</h2>" +
           "<h3>Overhead Analysis:</h3>" +
           "<ol>" +
           "<li>Enter a binary stream of bits between 4 and 16 bits long" +
           "    in the first input box.  This is the data word to be encoded." +
           "<li>Select the desired parameter for each Error" +
           "    Detection Code (EDC) to determine how much information redundancy" +
           "    will be added to the data word." +
           "<br><i><b>(Normally, you will want to make the overhead the same for" +
           "    all 3 code words so that the error detection results can be fairly" +
           "    compared.)</i></b>" +
           "<li>Push the <b> Analyze </b> button to calculate the code" +
           "    word and determine the percent overhead for each of the codes." +
           "</ol>" +
           "<br>" +
           "<h3>Bit and Burst Error Analysis</h3>" +
           "<ol>" +
           "<li>In the input box in the bottom left, enter the" +
           "    number of bits in error you want to apply to each code word for analysis." +
           "<br><i>(This value cannot be larger than the length of the shortest of the" +
           "    3 code words.)</i>" +
           "<li>Push the <b> Bit Error </b> button to evaluate all possible" +
           "    combinations of the number of errors indicated in the input box." +
           "<br><i><b>(If the code word is long and the number" +
           "    of applied error bits is also large, the full error" +
           "    analysis can take several minutes.  Please be patient.)</b></i>" +
           "<li>Push the <b> Burst Error </b> button to evaluate only" +
           "    adjacent errors of length specified in the input box." +
           "<li>Continue error detection analysis as desired.";
  outputdoc.write(disphelp);
}

// -->
</script>

</head>
<body bgcolor="00cccc" onLoad="getValues();">

  <p class=mediumNavyCenterBold>Explore the relative merits of three different
  types of error-detection codes:
  <br>Cyclic, Hamming, and Residue.</p>

  <FORM name=eceform1>

  <p align=center>Enter a data word between 4 and 16-bits long
  using only 0's and 1's
  <br><INPUT TYPE="TEXT" NAME="dataword"></p>


  <p align=center>Select generator polynomial for Cyclic Code:<br>
     <select name=poly>
       <option VALUE=0>X^3 + X + 1</option>
       <option VALUE=1>X^4 + X + 1</option>
       <option VALUE=2>X^5 + X^2 + 1</option>
       <option VALUE=3>X^6 + X + 1</option>
       <option VALUE=4>X^7 + X^3 + 1</option>
       <option VALUE=5>X^8 + X^4 + X^3 + X^2 + 1</option>
     </select></p>

  <p align=center>Select number of parity bits for Hamming Code:<br>
     <select name=chkbit>
       <option VALUE=0>3</option>
       <option VALUE=1>4</option>
       <option VALUE=2>5</option>
       <option VALUE=3>6</option>
     </select></p>

  <p align=center>Select number of residue bits for Residue Code:<br>
     <select name=duebit>
       <option VALUE=0>3</option>
       <option VALUE=1>4</option>
       <option VALUE=2>5</option>
       <option VALUE=3>6</option>
     </select></p>

  <p align=center><INPUT TYPE=SUBMIT NAME=analyze VALUE="Analyze" onClick=mainMenu("analyze")>
  <br><INPUT TYPE=SUBMIT NAME=helpme  VALUE="Help & Info" onClick=mainMenu("help")>
<!--
  <br><INPUT TYPE=SUBMIT NAME=inform  VALUE="Info" onClick=mainMenu("info")>
-->
  </p>

  </FORM>
  <hr align=center>

  <p class=mediumNavyCenterBold>Perform Exhaustive Error Analysis
  to determine the type of bit errors that can be detected.</p>

  <FORM name=eceform2>

  <p align=center>Enter number of bit errors per word up to a maximum
  length of the (smallest) code word.
  <br><INPUT TYPE=TEXT SIZE="2" NAME="errlen"></p>

  <p align=center>
  Calculate percent of all possible n-bit errors detected:
  <br><span class=mediumNavyCenterBold>(This option may take some time to calculate.)</span>
  <br><INPUT TYPE=SUBMIT NAME=biterror VALUE="Bit Error" onClick=mainMenu("biterror")>
  </p>

  <p align=center>
  Calculate percent of all n-length burst errors detected:
  <br><INPUT TYPE=SUBMIT NAME=bursterror  VALUE="Burst Error" onClick=mainMenu("bursterror")>
  </p>
  </FORM>


</body>
</html>
