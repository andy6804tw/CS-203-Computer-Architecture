

<HTML>

<HEAD>

<TITLE>Berger Code</TITLE>


<SCRIPT language=JavaScript><!--

var  carryMatrix = new Array(32);
var  sumMatrix = new Array(32);
var  carry = new Array(32);
var  sum = new Array(32);
var  faulty = null;
var  faultyMatrix = null;
var  carryEditWindow = null;
var  Global_X = "";
var  Global_Y = "";
var  Global_length=0;
var  OP_checked = 7 ;
var  type_checked = 2 ;
var  start = 0 ;


function clear(form)
{
		form.datawordX.value="";
		form.datawordY.value="";
		form.encodewordX.value="";
		form.encodewordY.value="";
		form.result.value="";
		form.Berger.value="";

		form.remainder.value = "";

}

function clear_output(form)
{
	
	form.remainder.value = "";
	
}



function is_binary(data)
{
	for (i=0;i<data.length;i++)
	{

var digit=parseInt(data.substring(i,i+1));
		if ((digit != 0) && (digit != 1))
		{

			return false;
		}

	}

	return true;

}

function is_hex(data)
{
	for (i=0;i<data.length;i++)
	{

		var digit=parseInt(data.substring(i,i+1),16);
		if (!((digit >= 0) && (digit <= 15)))
			return false;
	}
return true;
}


function hex_to_binary(data)
{
	var decimal = parseInt(data, 16);
	var binary = decimal.toString(2);
	return binary;
}

function binary_to_hex(data)
{
	var decimal = parseInt(data, 2);
	var hex = decimal.toString(16);
	return hex;
}

function BergerCode(data)
{	
	var count = 0;
	for (i=0;i<data.length;i++)
	{
	var digit=parseInt(data.substring(i,i+1));
		if (digit == 1) 
		{

			count++;
		}
	}		
	
	return count;

}

function viewandmodifytemp()
{	
	if(!checkinputs(document.inputForm)) return false;

		if (carryEditWindow == null)
			carryEditWindow = window.open("", "", "scrollbars=yes, resizable=yes, width=600, height=600");
		else
		{
			if (carryEditWindow.closed)
				carryEditWindow = window.open("", "", "scrollbars=yes, resizable=yes, width=600, height=600");
		}
		carryEditWindow.opener = self;

		//  Insert script to handle carry data changes
		carryEditWindow.document.open();
		carryEditWindow.document.write("<HTML><HEAD><TITLE>Edit carrys</TITLE>");

		carryEditWindow.document.write ("<SCRIPT LANGUAGE=\"JavaScript\">");
		carryEditWindow.document.write ("function handlecarryElementChange(row, col)");
		carryEditWindow.document.write ("{opener.handlecarryMatrixChange(row, col);}");
		carryEditWindow.document.write ("function handlesumElementChange(row, col)");
		carryEditWindow.document.write ("{opener.handlesumMatrixChange(row, col);}");
		carryEditWindow.document.write ("function carryElementChange(col)");
		carryEditWindow.document.write ("{opener.carryChange(col);}");
		carryEditWindow.document.write ("function sumElementChange(col)");
		carryEditWindow.document.write ("{opener.sumChange(col);}");

		carryEditWindow.document.write ("</SCRIPT></HEAD><BODY BGCOLOR=beige>");
		
		encode(document.inputForm);
		
		len = parseInt(document.inputForm.NumBits.value);
		displayLine = "" ;
		if(OP_checked <=2)
		{
			displayLine += "<B>The Outer Coding Operation for logic operation is shown below...simply click a bit to toggle it, thus inject a fault.";
			displayLine += "<BR><BR><h2>Outer Coding Operation</h2>";
			displayLine += "<FORM><TABLE  BORDER>";
			displayLine += "<TR>"
			for (i = len; i >= 1; i--)
				displayLine += "<TH ALIGN=CENTER WIDTH=25>L<SUB>" + i + "</SUB></TH>";
			displayLine += "</TR>"
			displayLine += "<TR>"
		
			for (column = 0; column < len ; column++)
			{
				if (faulty[column]==0)
				displayLine += "<TD WIDTH=25><INPUT SIZE=2 TYPE=\"text\" VALUE="
								+ sum[column]
								+ " readonly"
								+ " ONFOCUS=\"sumElementChange(" + column + ")\"></TD>";
				else
				displayLine += "<TD WIDTH=25 BGCOLOR=red><INPUT SIZE=2 TYPE=\"text\" VALUE="
								+ sum[column]
								+ " readonly"
								+ " ONFOCUS=\"sumElementChange(" + column + ")\"></TD>";
			}
			
		}
		if(OP_checked ==3)
		{
			displayLine += "<B>The Internal Carry/Sum Arrays for <FONT COLOR=red>Ripple Carry Adder</FONT> are shown below...simply click a bit ONCE to toggle it, thus inject a fault.Note that a fault can propagate and affect other bits. If a Carry/Sum bit is clicked TWICE, that means the corresponding Adder does NOT has fault any more.";
			displayLine += "<BR><BR><h2>Internal Carry Array</h2>";
			displayLine += "<FORM><TABLE  BORDER>";
			displayLine += "<TR>"
			for (i = len; i >= 1; i--)
				displayLine += "<TH ALIGN=CENTER WIDTH=25>C<SUB>" + i + "</SUB></TH>";
			displayLine += "</TR>"
			displayLine += "<TR>"
		
			for (column = 0; column < len ; column++)
			{
				if (faulty[column]==0)
				displayLine += "<TD WIDTH=25><INPUT SIZE=2 TYPE=\"text\" VALUE="
								+ carry[column]
								+ " readonly"
								+ " ONFOCUS=\"carryElementChange(" + column + ")\"></TD>";	
				else
				displayLine += "<TD WIDTH=25 BGCOLOR=red><INPUT SIZE=2 TYPE=\"text\" VALUE="
								+ carry[column]
								+ " readonly"
								+ " ONFOCUS=\"carryElementChange(" + column + ")\"></TD>";	
			}
			displayLine += "</TABLE><BR><BR><h2>Internal Sum Array</h2>";
			displayLine += "<TABLE  BORDER>";
			displayLine += "<TR>"
			for (i = len; i >= 1; i--)
				displayLine += "<TH ALIGN=CENTER WIDTH=25>S<SUB>" + i + "</SUB></TH>";
			displayLine += "</TR>"
			displayLine += "<TR>"
		
			for (column = 0; column < len ; column++)
			{
			
				if (faulty[column]==0)
				displayLine += "<TD WIDTH=25><INPUT SIZE=2 TYPE=\"text\" VALUE="
								+ sum[column]
								+ " readonly"
								+ " ONFOCUS=\"sumElementChange(" + column + ")\"></TD>";
				else
				displayLine += "<TD WIDTH=25 BGCOLOR=red><INPUT SIZE=2 TYPE=\"text\" VALUE="
								+ sum[column]
								+ " readonly"
								+ " ONFOCUS=\"sumElementChange(" + column + ")\"></TD>";
			}
			
		}
		
		if(OP_checked ==4)
		{
			displayLine += "<B>The Internal Borrow/Difference Arrays for <FONT COLOR=red>Ripple Borrow Subtractor</FONT> are shown below...simply click a bit ONCE to toggle it, thus inject a fault.Note that a fault can propagate and affect other bits. If a Borrow/Difference bit is clicked TWICE, that means the corresponding Adder does NOT has fault any more.";
			displayLine += "<BR><BR><h2>Internal Borrow Array</h2>";
			displayLine += "<FORM><TABLE  BORDER>";
			displayLine += "<TR>"
			for (i = len; i >= 1; i--)
				displayLine += "<TH ALIGN=CENTER WIDTH=25>B<SUB>" + i + "</SUB></TH>";
			displayLine += "</TR>"
			displayLine += "<TR>"
		
			for (column = 0; column < len ; column++)
			{
			
				if (faulty[column]==0)
				displayLine += "<TD WIDTH=25><INPUT SIZE=2 TYPE=\"text\" VALUE="
								+ carry[column]
								+ " readonly"
								+ " ONFOCUS=\"carryElementChange(" + column + ")\"></TD>";	
				else
				displayLine += "<TD WIDTH=25 BGCOLOR=red><INPUT SIZE=2 TYPE=\"text\" VALUE="
								+ carry[column]
								+ " readonly"
								+ " ONFOCUS=\"carryElementChange(" + column + ")\"></TD>";	
			}
			displayLine += "</TABLE><BR><BR><h2>Internal Difference Array</h2>";
			displayLine += "<TABLE  BORDER>";
			displayLine += "<TR>"
			for (i = len; i >= 1; i--)
				displayLine += "<TH ALIGN=CENTER WIDTH=25>D<SUB>" + i + "</SUB></TH>";
			displayLine += "</TR>"
			displayLine += "<TR>"
		
			for (column = 0; column < len ; column++)
			{
			
				if (faulty[column]==0)
				displayLine += "<TD WIDTH=25><INPUT SIZE=2 TYPE=\"text\" VALUE="
								+ sum[column]
								+ " readonly"
								+ " ONFOCUS=\"sumElementChange(" + column + ")\"></TD>";
				else
				displayLine += "<TD WIDTH=25 BGCOLOR=red><INPUT SIZE=2 TYPE=\"text\" VALUE="
								+ sum[column]
								+ " readonly"
								+ " ONFOCUS=\"sumElementChange(" + column + ")\"></TD>";
			}
			
		}
		
		if(OP_checked ==5)
		{
			displayLine += "<B>The Internal Carry/Sum Matrix for <FONT COLOR=red>Braun's Array Multiplier</FONT> are shown below...simply click a bit ONCE to toggle it, thus inject a fault.Note that a fault can propagate and affect following bits. If a Carry/Sum bit is clicked TWICE, that means the corresponding Array Adder does NOT has fault any more.";
			displayLine += "<BR><BR><h2>Internal Carry Matrix</h2>";
			displayLine += "<FORM><TABLE  BORDER>";
			displayLine += "<TR>"
			for (i = len-1; i >= 1; i--)
				displayLine += "<TH ALIGN=CENTER WIDTH=25>C<SUB>" + i + "</SUB></TH>";
			displayLine += "</TR>"
			for (row=0; row<len ; row++)
			{
			displayLine += "<TR>"
		
			for (column = 1; column < len ; column++)
			{
				if(faultyMatrix[row][column]==0)
				displayLine += "<TD WIDTH=25><INPUT SIZE=2 TYPE=\"text\" VALUE="
								+ carryMatrix[row][column]
								+ " readonly"
								+ " ONFOCUS=\"handlecarryElementChange(" + row + "," + column + ")\"></TD>";	
				else
				displayLine += "<TD WIDTH=25 BGCOLOR=red><INPUT SIZE=2 TYPE=\"text\" VALUE="
								+ carryMatrix[row][column]
								+ " readonly"
								+ " ONFOCUS=\"handlecarryElementChange(" + row + "," + column + ")\"></TD>";	
				
			}
			displayLine += "</TR>"
			}
			displayLine += "</TABLE><BR><BR><h2>Internal Sum Array</h2>";
			displayLine += "<TABLE  BORDER>";
			displayLine += "<TR>"
			for (i = len-1; i >= 1; i--)
				displayLine += "<TH ALIGN=CENTER WIDTH=25>S<SUB>" + i + "</SUB></TH>";
			displayLine += "</TR>"
			for (row=0; row<len ; row++)
			{
			displayLine += "<TR>"
		
			for (column = 1; column < len ; column++)
			{
				if(faultyMatrix[row][column]==0)
				displayLine += "<TD WIDTH=25><INPUT SIZE=2 TYPE=\"text\" VALUE="
								+ sumMatrix[row][column]
								+ " readonly"
								+ " ONFOCUS=\"handlesumElementChange(" + row + "," + column + ")\"></TD>";	
				else
				displayLine += "<TD WIDTH=25 BGCOLOR=red><INPUT SIZE=2 TYPE=\"text\" VALUE="
								+ sumMatrix[row][column]
								+ " readonly"
								+ " ONFOCUS=\"handlesumElementChange(" + row + "," + column + ")\"></TD>";	
			}
			displayLine += "</TR>"
			}
			
		}
		
		if(OP_checked ==6)
		{
			displayLine += "<B>The Internal Carry/Sum Matrix for <FONT COLOR=red>Guild's Nonrestoring Array Divider</FONT> are shown below...simply click a bit ONCE to toggle it, thus inject a fault.Note that a fault can propagate and affect following bits. If a Carry/Sum bit is clicked TWICE, that means the corresponding Array Adder does NOT has fault any more.";
			displayLine += "<BR><BR><h2>Internal Carry Matrix</h2>";
			displayLine += "<FORM><TABLE  BORDER>";
			displayLine += "<TR>"
			for (i = len+1; i >= 1; i--)
				displayLine += "<TH ALIGN=CENTER WIDTH=25>C<SUB>" + i + "</SUB></TH>";
			displayLine += "</TR>"
			for (row=0; row<=len ; row++)
			{
			displayLine += "<TR>"
		
			for (column = 0; column <= len ; column++)
			{
			
				if(faultyMatrix[row][column]==0)
				displayLine += "<TD WIDTH=25><INPUT SIZE=2 TYPE=\"text\" VALUE="
								+ carryMatrix[row][column]
								+ " readonly"
								+ " ONFOCUS=\"handlecarryElementChange(" + row + "," + column + ")\"></TD>";	
				else
				displayLine += "<TD WIDTH=25 BGCOLOR=red><INPUT SIZE=2 TYPE=\"text\" VALUE="
								+ carryMatrix[row][column]
								+ " readonly"
								+ " ONFOCUS=\"handlecarryElementChange(" + row + "," + column + ")\"></TD>";	
			}
			displayLine += "</TR>"
			}
			displayLine += "</TABLE><BR><BR><h2>Internal Sum Array</h2>";
			displayLine += "<TABLE  BORDER>";
			displayLine += "<TR>"
			for (i = len+1; i >= 1; i--)
				displayLine += "<TH ALIGN=CENTER WIDTH=25>S<SUB>" + i + "</SUB></TH>";
			displayLine += "</TR>"
			for (row=0; row<=len ; row++)
			{
			displayLine += "<TR>"
		
			for (column = 0; column <=len ; column++)
			{
			
				if(faultyMatrix[row][column]==0)
				displayLine += "<TD WIDTH=25><INPUT SIZE=2 TYPE=\"text\" VALUE="
								+ sumMatrix[row][column]
								+ " readonly"
								+ " ONFOCUS=\"handlesumElementChange(" + row + "," + column + ")\"></TD>";	
				else
				displayLine += "<TD WIDTH=25 BGCOLOR=red><INPUT SIZE=2 TYPE=\"text\" VALUE="
								+ sumMatrix[row][column]
								+ " readonly"
								+ " ONFOCUS=\"handlesumElementChange(" + row + "," + column + ")\"></TD>";	
			}
			displayLine += "</TR>"
			}
			
		}
		displayLine += "</TABLE></FORM>" ;
		carryEditWindow.document.write(displayLine);

		
		carryEditWindow.document.write("</BODY></HTML>");

		
	
}

function handlecarryMatrixChange(row, col)
{
	var	command = new String();

	if (carryMatrix[row][col] == 1)
		carryMatrix[row][col] = 0;
	else
		carryMatrix[row][col] = 1;
	if (faultyMatrix[row][col] == 1)
		faultyMatrix[row][col] = 0;
	else
		faultyMatrix[row][col] = 1;

	
	viewandmodifytemp();
}

function handlesumMatrixChange(row, col)
{
	var	command = new String();

	if (sumMatrix[row][col] == 1)
		sumMatrix[row][col] = 0;
	else
		sumMatrix[row][col] = 1;
	if (faultyMatrix[row][col] == 1)
		faultyMatrix[row][col] = 0;
	else
		faultyMatrix[row][col] = 1;

	
	viewandmodifytemp();
}

function carryChange(col)
{

	if (carry[col] == 1)
		carry[col] = 0;
	else
		carry[col] = 1;

	if (faulty[col] == 0)
		faulty[col] = 1;
	else faulty[col] = 0;
	viewandmodifytemp();
}

function sumChange(col)
{

	if (sum[col] == 1)
		sum[col] = 0;
	else
		sum[col] = 1;
	if (faulty[col] == 0)
		faulty[col] = 1;
	else faulty[col] = 0;
	
	viewandmodifytemp();
}

function checkinputs(form)
{
	len = parseInt(form.NumBits.value);
	if (form.datawordX.value == "") {
    alert("Please input data word X");
    return false
  }

  if (form.datawordY.value == "") {
    alert("Please input data word Y");
    return false
  }

  if (form.type[0].checked && ((!is_binary(form.datawordX.value)) || (!is_binary(form.datawordY.value))))
	{

		alert("Data Word must be in binary form");
		clear(form);
		return false ;
	}


  if (form.type[1].checked && ((!is_hex(form.datawordX.value)) || (!is_hex(form.datawordY.value))))
	{

		alert("Data Word must be in hex form");
		clear(form);
		return false;
	}
	
  if (form.type[1].checked)
  	{
  	temp_codeX = hex_to_binary(form.datawordX.value);
	temp_codeY = hex_to_binary(form.datawordY.value);
  	if ((!form.Operation[6].checked && len < temp_codeX.length) || (form.Operation[6].checked && 2*len < temp_codeX.length) || len < temp_codeY.length )
	{
		alert("Number of bits is less than input!!");
		return false;
	}
	}
	
  if (form.type[0].checked)
	if ((!form.Operation[6].checked && len < form.datawordX.value.length) || (form.Operation[6].checked && 2*len < form.datawordX.value.length) || len < form.datawordY.value.length)
	{
		alert("Number of bits is less than input!!");
		return false;
	}
  
	return true;
}

function Help()
{
	parent.resultsFrame.location.href="./instruction.html"
}

function encodeArith(form) {

clear_output(form);
  	if(!checkinputs(form)) return false;

 len = parseInt(form.NumBits.value);
 Q1 = "";
 R1 = "";

  if (form.type[1].checked)
	{	
	temp_codeX = hex_to_binary(form.datawordX.value);
	temp_codeY = hex_to_binary(form.datawordY.value);

		datawordX = parseInt(form.datawordX.value, 16);
 		datawordY = parseInt(form.datawordY.value, 16);
 		encodewordX = len - BergerCode(hex_to_binary(form.datawordX.value));
		encodewordY = len - BergerCode(hex_to_binary(form.datawordY.value));
	}

  if (form.type[0].checked)
	{	
		temp_codeX = form.datawordX.value;
		temp_codeY = form.datawordY.value;
	
  		datawordX = parseInt(form.datawordX.value, 2);
  		datawordY = parseInt(form.datawordY.value, 2);
  		encodewordX = len - BergerCode(form.datawordX.value) ;
		encodewordY = len - BergerCode(form.datawordY.value) ;
  	}

  var temp_result;
  var inter_string;

  for(i=temp_codeX.length;i<len;i++)  { temp_codeX = 0 + temp_codeX; }
  for(i=temp_codeY.length;i<len;i++)  { temp_codeY = 0 + temp_codeY; }

  if (form.Operation[0].checked)
	{	
		result = datawordX & datawordY;
		temp_result = datawordX | datawordY;
		inter_string = temp_result.toString(2);
		for(i=inter_string.length;i<len;i++)  { inter_string = 0 + inter_string; }
		
		OP = "AND" ;
		Express = "<TD><B>X<SUB>c</SUB> + Y<SUB>c</SUB> - (X <FONT COLOR=red>or</FONT> Y)<SUB>c</SUB></B>" ;
		

		OUT = result.toString(2);
		for(i=OUT.length;i<len;i++)  { OUT = 0 + OUT; }
		circuit = "Logic AND" ;
		picture1 = "<IMG SRC = logic.jpg>" ;
		Nresult = len - BergerCode(OUT);	

		Internal = "<TR> <TD><B>X <FONT COLOR=red>or</FONT> Y:</B>"; 
		Internal += "<TD><TD><TD><B>Coding Operation</B><TD> ";	
		if(start==0 || Global_X != temp_codeX || Global_Y != temp_codeY || Global_length != len || !form.Operation[OP_checked].checked || !form.type[type_checked].checked)
		{	sum = new Array(len);
			faulty = new Array(len);
			for (i=0;i<len;i++)	faulty[i]=0;
			for(i=0;i<len;i++)	
				{bit=parseInt(inter_string.substring(i,i+1));
				sum[i] = bit ;
				}
		}
			
					  
		for(i=0;i<len;i++)				
			{	bit = sum[i];
				if (bit==0)	Internal += "<TD><FONT COLOR=blue> <B>" + bit + "</FONT></B>" ;
				else		Internal += "<TD><FONT COLOR=green> <B>" + bit + "</FONT></B>" ;
			}
		inter_string = "";
		for(i=0;i<len;i++) inter_string = inter_string + sum[i] ;
		temp_result = len - BergerCode(inter_string) ;
		Berger = encodewordX + encodewordY - temp_result;
		
		table = "<TABLE BORDER>"
		table += "<TR>"
	table += "<TD>" + "<B>X<SUB>c</SUB> </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in data X " + "</TD><TD><B><FONT COLOR=blue>" + encodewordX + "</B></FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>Y<SUB>c</SUB> </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in data Y " + "</TD><TD><B><FONT COLOR=blue>" + encodewordY + "</FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>X <FONT COLOR=red>or</FONT> Y </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in Outer Coding Operation " + "</TD><TD><B><FONT COLOR=blue>" + temp_result + "</FONT></TD>"
	table += "</TR></TABLE>"

	OP_checked = 0;
	}
  
  if (form.Operation[1].checked)
	{	
		result = datawordX | datawordY;
		temp_result = datawordX & datawordY;
		inter_string = temp_result.toString(2);
		for(i=inter_string.length;i<len;i++)  { inter_string = 0 + inter_string; }
		
		OP = "OR" ;
		Express = "<TD><B>X<SUB>c</SUB> + Y<SUB>c</SUB> - (X <FONT COLOR=red>and</FONT> Y)<SUB>c</SUB></B>" ;
		
			
		OUT = result.toString(2);
		for(i=OUT.length;i<len;i++)  { OUT = 0 + OUT; }
		circuit = "Logic OR" ;
		picture1 = "<IMG SRC = logic.jpg>" ;
		Nresult = len - BergerCode(OUT);	

		Internal = "<TR> <TD><B>X <FONT COLOR=red>and</FONT> Y:</B>"; 
		Internal += "<TD><TD><TD><B>Outer Coding Operation</B><TD> ";	
		if(start==0 || Global_X != temp_codeX || Global_Y != temp_codeY || Global_length != len || !form.Operation[OP_checked].checked || !form.type[type_checked].checked)
		{	sum = new Array(len);
			faulty = new Array(len);
			for (i=0;i<len;i++)	faulty[i]=0;
			for(i=0;i<len;i++)	
				{bit=parseInt(inter_string.substring(i,i+1));
				sum[i] = bit ;
				}
		}
		
					  
		for(i=0;i<len;i++)				
			{	bit = sum[i] ; 
				if (bit==0)	Internal += "<TD><FONT COLOR=blue> <B>" + bit + "</FONT></B>" ;
				else		Internal += "<TD><FONT COLOR=green> <B>" + bit + "</FONT></B>" ;
			}
		inter_string = "";
		for(i=0;i<len;i++) inter_string = inter_string + sum[i] ;
		temp_result = len - BergerCode(inter_string);
		Berger = encodewordX + encodewordY - temp_result;	

		table = "<TABLE BORDER>"
		table += "<TR>"
	table += "<TD>" + "<B>X<SUB>c</SUB> </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in data X " + "</TD><TD><B><FONT COLOR=blue>" + encodewordX + "</B></FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>Y<SUB>c</SUB> </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in data Y " + "</TD><TD><B><FONT COLOR=blue>" + encodewordY + "</FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>X <FONT COLOR=red>and</FONT> Y </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in Outer Coding Operation " + "</TD><TD><B><FONT COLOR=blue>" + temp_result + "</FONT></TD>"
	table += "</TR></TABLE>"
	OP_checked = 1;

	}

  if (form.Operation[2].checked)
	{	
		result = datawordX ^ datawordY;
		temp_result = datawordX & datawordY;
		inter_string = temp_result.toString(2);
		for(i=inter_string.length;i<len;i++)  { inter_string = 0 + inter_string; }
		
		OP = "XOR" ;
		Express = "<TD><B>X<SUB>c</SUB> + Y<SUB>c</SUB> - 2(X <FONT COLOR=red>and</FONT> Y)<SUB>c</SUB> + n</B>" ;

		OUT = result.toString(2);
		for(i=OUT.length;i<len;i++)  { OUT = 0 + OUT; }
		circuit = "Logic XOR" ;
		picture1 = "<IMG SRC = logic.jpg>" ;
		Nresult = len - BergerCode(OUT);
	
		Internal = "<TR> <TD><B>X <FONT COLOR=red>and</FONT> Y:</B>"; 
		Internal += "<TD><TD><TD><B>Outer Coding Operation</B><TD> ";	
		if(start==0 || Global_X != temp_codeX || Global_Y != temp_codeY || Global_length != len || !form.Operation[OP_checked].checked || !form.type[type_checked].checked)
		{	sum = new Array(len);
			faulty = new Array(len);
			for (i=0;i<len;i++)	faulty[i]=0;
			for(i=0;i<len;i++)	
				{bit=parseInt(inter_string.substring(i,i+1));
				 sum[i] = bit ;
				}
		}
					  
		for(i=0;i<len;i++)				
			{	bit=sum[i];
				if (bit==0)	Internal += "<TD><FONT COLOR=blue> <B>" + bit + "</FONT></B>" ;
				else		Internal += "<TD><FONT COLOR=green> <B>" + bit + "</FONT></B>" ;
			}
		inter_string = "";
		for(i=0;i<len;i++) inter_string = inter_string + sum[i] ;
		temp_result = len -BergerCode(inter_string) ;
		Berger = encodewordX + encodewordY - 2*temp_result + len;

		table = "<TABLE BORDER>"
		table += "<TR>"
	table += "<TD>" + "<B>X<SUB>c</SUB> </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in data X " + "</TD><TD><B><FONT COLOR=blue>" + encodewordX + "</B></FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>Y<SUB>c</SUB> </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in data Y " + "</TD><TD><B><FONT COLOR=blue>" + encodewordY + "</FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>X <FONT COLOR=red>and</FONT> Y </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in Outer Coding Operation " + "</TD><TD><B><FONT COLOR=blue>" + temp_result + "</FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>n </TD><TD><B> Number of bits" + "</TD><TD><B><FONT COLOR=blue>" + len +"</B></FONT></TD>"
	table += "</TR></TABLE>"

	OP_checked = 2;

	}

  if (form.Operation[3].checked)
	{	
		result = datawordX + datawordY;
		A = datawordX.toString(2);
		B = datawordY.toString(2);
		C = "";
		OUT = "";
		for(i=0;i<len;i++)
		{	if (i >= A.length) { A = 0 + A ;}
			if (i >= B.length) { B = 0 + B ;}
		}
		
		if(start==0 || Global_X != temp_codeX || Global_Y != temp_codeY || Global_length != len || !form.Operation[OP_checked].checked || !form.type[type_checked].checked)
		{	sum = new Array(len);
			faulty = new Array(len);
			for (i=0;i<len;i++)	faulty[i]=0;
			carry =  new Array(len);
			for(i=len-1;i>=0;i--)
			{	
			digitA=parseInt(A.substring(i,i+1));
			digitB=parseInt(B.substring(i,i+1));
			if(i==len-1) 
			{
				digitC = digitA & digitB ;
				digitOUT = digitA ^ digitB ;
				C = digitC + C;
				OUT = digitOUT + OUT;
				carry[i] = digitC;
				sum[i] = digitOUT;
			}
			else
			{
				digitC = (digitA & digitB) | ((digitA | digitB) &  Cin);
				digitOUT = digitA ^ digitB ^ Cin ;
				OUT = digitOUT + OUT ;
				C = digitC + C;
				carry[i] = digitC;
				sum[i] = digitOUT;
			}
			 Cin =  digitC ;
			}
		}
		else
		{
			
		for(i=len-1;i>=0;i--)
		{					
				C = carry[i] + C;
				OUT = sum[i] + OUT;	
		}
		}
		
		Num_Carry = len - BergerCode(C);
		Nresult = len - BergerCode(OUT);	
		Berger = encodewordX + encodewordY - Num_Carry + parseInt(C.substring(0,1));
		
		circuit = "Ripple Carry Adder" ;
		picture1 = "<IMG SRC = add_subtract.jpg>" ;
		OP = "ADD" ;	
		Express = "<TD><B>X<SUB>c</SUB> + Y<SUB>c</SUB> - C<SUB>c</SUB> + c<SUB>out</SUB></B>" ;
		

		Internal = "<TR> <TD><B>C:</B>"; 
		Internal += "<TD><TD><TD><B>Internal Carry</B><TD> ";	
		for(i=0;i<len;i++)
			{
				bit=parseInt(C.substring(i,i+1));
				bit1=parseInt(OUT.substring(i,i+1));
				carry[i] = bit ;
				sum[i] = bit1;
				if (bit==0)	Internal += "<TD><FONT COLOR=blue> <B>" + bit + "</FONT></B>" ;
				else		Internal += "<TD><FONT COLOR=green> <B>" + bit + "</FONT></B>" ;
			}
		
		table = "<TABLE BORDER>"
	table += "<TR>"
	table += "<TD>" + "<B>X<SUB>c</SUB> </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in data X " + "</TD><TD><B><FONT COLOR=blue>" + encodewordX + "</B></FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>Y<SUB>c</SUB> </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in data Y " + "</TD><TD><B><FONT COLOR=blue>" + encodewordY + "</FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>C<SUB>c</SUB> </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in internal carry C " + "</TD><TD><B><FONT COLOR=blue>" + Num_Carry + "</FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>c<SUB>out</SUB> </TD><TD><B> Final Carry bit" + "</TD><TD><B><FONT COLOR=blue>" + parseInt(C.substring(0,1))+ "</B></FONT></TD>"
	table += "</TR></TABLE>"

	OP_checked = 3;
	}

  
  if (form.Operation[4].checked)
	{	
		if(datawordX < datawordY)
		{

		alert("Data X must be larger than Data Y");
		
		return false ;
		}
	
		result = datawordX - datawordY;
		A = datawordX.toString(2);
		B = datawordY.toString(2);
		C = "";
		OUT = "";
		for(i=0;i<len;i++)
		{	if (i >= A.length) { A = 0 + A ;}
			if (i >= B.length) { B = 0 + B ;}
		}
		
		if(start==0 || Global_X != temp_codeX || Global_Y != temp_codeY || Global_length != len || !form.Operation[OP_checked].checked || !form.type[type_checked].checked)
		{	sum = new Array(len);
			faulty = new Array(len);
			for (i=0;i<len;i++)	faulty[i]=0;
			carry =  new Array(len);
			for(i=len-1;i>=0;i--)
			{	
			digitA=parseInt(A.substring(i,i+1));
			digitB=parseInt(B.substring(i,i+1));
			if(i==len-1) 
			{
				digitC = (~digitA) & digitB ;
				digitOUT = digitA ^ digitB ;
				C = digitC + C;
				OUT = digitOUT + OUT;
				carry[i] = digitC;
				sum[i] = digitOUT;
			}
			else
			{
				digitC = ((~digitA) & digitB) | (((~digitA) ^ digitB) &  Cin);
				digitOUT = digitA ^ digitB ^ Cin ;
				OUT = digitOUT + OUT ;
				C = digitC + C;
				carry[i] = digitC;
				sum[i] = digitOUT;
			}
			 Cin =  digitC ;
			}
		}
		else
		{
			
		for(i=len-1;i>=0;i--)
		{					
				C = carry[i] + C;
				OUT = sum[i] + OUT;
		}
		}
		
		Num_Borrow = len - BergerCode(C);

		Berger = encodewordX - encodewordY + Num_Borrow - parseInt(C.substring(0,1));
		result = parseInt(OUT,2);
		
		circuit = "Ripple Borrow Subtractor" ;
		picture1 = "<IMG SRC = add_subtract.jpg>" ;
		OP = "SUB" ;	
		Express = "<TD><B>X<SUB>c</SUB> - Y<SUB>c</SUB> + B<SUB>c</SUB> - b<SUB>out</SUB></B>" ;
		Nresult = len - BergerCode(OUT);	
		
		Internal = "<TR> <TD><B>B:</B>"; 
		Internal += "<TD><TD><TD><B>Internal Borrow</B><TD> ";
		for(i=0;i<len;i++)
			{
				bit=parseInt(C.substring(i,i+1));
				bit1=parseInt(OUT.substring(i,i+1));
				carry[i] = bit ;
				sum[i] = bit1;
				if (bit==0)	Internal += "<TD><FONT COLOR=blue> <B>" + bit + "</FONT></B>" ;
				else		Internal += "<TD><FONT COLOR=green> <B>" + bit + "</FONT></B>" ;
			}
	

		table = "<TABLE BORDER>"
	table += "<TR>"
	table += "<TD>" + "<B>X<SUB>c</SUB> </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in data X " + "</TD><TD><B><FONT COLOR=blue>" + encodewordX + "</B></FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>Y<SUB>c</SUB> </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in data Y " + "</TD><TD><B><FONT COLOR=blue>" + encodewordY + "</FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>B<SUB>c</SUB> </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in internal borrow B " + "</TD><TD><B><FONT COLOR=blue>" + Num_Borrow + "</FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>b<SUB>out</SUB> </TD><TD><B> Final Borrow bit" + "</TD><TD><B><FONT COLOR=blue>" + parseInt(C.substring(0,1))+ "</B></FONT></TD>"
	table += "</TR></TABLE>"
	
	OP_checked = 4;

	}


  if (form.Operation[5].checked)
	{	
		result = datawordX * datawordY;
		A = datawordX.toString(2);
		B = datawordY.toString(2);
		C = "";
		S = "";
		var Inter_C = new Array(len);
		OUT = "";
		var Inter_S = new Array(len);
		P = "";
		var A_array = new Array(len);
		var B_array = new Array(len);
		for(i=0;i<len;i++)
		{	if (i >= A.length) { A = 0 + A ;}
			if (i >= B.length) { B = 0 + B ;}
		}
		for(i=0;i<len;i++)
		{
			A_array[len-1-i] = parseInt(A.substring(i,i+1));
			B_array[len-1-i] = parseInt(B.substring(i,i+1));
		}
		P = (A_array[0] & B_array[0]) + P;
	if(start==0 || Global_X != temp_codeX || Global_Y != temp_codeY || Global_length != len || !form.Operation[OP_checked].checked || !form.type[type_checked].checked)
	{	carryMatrix = new Array(len);
		sumMatrix = new Array(len);
		faultyMatrix = new Array(len);
		for(i=0;i<len;i++)
		{
			carryMatrix[i] = new Array(len);
			sumMatrix[i] = new Array(len);
			faultyMatrix[i] = new Array(len);
		}
		for(i=0;i<len;i++)
			for(j=0;j<len;j++)	faultyMatrix[i][j] = 0;
		for(i=0;i<len-1;i++)
		{
			temp_A = A_array[i+1] & B_array[0];
			temp_B = A_array[i] & B_array[1];
			Inter_S[i]= temp_A ^ temp_B;
			Inter_C[i]= temp_A & temp_B;
			carryMatrix[0][len-1-i] = Inter_C[i] ;
			sumMatrix[0][len-1-i] = Inter_S[i] ;
			C = Inter_C[i] + C;
			S = Inter_S[i] + S;
		}

		P = Inter_S[0] + P;
		for(i=1;i<len-1;i++)
		{	
			Inter_S[len-1] = A_array[len-1] & B_array[i];		
			for(j=0;j<len-1;j++)
			{
				temp_A = Inter_S[j+1];
				temp_B = A_array[j] & B_array[i+1];
				Inter_S[j]= temp_A ^ temp_B ^ Inter_C[j];
				Inter_C[j]= (temp_A & temp_B) | ((temp_A | temp_B) & Inter_C[j]);
				carryMatrix[i][len-1-j] = Inter_C[j] ;
				sumMatrix[i][len-1-j] = Inter_S[j] ;
				C = Inter_C[j] + C;
				S = Inter_S[j] + S;
			}
			P = Inter_S[0] + P;
		}

		Inter_S[len-1] = A_array[len-1] & B_array[len-1];

		for(j=0;j<len-1;j++)
		{
			if(j==0)	temp_B = 0;
			else		temp_B = Inter_C[j-1];
	
		 	temp_A = Inter_S[j+1];
			Inter_S[j]= temp_A ^ temp_B ^ Inter_C[j];
			Inter_C[j]= (temp_A & temp_B) | ((temp_A | temp_B) & Inter_C[j]);
			carryMatrix[len-1][len-1-j] = Inter_C[j] ;
			sumMatrix[len-1][len-1-j] = Inter_S[j] ;
			C = Inter_C[j] + C;
			S = Inter_S[j] + S;
			P = Inter_S[j] + P;
		}
	
		P = Inter_C[len-2] + P;
	}
	
	else
	{
		for(i=0;i<len-1;i++)
		{	
			
			for(j=0;j<len-1;j++)
			{	
				C = carryMatrix[i][len-1-j] + C;
				S = sumMatrix[i][len-1-j] + S;
			}
			P = sumMatrix[i][len-1] + P;
		}
		for(j=0;j<len-1;j++)
			{
				P = sumMatrix[len-1][len-1-j] + P;
				C = carryMatrix[len-1][len-1-j] + C;
				S = sumMatrix[len-1][len-1-j] + S;
			}

		P = carryMatrix[len-1][1] + P;		
			
	}
		OUT = P ;
		
		Num_Carry = len*(len-1)-BergerCode(C);

		Berger = len*encodewordX + len*encodewordY - encodewordX*encodewordY + len - Num_Carry;
		result = parseInt(OUT,2);
		
		circuit = "Braun's Array Multiplier" ;
		picture1 = "<IMG SRC = mul.jpg> <BR> <IMG SRC = mul1.jpg>" ;
		OP = "MUL" ;	
		Express = "<TD><B>nX<SUB>c</SUB> + nY<SUB>c</SUB> - X<SUB>c</SUB>Y<SUB>c</SUB> - C<SUB>c</SUB> + n" ;
		Nresult = 2*len - BergerCode(OUT);	
		
		Internal = "<TR> <TD><B>C:</B>"; 
		Internal += "<TD><TD><TD><B>Internal Carry Array</B><TD> ";	
		for(j=0;j<len-1;j++)
			{
				Internal += "<TD>" ;
				for(i=len-1;i>j;i--)	Internal += "<FONT COLOR=beige>*</FONT><BR>" ;
				for(i=j;i>=0;i--)
				{
				bit=parseInt(C.substring(i*(len-2)+j,i*(len-2)+j+1));
				if (bit==0) Internal += "<FONT COLOR=blue> <B>" + bit + "</FONT></B><BR>" ;
				else		Internal += "<FONT COLOR=green> <B>" + bit + "</FONT></B><BR>" ;
				}
				 
			}
		for(j=len-1;j<2*len-2;j++)
			{
				Internal += "<TD>" ;
				for(i=len-1;i>=j-len+2;i--)
				{
				bit=parseInt(C.substring(i*(len-2)+j,i*(len-2)+j+1));
				if (bit==0)	Internal += "<FONT COLOR=blue> <B>" + bit + "</FONT></B><BR>" ;
				else		Internal += "<FONT COLOR=green> <B>" + bit + "</FONT></B><BR>" ;
				}
				for(i=j-len+1;i>=0;i--)	Internal += "<FONT COLOR=beige>*</FONT><BR>" ;
				 
			}
		
		Internal += "<TR> <TD><B>S:</B>"; 
		Internal += "<TD><TD><TD><B>Internal Sum Array</B><TD> ";	
		for(j=0;j<len-1;j++)
			{
				Internal += "<TD>" ;
				for(i=len-1;i>j;i--)	Internal += "<FONT COLOR=beige>*</FONT><BR>" ;
				for(i=j;i>=0;i--)
				{
					if (bit==0)	Internal += "<Font COLOR=blue> <B>" + bit + "</FONT></B><BR>" ;
					else		Internal += "<Font COLOR=green> <B>" + bit + "</FONT></B><BR>" ;
				}
			}
		for(j=len-1;j<2*len-2;j++)
			{
				Internal += "<TD>" ;
				for(i=len-1;i>=j-len+2;i--)
				{
				bit=parseInt(S.substring(i*(len-2)+j,i*(len-2)+j+1));
				if (bit==0)	Internal += "<FONT COLOR=blue> <B>" + bit + "</FONT></B><BR>" ;
				else		Internal += "<FONT COLOR=green> <B>" + bit + "</FONT></B><BR>" ;
				}
				for(i=j-len+1;i>=0;i--)	Internal += "<FONT COLOR=beige>*</FONT><BR>" ;
				 
			}
		
	table = "<TABLE BORDER>"
	table += "<TR>"
	table += "<TD>" + "<B>X<SUB>c</SUB> </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in data X " + "</TD><TD><B><FONT COLOR=blue>" + encodewordX + "</B></FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>Y<SUB>c</SUB> </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in data Y " + "</TD><TD><B><FONT COLOR=blue>" + encodewordY + "</FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>C<SUB>c</SUB> </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in internal carry Array C " + "</TD><TD><B><FONT COLOR=blue>" + Num_Carry + "</FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>n </TD><TD><B> Number of bits" + "</TD><TD><B><FONT COLOR=blue>" + len +"</B></FONT></TD>"
	table += "</TR></TABLE>"

	OP_checked = 5;

	}
	
	if (form.Operation[6].checked)
	{	
		for(i=temp_codeX.length;i<2*len;i++)  { temp_codeX = 0 + temp_codeX; }
		Global_X = temp_codeX ;
		quotient = Math.floor(datawordX / datawordY);
		A = datawordX.toString(2);
		B = datawordY.toString(2);
		C = "";
		C1 = "";
		var Inter_C = new Array(len+2);
		S = "";
		var Inter_S = new Array(len+1);
		var S_last = new Array(len+1);
		Q = "";
		R = "";
		R1 = "";
		OUT = "";
		var A_array = new Array(2*len+1);
		var B_array = new Array(len+1);
		var Q_array = new Array(len+1);
		var R_array = new Array(len+1);

		for(i=0;i<len;i++)
		{	
			if (i >= B.length) { B = 0 + B ;}
		}
		for(i=0;i<2*len;i++)
		{	if (i >= A.length) { A = 0 + A ;}
		}

		for(i=0;i<len;i++)
		{
			
			B_array[len-1-i] = parseInt(B.substring(i,i+1));
		}
		for(i=0;i<2*len;i++)
		{
			A_array[2*len-1-i] = parseInt(A.substring(i,i+1));
			
		}

		Q = quotient.toString(2);
		for(i=0;i<=len;i++)
			if (i >= Q.length) { Q = 0 + Q ;}
		for(i=0;i<=len;i++)
			Q_array[len-i] = parseInt(Q.substring(i,i+1));

		Inter_C[0]=1;
		A_array[2*len] = 0;
		B_array[len] = 0;
		
	if(start==0 || Global_X != temp_codeX || Global_Y != temp_codeY || Global_length != len || !form.Operation[OP_checked].checked || !form.type[type_checked].checked)
	{
		carryMatrix = new Array(len+1);
		sumMatrix = new Array(len+1);
		faultyMatrix = new Array(len);
		for(i=0;i<len;i++)
		{
			carryMatrix[i] = new Array(len);
			sumMatrix[i] = new Array(len);
			faultyMatrix[i] = new Array(len);
		}
		for(i=0;i<len;i++)
			for(j=0;j<len;j++)	faultyMatrix[i][j] = 0;
		for(i=0;i<=len;i++)
		{
			
			temp_A = A_array[i+len];
			temp_B = B_array[i] ^ 1;
			Inter_S[i]= temp_A ^ temp_B ^ Inter_C[i] ;
			S_last[i] = Inter_S[i];
			Inter_C[i+1]= (temp_A & temp_B) | ((temp_A | temp_B) & Inter_C[i]);
			carryMatrix[0][len-i] = Inter_C[i+1] ;
			sumMatrix[0][len-i] = Inter_S[i] ;
			if(i!=len)
			{C = Inter_C[i+1] + C;
			S = Inter_S[i] + S;
			}
			
			
		}
		Q_array[len] = Inter_C[len+1];
		R_array[len] = Inter_S[len];
		R = R + Inter_S[len];
		Q1 = Q1 + Inter_C[len+1];
		for(i=len-1;i>=0;i--)
		{	
			Inter_C[0] = Q_array[i+1];	
			for(j=0;j<=len;j++)
			{
				if(j==0)	temp_A = A_array[i];
				else		temp_A = S_last[j-1];
				temp_B = B_array[j] ^ Q_array[i+1] ;
				Inter_S[j]= temp_A ^ temp_B ^ Inter_C[j];
				Inter_C[j+1]= (temp_A & temp_B) | ((temp_A | temp_B) & Inter_C[j]);
				carryMatrix[len-i][len-j] = Inter_C[j+1] ;
				sumMatrix[len-i][len-j] = Inter_S[j] ;
				if(j!=len)
				{C = Inter_C[j+1] + C;
				 S = Inter_S[j] + S;
				}
			}
			for(j=0;j<=len;j++)
				S_last[j] = Inter_S[j];

			Q_array[i] = Inter_C[len+1];
			R_array[i] = Inter_S[len];
			R = R + Inter_S[len];
			Q1 = Q1 + Inter_C[len+1];

		}
		for(i=0;i<=len-1;i++)
		{
			R1 = Inter_S[i] + R1;
		}
	}
	
	else
	{	
		for(i=len;i>=0;i--)
		{	
			
			for(j=0;j<=len;j++)
			{	
			if(j!=len)
				{C = carryMatrix[len-i][len-j] + C;
				 S = sumMatrix[len-i][len-j] + S;
				}
			}
			
			Q_array[i] = carryMatrix[len-i][0];
			R_array[i] = sumMatrix[len-i][0];
			R = R + sumMatrix[len-i][0];
			Q1 = Q1 + carryMatrix[len-i][0];

		}
		for(i=0;i<=len-1;i++)
		{
			R1 = sumMatrix[len][len-i] + R1;
		}
	
	}
		
		
		Qc = len+1-BergerCode(Q1);
		Xc = 2*len-BergerCode(A);
		Yc = len-BergerCode(B);

		Berger = Xc + BergerCode(C)+BergerCode(R)+ (2*Qc+2*Q_array[0]-len-3)*Yc-len*Qc-(len-2)*Q_array[0]-2;
		quotient = parseInt(Q1,2);
		circuit = "Guild's nonrestoring Array Divider" ;
		picture1 = "<IMG SRC = div.jpg> <BR> <IMG SRC = div1.jpg>" ;
		OP = "DIV" ;	
		Express = "<TD><B>X<SUB>c</SUB> + N(C) + N(R*) + (2Q<SUB>c</SUB>+2q<SUB>1</SUB>-n-3)Y<SUB>c</SUB> - nQ<SUB>c</SUB> - (n-2)q<SUB>1</SUB> - 2" ;
		Nresult = len - BergerCode(R1);
		result = " Remainder of Array Divider" ;
		OUT = R1 ;

		Internal = "<TR> <TD><B>C:</B>"; 
		Internal += "<TD><TD><TD><B>Internal Carry Array</B><TD> ";	
		for(j=2*len-1;j>=len;j--)
			{
				Internal += "<TD>" ;
				for(i=len;i>=j-len+1;i--)
				{
				bit=parseInt(C.substring(i*(len+1)+len-1-j,i*(len+1)+len-j));
				if (bit==0)	Internal += "<FONT COLOR=blue> <B>" + bit + "</FONT></B><BR>" ;
				else		Internal += "<FONT COLOR=green> <B>" + bit + "</FONT></B><BR>" ;
				}
				for(i=j-len;i>=0;i--)	Internal += "<FONT COLOR=beige>*</FONT><BR>" ;
				 
			}
		for(j=len-1;j>=0;j--)
			{
				Internal += "<TD>" ;
				for(i=len;i>j;i--)	Internal += "<FONT COLOR=beige>*</FONT><BR>" ;
				for(i=j;i>=0;i--)
				{
				bit=parseInt(C.substring(i*(len+1)+len-1-j,i*(len+1)+len-j));
				if (bit==0)	Internal += "<FONT COLOR=blue> <B>" + bit + "</FONT></B><BR>" ;
				else		Internal += "<FONT COLOR=green> <B>" + bit + "</FONT></B><BR>" ;
				}
				 
			}

		Internal += "<TR> <TD><B>S:</B>"; 
		Internal += "<TD><TD><TD><B>Internal Sum Array</B><TD> ";	
		for(j=2*len-1;j>=len;j--)
			{
				Internal += "<TD>" ;
				for(i=len;i>=j-len+1;i--)
				{
				bit=parseInt(S.substring(i*(len+1)+len-1-j,i*(len+1)+len-j));
				if (bit==0)	Internal += "<FONT COLOR=blue> <B>" + bit + "</FONT></B><BR>" ;
				else		Internal += "<FONT COLOR=green> <B>" + bit + "</FONT></B><BR>" ;
				}
				for(i=j-len;i>=0;i--)	Internal += "<FONT COLOR=beige>*</FONT><BR>" ;
				 
			}
		for(j=len-1;j>=0;j--)
			{
				Internal += "<TD>" ;
				for(i=len;i>j;i--)	Internal += "<FONT COLOR=beige>*</FONT><BR>" ;
				for(i=j;i>=0;i--)
				{
				bit=parseInt(S.substring(i*(len+1)+len-1-j,i*(len+1)+len-j));
				if (bit==0)	Internal += "<FONT COLOR=blue> <B>" + bit + "</FONT></B><BR>" ;
				else		Internal += "<FONT COLOR=green> <B>" + bit + "</FONT></B><BR>" ;
				}
				 
			}


	table = "<TABLE BORDER>"
	table += "<TR>"
	table += "<TD>" + "<B>X<SUB>c</SUB> </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in data X " + "</TD><TD><B><FONT COLOR=blue>" + Xc + "</B></FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>Y<SUB>c</SUB> </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in data Y " + "</TD><TD><B><FONT COLOR=blue>" + Yc + "</FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>Q<SUB>c</SUB> </TD><TD><B> Number of <FONT COLOR=blue>0</FONT> in quotient Q " + "</TD><TD><B><FONT COLOR=blue>" + Qc + "</FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>N(C) </TD><TD><B> Number of <FONT COLOR=green>1</FONT> in internal carry Array C " + "</TD><TD><B><FONT COLOR=green>" + BergerCode(C) + "</FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>N(R*) </TD><TD><B> Number of <FONT COLOR=green>1</FONT> in top remainders R* " + "</TD><TD><B><FONT COLOR=green>" + BergerCode(R) + "</FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>q<SUB>1</SUB> </TD><TD><B> Least significant bit of Q " + "</TD><TD><B><FONT COLOR=blue>" + Q_array[0] + "</FONT></TD>"
	table += "</TR><TR>"
	table += "<TD>" + "<B>n </TD><TD><B> Number of bits" + "</TD><TD><B><FONT COLOR=blue>" + len +"</B></FONT></TD>"
	table += "</TR></TABLE>"

	OP_checked = 6;
	}



 
  Bi_berger = Berger.toString(2);
  if (form.Operation[6].checked)
  {
 	
	form.remainder.value = R1;
	encodewordX = len + encodewordX;
	
  } 
  form.encodewordX.value = encodewordX.toString(2);	
  form.encodewordY.value = encodewordY.toString(2);
  
  form.result.value  = OUT;
  if (form.Operation[6].checked)
   {  
 	 form.result.value = Q1; 
   }
  form.Berger.value = Berger.toString(2);
  
  if (form.type[1].checked)
		type_checked = 1;

  if (form.type[0].checked)
		type_checked = 0;

  Global_X = temp_codeX ;
  Global_Y = temp_codeY ;
  Global_length = len ;
  
  
  if (start == 0)
  {	start = 1;
  	parent.resultsFrame.location.href="./results.html"	
  }	

  Top = "<HTML><HEAD><TITLE>Tablet</TITLE></HEAD><BODY bgcolor = white>" ;
	Middle = " ";
	Middle += "<BR>" ; 
	Middle += "<B>Berger Check Prediction for <FONT COLOR=red>" + circuit + "</FONT></B><BR>" ;
	Middle += "<PRE>"
	Middle += "<BR>"
	//Middle += picture1;
   	Middle += "</PRE>"
	Middle += "<B>The Operation is:</B>" + "<BR>" ;

	Middle += "<TABLE>" ;
    		Middle += "<TR> <TD>X:<TD>" ;	
		Middle += "<TD> <TD><B>" + datawordX + "</B><TD>";	
		for(i=0;i<len;i++)
			{
				bit=parseInt(temp_codeX.substring(i,i+1));
				if (bit==0)	Middle += "<TD><FONT COLOR=blue> <B>" + bit + "</FONT></B>" ;
				else		Middle += "<TD><FONT COLOR=green> <B>" + bit + "</FONT></B>" ;
			}
		if (form.Operation[6].checked)
		for(i=len;i<2*len;i++)
			{
				bit=parseInt(temp_codeX.substring(i,i+1));
				if (bit==0)	Middle += "<TD><FONT COLOR=blue> <B>" + bit + "</FONT></B>" ;
				else		Middle += "<TD><FONT COLOR=green> <B>" + bit + "</FONT></B>" ;
			}

		Middle +="<br>";
		Middle += "<TR> <TD>Y:<TD>";
		Middle += "<TD> <TD><B>" + datawordY + "</B><TD>";	
		for(i=0;i<len;i++)
			{
				bit=parseInt(temp_codeY.substring(i,i+1));
				if (bit==0)	Middle += "<TD><FONT COLOR=blue> <B>" + bit + "</FONT></B>" ;
				else 		Middle += "<TD><FONT COLOR=green> <B>" + bit + "</FONT></B>" ;
			}
		Middle +="<br>";
		Middle += "<TR> <TD><TD><TD><TD> " ;
		Middle += "<B><FONT COLOR=red>" + OP + "</FONT> <TD></B>" ; 
		for(i=0;i<len;i++)	Middle += "<TD><B>_</B>" ;

		Middle += "<TR> <TD><B>S:</B>"; 
		Middle += "<TD><TD><TD><B>" + result + "</B><TD> ";	
		for(i=0;i<len;i++)
			{
				bit=parseInt(OUT.substring(i,i+1));
				if (bit==0)	Middle += "<TD><FONT COLOR=blue> <B>" + bit + "</FONT></B>" ;
				else		Middle += "<TD><FONT COLOR=green> <B>" + bit + "</FONT></B>" ;
			}
		if (form.Operation[5].checked)
		for(i=len;i<2*len;i++)
			{
				bit=parseInt(OUT.substring(i,i+1));
				if (bit==0)	Middle += "<TD><FONT COLOR=blue> <B>" + bit + "</FONT></B>" ;
				else		Middle += "<TD><FONT COLOR=green> <B>" + bit + "</FONT></B>" ;
			}
		if (form.Operation[6].checked)
			{
				Middle += "<TR> <TD><B>Q:</B>"; 
				Middle += "<TD><TD><TD><B>" + quotient + "</B><TD> ";	
				for(i=0;i<=len;i++)
				{
				bit=parseInt(Q1.substring(i,i+1));
				if (bit==0)	Middle += "<TD><FONT COLOR=blue> <B>" + bit + "</FONT></B>" ;
				else		Middle += "<TD><FONT COLOR=green> <B>" + bit + "</FONT></B>" ;
				}
				
				Middle += "<TR> <TD><B>R*:</B>"; 
				Middle += "<TD><TD><TD><B> Top remainders </B><TD> ";	
				for(i=0;i<=len;i++)
				{
				bit=parseInt(R.substring(i,i+1));
				if (bit==0)	Middle += "<TD><FONT COLOR=blue> <B>" + bit + "</FONT></B>" ;
				else		Middle += "<TD><FONT COLOR=green> <B>" + bit + "</FONT></B>" ;
				}

			}


		Middle += "<br>";
		Middle += Internal ;	

		Middle += "</TABLE> <BR>" ;
		Middle += "Number of <FONT COLOR=blue><B>0</B></FONT>s in result <B>S</B>:"; 
		Middle += "<FONT COLOR=blue>   <B>" + Nresult + "</B></FONT><br>" ;
		Middle += "<BR><BR>" ;

		Middle += "<B>The Berger Check Prediction is:</B>" + "<BR><BR>" ;
		Middle += table;
		Middle += "<BR><TABLE>" ;
    		Middle += "<TR> <TD>   <B>S<SUB>c</SUB><TD></B>" ;	
		Middle += "<TD>  <TD> <B>=</B>" + Express + "<br>" ;
		Middle += "<TR> <TD> <TD> <TD> <TD> <B>=</B> <TD> <FONT COLOR=red><B>" + Berger + "</B></FONT>" ;
		Middle += "</TABLE>" ;
		Middle += "<B>Binary Code:</B> <FONT COLOR=red><B>" + Bi_berger + "</B></FONT>" ;
		Middle += "<BR><BR><B> Berger Check Prediction indicates that this operation ";
		if(Nresult==Berger)
		Middle += "<FONT COLOR=green><B>has no</B></FONT> fault.";
		else
		Middle += "<FONT COLOR=red><B>has </B></FONT> fault.";

	Bottom = "</BODY> </HTML>" ;
  
  
  parent.resultsFrame.document.open()
  parent.resultsFrame.document.write(Top)
  parent.resultsFrame.document.write(Middle)
  parent.resultsFrame.document.write(Bottom)
  parent.resultsFrame.document.close()

  return true
}

function encode(form) {

  clear_output(form);
  	if(!checkinputs(form)) return false;

 len = parseInt(form.NumBits.value);
 Q1 = "";
 R1 = "";

  if (form.type[1].checked)
	{	
	temp_codeX = hex_to_binary(form.datawordX.value);
	temp_codeY = hex_to_binary(form.datawordY.value);

		datawordX = parseInt(form.datawordX.value, 16);
 		datawordY = parseInt(form.datawordY.value, 16);
 		encodewordX = len - BergerCode(hex_to_binary(form.datawordX.value));
		encodewordY = len - BergerCode(hex_to_binary(form.datawordY.value));
	}

  if (form.type[0].checked)
	{	
		temp_codeX = form.datawordX.value;
		temp_codeY = form.datawordY.value;
	
  		datawordX = parseInt(form.datawordX.value, 2);
  		datawordY = parseInt(form.datawordY.value, 2);
  		encodewordX = len - BergerCode(form.datawordX.value) ;
		encodewordY = len - BergerCode(form.datawordY.value) ;
  	}

  var temp_result;
  var inter_string;

  for(i=temp_codeX.length;i<len;i++)  { temp_codeX = 0 + temp_codeX; }
  for(i=temp_codeY.length;i<len;i++)  { temp_codeY = 0 + temp_codeY; }

  if (form.Operation[0].checked)
	{	
		result = datawordX & datawordY;
		temp_result = datawordX | datawordY;
		inter_string = temp_result.toString(2);
		for(i=inter_string.length;i<len;i++)  { inter_string = 0 + inter_string; }
		if(start==0 || Global_X != temp_codeX || Global_Y != temp_codeY || Global_length != len || !form.Operation[OP_checked].checked || !form.type[type_checked].checked)
		{	sum = new Array(len);
			faulty = new Array(len);
			for (i=0;i<len;i++)	faulty[i]=0;
			for(i=0;i<len;i++)	
				{bit=parseInt(inter_string.substring(i,i+1));
				sum[i] = bit ;
				}
		}
	OP_checked = 0;
	}
  
  if (form.Operation[1].checked)
	{	
		result = datawordX | datawordY;
		temp_result = datawordX & datawordY;
		inter_string = temp_result.toString(2);
		for(i=inter_string.length;i<len;i++)  { inter_string = 0 + inter_string; }
		if(start==0 || Global_X != temp_codeX || Global_Y != temp_codeY || Global_length != len || !form.Operation[OP_checked].checked || !form.type[type_checked].checked)
		{	sum = new Array(len);
			faulty = new Array(len);
			for (i=0;i<len;i++)	faulty[i]=0;
			for(i=0;i<len;i++)	
				{bit=parseInt(inter_string.substring(i,i+1));
				sum[i] = bit ;
				}
		}
		
	OP_checked = 1;

	}

  if (form.Operation[2].checked)
	{	
		result = datawordX ^ datawordY;
		temp_result = datawordX & datawordY;
		inter_string = temp_result.toString(2);
		for(i=inter_string.length;i<len;i++)  { inter_string = 0 + inter_string; }
		
		if(start==0 || Global_X != temp_codeX || Global_Y != temp_codeY || Global_length != len || !form.Operation[OP_checked].checked || !form.type[type_checked].checked)
		{	sum = new Array(len);
			faulty = new Array(len);
			for (i=0;i<len;i++)	faulty[i]=0;
			for(i=0;i<len;i++)	
				{bit=parseInt(inter_string.substring(i,i+1));
				 sum[i] = bit ;
				}
		}

	OP_checked = 2;

	}

  if (form.Operation[3].checked)
	{	
		result = datawordX + datawordY;
		A = datawordX.toString(2);
		B = datawordY.toString(2);
		C = "";
		OUT = "";
		for(i=0;i<len;i++)
		{	if (i >= A.length) { A = 0 + A ;}
			if (i >= B.length) { B = 0 + B ;}
		}
		
		if(start==0 || Global_X != temp_codeX || Global_Y != temp_codeY || Global_length != len || !form.Operation[OP_checked].checked || !form.type[type_checked].checked)
		{	sum = new Array(len);
			carry =  new Array(len);
			faulty = new Array(len);
			for(i=0;i<len;i++)	faulty[i] = 0;
			for(i=len-1;i>=0;i--)
			{	
			digitA=parseInt(A.substring(i,i+1));
			digitB=parseInt(B.substring(i,i+1));
			if(i==len-1) 
			{
				digitC = digitA & digitB ;
				digitOUT = digitA ^ digitB ;
				C = digitC + C;
				OUT = digitOUT + OUT;
				carry[i] = digitC;
				sum[i] = digitOUT;
			}
			else
			{
				digitC = (digitA & digitB) | ((digitA | digitB) &  Cin);
				digitOUT = digitA ^ digitB ^ Cin ;
				OUT = digitOUT + OUT ;
				C = digitC + C;
				carry[i] = digitC;
				sum[i] = digitOUT;
			}
			 Cin =  digitC ;
			}
			
		}
		else
		{

		for(i=len-1;i>=0;i--)
		{	digitA=parseInt(A.substring(i,i+1));
			digitB=parseInt(B.substring(i,i+1));
			if(i==len-1) 
			{
				digitC = carry[i];
				digitOUT = sum[i];
				C = digitC + C;
				OUT = digitOUT + OUT;

			}
			else
			{
				digitC = (digitA & digitB) | ((digitA | digitB) &  carry[i+1]);
				digitOUT = digitA ^ digitB ^ carry[i+1] ;
				if(faulty[i]== 0)
				{ 	carry[i] = digitC;
					sum[i] = digitOUT;
					
				}
				else 
				{
					digitC = carry[i];
					digitOUT = sum[i];
				}
				
				OUT = digitOUT + OUT ;
				C = digitC + C;
			}
			
		}
		}

	OP_checked = 3;
	}
  
  if (form.Operation[4].checked)
	{	
		if(datawordX < datawordY)
		{

		alert("Data X must be larger than Data Y");
		
		return false ;
		}
		result = datawordX - datawordY;
		A = datawordX.toString(2);
		B = datawordY.toString(2);
		C = "";
		OUT = "";
		for(i=0;i<len;i++)
		{	if (i >= A.length) { A = 0 + A ;}
			if (i >= B.length) { B = 0 + B ;}
		}
		
		if(start==0 || Global_X != temp_codeX || Global_Y != temp_codeY || Global_length != len || !form.Operation[OP_checked].checked || !form.type[type_checked].checked)
		{	sum = new Array(len);
			carry =  new Array(len);
			for(i=len-1;i>=0;i--)
			{	
			digitA=parseInt(A.substring(i,i+1));
			digitB=parseInt(B.substring(i,i+1));
			if(i==len-1) 
			{
				digitC = (~digitA) & digitB ;
				digitOUT = digitA ^ digitB ;
				C = digitC + C;
				OUT = digitOUT + OUT;
				carry[i] = digitC;
				sum[i] = digitOUT;
			}
			else
			{
				digitC = ((~digitA) & digitB) | (((~digitA) ^ digitB) &  Cin);
				digitOUT = digitA ^ digitB ^ Cin ;
				OUT = digitOUT + OUT ;
				C = digitC + C;
				carry[i] = digitC;
				sum[i] = digitOUT;
			}
			 Cin =  digitC ;
			}
			faulty = new Array(len);
			for(i=0;i<len;i++)	faulty[i] = 0;
		}
		else
		{
			
		for(i=len-1;i>=0;i--)
		{	digitA=parseInt(A.substring(i,i+1));
			digitB=parseInt(B.substring(i,i+1));
			if(i==len-1) 
			{
					digitC = carry[i];
					digitOUT = sum[i];
				C = digitC + C;
				OUT = digitOUT + OUT;

			}
			else
			{
				digitC = ((~digitA) & digitB) | (((~digitA) ^ digitB) &  carry[i+1]);
				digitOUT = digitA ^ digitB ^ carry[i+1] ;
				if(faulty[i] == 1)
				{ 	
					digitC = carry[i];
					digitOUT = sum[i];
				}
				else 
				{
					carry[i] = digitC;
					sum[i] = digitOUT;
				}
				
				OUT = digitOUT + OUT ;
				C = digitC + C;
			}
			
		}
		}
			
	OP_checked = 4;

	}


  if (form.Operation[5].checked)
	{	
		result = datawordX * datawordY;
		A = datawordX.toString(2);
		B = datawordY.toString(2);
		C = "";
		S = "";
		var Inter_C = new Array(len);
		OUT = "";
		var Inter_S = new Array(len);
		P = "";
		var A_array = new Array(len);
		var B_array = new Array(len);
		for(i=0;i<len;i++)
		{	if (i >= A.length) { A = 0 + A ;}
			if (i >= B.length) { B = 0 + B ;}
		}
		for(i=0;i<len;i++)
		{
			A_array[len-1-i] = parseInt(A.substring(i,i+1));
			B_array[len-1-i] = parseInt(B.substring(i,i+1));
		}
		P = (A_array[0] & B_array[0]) + P;
	if(start==0 || Global_X != temp_codeX || Global_Y != temp_codeY || Global_length != len || !form.Operation[OP_checked].checked || !form.type[type_checked].checked)
	{	carryMatrix = new Array(len);
		sumMatrix = new Array(len);
		faultyMatrix = new Array(len);
		for(i=0;i<len;i++)
		{
			carryMatrix[i] = new Array(len);
			sumMatrix[i] = new Array(len);
			faultyMatrix[i] = new Array(len);
		}
		for(i=0;i<len;i++)
			for(j=0;j<len;j++)	faultyMatrix[i][j] = 0;
			
		for(i=0;i<len-1;i++)
		{
			temp_A = A_array[i+1] & B_array[0];
			temp_B = A_array[i] & B_array[1];
			Inter_S[i]= temp_A ^ temp_B;
			Inter_C[i]= temp_A & temp_B;
			carryMatrix[0][len-1-i] = Inter_C[i] ;
			sumMatrix[0][len-1-i] = Inter_S[i] ;
			C = Inter_C[i] + C;
			S = Inter_S[i] + S;
		}

		P = Inter_S[0] + P;
		for(i=1;i<len-1;i++)
		{	
			Inter_S[len-1] = A_array[len-1] & B_array[i];		
			for(j=0;j<len-1;j++)
			{
				temp_A = Inter_S[j+1];
				temp_B = A_array[j] & B_array[i+1];
				Inter_S[j]= temp_A ^ temp_B ^ Inter_C[j];
				Inter_C[j]= (temp_A & temp_B) | ((temp_A | temp_B) & Inter_C[j]);
				carryMatrix[i][len-1-j] = Inter_C[j] ;
				sumMatrix[i][len-1-j] = Inter_S[j] ;
				C = Inter_C[j] + C;
				S = Inter_S[j] + S;
			}
			P = Inter_S[0] + P;
		}

		Inter_S[len-1] = A_array[len-1] & B_array[len-1];

		for(j=0;j<len-1;j++)
		{
			if(j==0)	temp_B = 0;
			else		temp_B = Inter_C[j-1];
	
		 	temp_A = Inter_S[j+1];
			Inter_S[j]= temp_A ^ temp_B ^ Inter_C[j];
			Inter_C[j]= (temp_A & temp_B) | ((temp_A | temp_B) & Inter_C[j]);
			carryMatrix[len-1][len-1-j] = Inter_C[j] ;
			sumMatrix[len-1][len-1-j] = Inter_S[j] ;
			C = Inter_C[j] + C;
			S = Inter_S[j] + S;
			P = Inter_S[j] + P;
		}
	
		P = Inter_C[len-2] + P;
	}
	
	else
	{
		
		
		for(i=0;i<len-1;i++)
		{
			temp_A = A_array[i+1] & B_array[0];
			temp_B = A_array[i] & B_array[1];
			Inter_S[i]= temp_A ^ temp_B;
			Inter_C[i]= temp_A & temp_B;
			if (faultyMatrix[0][len-1-i] == 1 )
			{
				Inter_C[i] = carryMatrix[0][len-1-i];
				Inter_S[i] = sumMatrix[0][len-1-i];
			}
			else
			{
				carryMatrix[0][len-1-i] = Inter_C[i] ;
				sumMatrix[0][len-1-i] = Inter_S[i] ;
			}
			C = Inter_C[i] + C;
			S = Inter_S[i] + S;
		}

		P = Inter_S[0] + P;
		for(i=1;i<len-1;i++)
		{	
			Inter_S[len-1] = A_array[len-1] & B_array[i];	
			sumMatrix[i][0] = Inter_S[len-1];	
			for(j=0;j<len-1;j++)
			{
				temp_A = Inter_S[j+1];
				temp_B = A_array[j] & B_array[i+1];
				Inter_S[j]= temp_A ^ temp_B ^ Inter_C[j];
				Inter_C[j]= (temp_A & temp_B) | ((temp_A | temp_B) & Inter_C[j]);
				if (faultyMatrix[i][len-1-j] ==1)
				{
				Inter_C[j] = carryMatrix[i][len-1-j];
				Inter_S[j] = sumMatrix[i][len-1-j];
				}
			else
				{
				carryMatrix[i][len-1-j] = Inter_C[j] ;
				sumMatrix[i][len-1-j] = Inter_S[j] ;
				}
				
				C = Inter_C[j] + C;
				S = Inter_S[j] + S;
			}
			P = Inter_S[0] + P;
		}

		Inter_S[len-1] = A_array[len-1] & B_array[len-1];

		for(j=0;j<len-1;j++)
		{
			if(j==0)	temp_B = 0;
			else		temp_B = Inter_C[j-1];
	
		 	temp_A = Inter_S[j+1];
			Inter_S[j]= temp_A ^ temp_B ^ Inter_C[j];
			Inter_C[j]= (temp_A & temp_B) | ((temp_A | temp_B) & Inter_C[j]);
			if (faultyMatrix[len-1][len-1-j] ==1)
				{
				Inter_C[j] = carryMatrix[len-1][len-1-j];
				Inter_S[j] = sumMatrix[len-1][len-1-j];
				}
			else
				{
				carryMatrix[len-1][len-1-j] = Inter_C[j] ;
				sumMatrix[len-1][len-1-j] = Inter_S[j] ;
				}
				
			C = Inter_C[j] + C;
			S = Inter_S[j] + S;
			P = Inter_S[j] + P;
		}
	
		P = Inter_C[len-2] + P;
			
	
	}

	OP_checked = 5;

	}

	if (form.Operation[6].checked)
	{	
		for(i=temp_codeX.length;i<2*len;i++)  { temp_codeX = 0 + temp_codeX; }
		Global_X = temp_codeX ;
		quotient = Math.floor(datawordX / datawordY);
		A = datawordX.toString(2);
		B = datawordY.toString(2);
		C = "";
		C1 = "";
		var Inter_C = new Array(len+2);
		S = "";
		var Inter_S = new Array(len+1);
		var S_last = new Array(len+1);
		Q = "";
		R = "";
		R1 = "";
		OUT = "";
		var A_array = new Array(2*len+1);
		var B_array = new Array(len+1);
		var Q_array = new Array(len+1);
		var R_array = new Array(len+1);

		for(i=0;i<len;i++)
		{	
			if (i >= B.length) { B = 0 + B ;}
		}
		for(i=0;i<2*len;i++)
		{	if (i >= A.length) { A = 0 + A ;}
		}

		for(i=0;i<len;i++)
		{
			
			B_array[len-1-i] = parseInt(B.substring(i,i+1));
		}
		for(i=0;i<2*len;i++)
		{
			A_array[2*len-1-i] = parseInt(A.substring(i,i+1));
			
		}

		Q = quotient.toString(2);
		for(i=0;i<=len;i++)
			if (i >= Q.length) { Q = 0 + Q ;}
		for(i=0;i<=len;i++)
			Q_array[len-i] = parseInt(Q.substring(i,i+1));

		Inter_C[0]=1;
		A_array[2*len] = 0;
		B_array[len] = 0;
		
	if(start==0 || Global_X != temp_codeX || Global_Y != temp_codeY || Global_length != len || !form.Operation[OP_checked].checked || !form.type[type_checked].checked)
	{
		carryMatrix = new Array(len+1);
		sumMatrix = new Array(len+1);
		faultyMatrix = new Array(len+1);
		for(i=0;i<=len;i++)
		{
			carryMatrix[i] = new Array(len+1);
			sumMatrix[i] = new Array(len+1);
			faultyMatrix[i] = new Array(len+1);
		}
		for(i=0;i<=len;i++)
			for(j=0;j<=len;j++)	faultyMatrix[i][j] = 0;
		
		for(i=0;i<=len;i++)
		{
			
			temp_A = A_array[i+len];
			temp_B = B_array[i] ^ 1;
			Inter_S[i]= temp_A ^ temp_B ^ Inter_C[i] ;
			S_last[i] = Inter_S[i];
			Inter_C[i+1]= (temp_A & temp_B) | ((temp_A | temp_B) & Inter_C[i]);
			carryMatrix[0][len-i] = Inter_C[i+1] ;
			sumMatrix[0][len-i] = Inter_S[i] ;
			if(i!=len)
			{C = Inter_C[i+1] + C;
			S = Inter_S[i] + S;
			}
			
			
		}
		Q_array[len] = Inter_C[len+1];
		R_array[len] = Inter_S[len];
		R = R + Inter_S[len];
		Q1 = Q1 + Inter_C[len+1];
		for(i=len-1;i>=0;i--)
		{	
			Inter_C[0] = Q_array[i+1];	
			for(j=0;j<=len;j++)
			{
				if(j==0)	temp_A = A_array[i];
				else		temp_A = S_last[j-1];
				temp_B = B_array[j] ^ Q_array[i+1] ;
				Inter_S[j]= temp_A ^ temp_B ^ Inter_C[j];
				Inter_C[j+1]= (temp_A & temp_B) | ((temp_A | temp_B) & Inter_C[j]);
				carryMatrix[len-i][len-j] = Inter_C[j+1] ;
				sumMatrix[len-i][len-j] = Inter_S[j] ;
				if(j!=len)
				{C = Inter_C[j+1] + C;
				 S = Inter_S[j] + S;
				}
			}
			for(j=0;j<=len;j++)
				S_last[j] = Inter_S[j];

			Q_array[i] = Inter_C[len+1];
			R_array[i] = Inter_S[len];
			R = R + Inter_S[len];
			Q1 = Q1 + Inter_C[len+1];

		}
		for(i=0;i<=len-1;i++)
		{
			R1 = Inter_S[i] + R1;
		}
	}
	
	else
	{	
		for(i=0;i<=len;i++)
		{				
			temp_A = A_array[i+len];
			temp_B = B_array[i] ^ 1;
			Inter_S[i]= temp_A ^ temp_B ^ Inter_C[i] ;
			S_last[i] = Inter_S[i];
			Inter_C[i+1]= (temp_A & temp_B) | ((temp_A | temp_B) & Inter_C[i]);
			if (faultyMatrix[0][len-i] ==1)
			{
				Inter_C[i+1] = carryMatrix[0][len-i];
				Inter_S[i] = sumMatrix[0][len-i];
			}
			else
			{
				carryMatrix[0][len-i] = Inter_C[i+1] ;
				sumMatrix[0][len-i] = Inter_S[i] ;
			}
			if(i!=len)
			{C = Inter_C[i+1] + C;
			S = Inter_S[i] + S;
			}
			
		}
		Q_array[len] = Inter_C[len+1];
		R_array[len] = Inter_S[len];
		R = R + Inter_S[len];
		Q1 = Q1 + Inter_C[len+1];
		
		for(i=len-1;i>=0;i--)
		{	
			Inter_C[0] = Q_array[i+1];	
			for(j=0;j<=len;j++)
			{
				if(j==0)	temp_A = A_array[i];
				else		temp_A = S_last[j-1];
				temp_B = B_array[j] ^ Q_array[i+1] ;
				Inter_S[j]= temp_A ^ temp_B ^ Inter_C[j];
				Inter_C[j+1]= (temp_A & temp_B) | ((temp_A | temp_B) & Inter_C[j]);
			if (faultyMatrix[len-i][len-j] ==1)
			{
				Inter_C[j+1] = carryMatrix[len-i][len-j];
				Inter_S[j] = sumMatrix[len-i][len-j];
			}
			else
			{
				carryMatrix[len-i][len-j] = Inter_C[j+1] ;
				sumMatrix[len-i][len-j] = Inter_S[j] ;
			}
				
				if(j!=len)
				{C = Inter_C[j+1] + C;
				 S = Inter_S[j] + S;
				}
			}
			for(j=0;j<=len;j++)
				S_last[j] = Inter_S[j];
				
			Q_array[i] = Inter_C[len+1];
			R_array[i] = Inter_S[len];
			R = R + Inter_S[len];
			Q1 = Q1 + Inter_C[len+1];

		}
		for(i=0;i<=len-1;i++)
		{
			R1 = Inter_S[i] + R1;
		}
	
	}

	OP_checked = 6;
	}
  
  if (form.type[1].checked)
		type_checked = 1;

  if (form.type[0].checked)
		type_checked = 0;

  if (start == 0)
  {	start = 1;
  	parent.resultsFrame.location.href="./results.html"
  }	

  Global_X = temp_codeX ;
  Global_Y = temp_codeY ;
  Global_length = len ;

  return true
}





//--></SCRIPT>

</HEAD>


<BODY bgcolor="wheat">



<font size="+3"><B>Berger Code Predictor/Concurrent Error Detector </B></font>

<FORM name=inputForm>

<table cellpadding=10>


<font size="+2"><B>Logic/Arithmetic Operation</B></font><BR>
<BR>

<font size="+0"><B>binary</B></font><input type="radio" name="type" value="binary" checked>
<font size="+0"><B>hex</B></font><input type="radio" name="type" value="hex"><BR><BR>

<font size="+1"><B>AND</B></font><input type="radio" name="Operation" value="AND">
<font size="+1"><B>OR</B></font><input type="radio" name="Operation" value="OR">
<font size="+1"><B>XOR</B></font><input type="radio" name="Operation" value="XOR">
<BR><BR>
<font size="+1"><B>ADDITION</B></font><input type="radio" name="Operation" value="ADDITION" checked>
<font size="+1"><B>SUBTRACTION</B></font><input type="radio" name="Operation" value="SUBTRACTION">
<font size="+1"><B>MULTIPLICATION</B></font><input type="radio" name="Operation" value="MULTIPLICATION">
<font size="+1"><B>DIVISION</B></font><input type="radio" name="Operation" value="DIVISION"><BR><BR>

<tr>
<td><B>Data word X: </B><BR><INPUT type="text" name="datawordX" size=32><BR></td>
<td><B>Data word Y:</B><BR><INPUT type="text" name="datawordY" size=32></td>
</tr>

<tr>
<td><B>Number of bits</B><font size="+0"><B>(for div.,bits of divisor)</B></font><BR><INPUT type="text" name="NumBits" size=16></td>
</tr>
</table><BR><BR>

<table>
<tr><td><FONT COLOR="blue"><B>(optional): Click the "Fault Injection" button to view or modify the temporary/intermediate operation result and inject internal fault
</B></td>
</tr>
<tr><td><INPUT type="button" name="viewAndModifytempButton" value="Fault Injection" onClick="viewandmodifytemp()"></td>
</FONT></tr></table>
<BR>

<table>
<tr><td><font size="+0"><B>Click the "Compute" button to compute the Logic/Arithmetic operation result and the according Berger Check Prediction code  
</B></font></td><BR>
<BR></tr>
<tr><td><INPUT type="button" name="enter" value="Compute" onClick="encodeArith(this.form)"></td>
</tr>
</table><BR><BR><BR>

<table>
<tr>
<td><B>Berger Encoded data word X</B><BR><B>( Number of 0s in binary)</B><BR><INPUT type="text" name="encodewordX" size=32><BR></td>
<td><B>Berger Encoded data word Y</B><BR><B>( Number of 0s in binary )</B><BR><INPUT type="text" name="encodewordY" size=32></td>
</tr>

<tr>
<td><B>Operation Result:</B><BR><font size="+0"><B>(quotient for div.)</B></font><BR><INPUT type="text" name="result" size=32></td>
<td><B>Berger Prediction Code:</B><BR><B>(for div., Code of remainder)</B><BR><INPUT type="text" name="Berger" size=32></td>
</tr>

<tr>
<td><B>Operation Result:</B><BR><font size="+0"><B>(remainder for div.)</B></font><BR><INPUT type="text" name="remainder" size=32><BR></td>
</tr>

</table>

<P>

<BR>

<TABLE>
  <TR><INPUT onclick=Help() type=button value="Simulator Help" name=help></TR></TABLE>

</FORM>

</BODY>

</HTML>
