<html>
   <head>
      <title>Character Codes</title>
      <script type="text/javascript">
      
// global variables for diagram
   var GlobalDataIn;
   var GlobalCka;
   var GlobalCkb;
   var GlobalParityB;
   
   var GlobalCheckA;
   var GlobalSyndA
   var GlobalCheckB;
   var GlobalSyndB;
   
   var GlobalSglALoc;
   var GlobalSglBLoc;
   var GlobalDbl;
   var GlobalParB;
   var GlobalSglTpl;
   var GlobalLb0;
   
   var GlobalDataOut;
   var GlobalError;
   var GlobalMux;
   
//-----------------------------------------------------------------------------
//                            Datapath elements
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// converts decimal input (up to 2^32) to 8-digit hex character string
      function toHex(dec) {
         var div = 0X10000000;                        // divisor
         var hchar = 0;                               // hex character
         hexChars = "0123456789ABCDEF";               // select from one of these
         if (dec > 0XFFFFFFFF) {                      // check limit (not tested yet)
            return null;
         }
         
         result = "0X";                               // hex result begins with 0X

         for (var i = 0; i <= 7; i++) {               // loop for 8 characters
            hchar = Math.floor(dec/(div >> 4 * i));   // divide decimal value by 16^i
            dec -= ((div >> 4 * i) * hchar);          // subtract hex value obtained from decimal value
            result += hexChars.charAt(hchar);         // append hex char to result
         }
         return result;
      }     
//-----------------------------------------------------------------------------
  
     
//-----------------------------------------------------------------------------
// computes 32-bit "xor" of two inputs
      function calcXor(x, y) {
         hexChars = "0123456789ABCDEF";
         var c = new Array(8);
         var d = new Array(8);
         var e = new Array(8);
         result = "0X";
 
        for (var i = 0; i <= 7; i++) {       // for each of 8 characters 
            if (i < (8 - x.length)) {        // need to insert leading zeroes
               c[i] = 0X0;                   // leading nibbles=0 if length<8
            } else {
               c[i] = "0X" + x.charAt(i - 8 + x.length);
            }
            if (i < (8 - y.length)) {
               d[i] = 0X0;                   // same for 2nd input
            } else {
               d[i] = "0X" + y.charAt(i - 8 + y.length);
            }            
            e[i] = c[i]^d[i];                // xor
            result += hexChars.charAt(e[i]); // append to result
         }
         
         return result;
       }      
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// computes the 16 checkbit value, in hex, by concatenation
      function calcCk(cka, parb, ckb) {
        var a;
        var b;         
        a = 2*cka;
        b = ckb;
        
        if (parb == "1") {
           a++;
        }    
 
        a = toHex(a);
 
        // strip off "0X"
        a = a.replace("0X", "");
        b = b.replace("0X", "");        
        
        a += b;
                
        return a;
      }      
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// computes 32-bit "and" of two inputs
      function calcAnd(x, y) {
         hexChars = "0123456789ABCDEF";
         var c = new Array(8);
         var d = new Array(8);
         var e = new Array(8);
         result = "";
 
        for (var i = 0; i <= 7; i++) {       // for each of 8 characters 
            if (i < (8 - x.length)) {        // need to insert leading zeroes
               c[i] = 0X0;                   // leading nibbles=0 if length<8
            } else {
               c[i] = "0X" + x.charAt(i - 8 + x.length);
            }
            if (i < (8 - y.length)) {
               d[i] = 0X0;                   // same for 2nd input
            } else {
               d[i] = "0X" + y.charAt(i - 8 + y.length);
            }            
            e[i] = c[i]&d[i];                // and
            result += hexChars.charAt(e[i]); // append to result
         }
         return result;
       }      
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// computes parity of two 1-bit inputs
      function calcPar(x,y) {
 
         if (x==y) {
            return "0";
         } else {
            return "1";
         }   
       }      
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// computes XOR of one input up to 32-bits
      function calcXor1(x) {
         var c = new Array(8);
         result = false;
 
         for (var i = 0; i <= (x.length-1); i++) {  // for each of the characters 
            c[i] = "0X" + x.charAt(i);              // odd bits in nibble
            if ((c[i] == 1) || (c[i] == 2)  || (c[i] == 4)  || (c[i] == 7) ||
                (c[i] == 8) || (c[i] == 11) || (c[i] == 13) || (c[i] == 14)) {
               result = !result; 
            }   
         }
         if (result) {
            return "1";
         } else {
            return "0";
         }   
       }      
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// calculates the "a" check bits
      function calcCka(x) {
         var c = new Array(8);
         var d;
         var e = new Array(7);         
         var cka = new Array(7);
         result = "";

        cka[0] = "FF021283";                 // a check matrix values in hex
        cka[1] = "09FF2484";
        cka[2] = "1010FF36";
        cka[3] = "222580FF";
        cka[4] = "65490F68";
        cka[5] = "868EF808";
        cka[6] = "D8F04151";

         for (var i = 0; i <= 6; i++) {      // for each of 7 rows 
            d = calcAnd(x, cka[i]);
            e[i] = calcXor1(d);
         }
         
         //for (var i = 0; i <= 6; i++) {
         //   result += e[i];
         //}

         // flip the bits to match synd pattern
         for (var i = 6; i >= 0; i--) {
            result += e[i];
         }

         result = result.replace("true", "");   // "true" and "false" are 
         result = result.replace("false", "");  // prepended to result  - ??
         return result;
       }      
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// calculates loca, which is the decode of the "a" syndrome check bits
      function calcLoca(x) {
         var synd_a = new Array(32);
         var a = "";   // error-bit position, in decimal
         var b = "";   // hex character value
         var c = "";   // position of hex char
         result = "";         

         // syndrome list
         synd_a[0] = 97;   synd_a[1] = 81;   synd_a[2] = 25;   synd_a[3] = 69;
         synd_a[4] = 67;   synd_a[5] = 49;   synd_a[6] = 41;   synd_a[7] = 19;
         synd_a[8] = 98;   synd_a[9] = 82;   synd_a[10] = 74;  synd_a[11] = 70;
         synd_a[12] = 50;  synd_a[13] = 42;  synd_a[14] = 35;  synd_a[15] = 26;
         synd_a[16] = 44;  synd_a[17] = 100; synd_a[18] = 38;  synd_a[19] = 37;
         synd_a[20] = 52;  synd_a[21] = 22;  synd_a[22] = 21;  synd_a[23] = 84;
         synd_a[24] = 11;  synd_a[25] = 88;  synd_a[26] = 28;  synd_a[27] = 76;
         synd_a[28] = 56;  synd_a[29] = 14;  synd_a[30] = 13;  synd_a[31] = 73;

         // find bit postion by searching through syndrome list
         for (var i = 0; i <= 31; i++) {
            if (synd_a[i] == x) {
               a = i;
            }
         }
        
         // hex character value is 1, 2, 4, or 8, use mod function
         if (a == 0) {
            b = "8";
         } else {         
            if (a == "") {
               b = "0";
            } else {   
               if ((a % 4) == 3) {b = "1";}
               if ((a % 4) == 2) {b = "2";}
               if ((a % 4) == 1) {b = "4";}
               if ((a % 4) == 0) {b = "8";}
            }
         }
  
         // hex character position is 0 through 7
         c = Math.floor(a/4);
                  
         // replace appropriate character in result
         for (var i = 0; i <= 7; i++) {
            if (i == c) {
               result += b;
            } else {
               result += "0";
            }
         }
         return result;
       }      
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// calculates the "b" check bits
      function calcCkb(x) {
         var c = new Array(8);
         var d;
         var e = new Array(8);         
         var ckb = new Array(8);
         var f = "";
         m = 0X10000000;

        ckb[0] = "6E042506";                   // b check matrix values in hex
        ckb[1] = "20FE4808";
        ckb[2] = "0301B66C";
        ckb[3] = "844B01BA";
        ckb[4] = "F8921E40";
        ckb[5] = "0C39F011";
        ckb[6] = "53A082A3";
        ckb[7] = "914449D5";

         for (var i = 0; i <= 7; i++) {        // for each of 8 rows 
            d = calcAnd(x, ckb[i]);
            e[i] = calcXor1(d);
         }
         
         //for (var i = 0; i <= 7; i++) {
         //   f += e[i];
         //}                        

         // flip the bits to match syndrome patterns
         for (var i = 7; i >= 0; i--) {
            f += e[i];
         }                        
         
         f = f.replace("true", "");          // "true" and "false" are 
         f = f.replace("false", "");         // prepended to result  - ??

         result = f;
         return result;
       }      
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// calculates locb, which is the decode of the "b" syndrome check bits
      function calcLocb(x) {
         var synd_b = new Array(32);
         var a = "";   // error-bit position, in decimal
         var b = "";   // hex character value
         var c = "";   // position of hex char
         result = "";         

         // syndrome list
         synd_b[0] = 152;  synd_b[1] = 81;   synd_b[2] = 19;   synd_b[3] = 208;
         synd_b[4] = 49;   synd_b[5] = 41;   synd_b[6] = 69;   synd_b[7] = 196;
         synd_b[8] = 82;   synd_b[9] = 138;  synd_b[10] = 98;  synd_b[11] = 50;
         synd_b[12] = 42;  synd_b[13] = 131; synd_b[14] = 26;  synd_b[15] = 44;
         synd_b[16] = 100; synd_b[17] = 162; synd_b[18] = 37;  synd_b[19] = 52;
         synd_b[20] = 146; synd_b[21] = 21;  synd_b[22] = 84;  synd_b[23] = 137;
         synd_b[24] = 200; synd_b[25] = 148; synd_b[26] = 76;  synd_b[27] = 168;
         synd_b[28] = 14;  synd_b[29] = 133; synd_b[30] = 73;  synd_b[31] = 224;

         // find bit postion by searching through syndrome list
         for (var i = 0; i <= 31; i++) {
            if (synd_b[i] == x) {
               a = i;
            }
         }
        
         // hex character value is 1, 2, 4, or 8, use mod function
         if (a == 0) {
            b = "8";
         } else {         
            if (a == "") {
               b = "0";
            } else {   
               if ((a % 4) == 3) {b = "1";}
               if ((a % 4) == 2) {b = "2";}
               if ((a % 4) == 1) {b = "4";}
               if ((a % 4) == 0) {b = "8";}
            }
         }
  
         // hex character position is 0 through 7
         c = Math.floor(a/4);
                  
         // replace appropriate character in result
         for (var i = 0; i <= 7; i++) {
            if (i == c) {
               result += b;
            } else {
               result += "0";
            }
         }
         return result;
       }      
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// calculate locd, which is the decode of the "a" and "b" syndrome check bits
// to find double bit errors
      function calcLocd(x,y) {
         var synd_a = new Array(32);
         var synd_b = new Array(32);
         var dbl_a = new Array(496);
         var dbl_b = new Array(496);
         var dbl_a_i = new Array(32);
         var dbl_a_j = new Array(32);
         var dbl_b_i = new Array(32);
         var dbl_b_j = new Array(32);
         var a = "";             // error-bit index, in decimal
         var bit1 = "";          // error-bit position, 1st bit
         var bit2 = "";          // error-bit position, 2nd bit
         var b1b = "";           // bit 1 bit position in nibble
         var b2b = "";           // bit 2 bit position in nibble
         var b1n = "";           // bit1 nibble position
         var b2n = "";           // bit2 nibble position
         var b1v = "";           // bit1 value when in different nibbles
         var b2v = "";           // bit2 value when in different nibbles
         var c = "";             // value of nibble with 2 errors
         result = "";         

         var k = 0;              // k is a single index to each double-bit pattern
         
         // syndrome a list
         synd_a[0] = 97;   synd_a[1] = 81;   synd_a[2] = 25;   synd_a[3] = 69;
         synd_a[4] = 67;   synd_a[5] = 49;   synd_a[6] = 41;   synd_a[7] = 19;
         synd_a[8] = 98;   synd_a[9] = 82;   synd_a[10] = 74;  synd_a[11] = 70;
         synd_a[12] = 50;  synd_a[13] = 42;  synd_a[14] = 35;  synd_a[15] = 26;
         synd_a[16] = 44;  synd_a[17] = 100; synd_a[18] = 38;  synd_a[19] = 37;
         synd_a[20] = 52;  synd_a[21] = 22;  synd_a[22] = 21;  synd_a[23] = 84;
         synd_a[24] = 11;  synd_a[25] = 88;  synd_a[26] = 28;  synd_a[27] = 76;
         synd_a[28] = 56;  synd_a[29] = 14;  synd_a[30] = 13;  synd_a[31] = 73;

         // syndrome b list
         synd_b[0] = 152;  synd_b[1] = 81;   synd_b[2] = 19;   synd_b[3] = 208;
         synd_b[4] = 49;   synd_b[5] = 41;   synd_b[6] = 69;   synd_b[7] = 196;
         synd_b[8] = 82;   synd_b[9] = 138;  synd_b[10] = 98;  synd_b[11] = 50;
         synd_b[12] = 42;  synd_b[13] = 131; synd_b[14] = 26;  synd_b[15] = 44;
         synd_b[16] = 100; synd_b[17] = 162; synd_b[18] = 37;  synd_b[19] = 52;
         synd_b[20] = 146; synd_b[21] = 21;  synd_b[22] = 84;  synd_b[23] = 137;
         synd_b[24] = 200; synd_b[25] = 148; synd_b[26] = 76;  synd_b[27] = 168;
         synd_b[28] = 14;  synd_b[29] = 133; synd_b[30] = 73;  synd_b[31] = 224;

         // first create arrays with the double-bit patterns
         for (var i = 0; i <= 30; i++) {               // find synd pattern for each double-bit error
            for (var j = i+1; j <= 31; j++) {
               dbl_a[k] = synd_a[i] ^ synd_a[j];
               dbl_a_i[k] = i;
               dbl_a_j[k] = j;                         // keep track of indexes to help debug
      
               dbl_b[k] = synd_b[i] ^ synd_b[j];
               dbl_b_i[k] = i;
               dbl_b_j[k] = j;
      
               k++;
            }
         }

         // find bit index by searching through double bit patterns
         for (var i = 0; i <= 495; i++) {
            if ((dbl_a[i] == x) && (dbl_b[i] == y)) {
               a = i;
            }
         }

         // used index "a" to find the two bits that are in error
         bit1 = dbl_a_i[a];
         bit2 = dbl_a_j[a];
        
         b1b = bit1 % 4;                     // bit1 bit position
         b2b = bit2 % 4;                     // bit2 bit position
         b1n = Math.floor(bit1 / 4);         // bit1 nibble position
         b2n = Math.floor(bit2 / 4);         // bit2 nibble position
         
         if (b1n == b2n) {                   // same nibble
            if (b1b == 0) {
               if (b2b == 1) {c = "C";}      // first two bits
               if (b2b == 2) {c = "A";}
               if (b2b == 3) {c = "9";}
            }   
            if (b1b == 1) {
               if (b2b == 0) {c = "C";}      
               if (b2b == 2) {c = "6";}
               if (b2b == 3) {c = "5";}
            }   
            if (b1b == 2) {
               if (b2b == 0) {c = "A";}
               if (b2b == 1) {c = "6";}
               if (b2b == 3) {c = "3";}
            }
            if (b1b == 3) {
               if (b2b == 0) {c = "9";}
               if (b2b == 1) {c = "5";}
               if (b2b == 2) {c = "3";}
            }
         } else {                            // different nibbles  
            if (b1b == 3) {b1v = "1";}
            if (b1b == 2) {b1v = "2";}
            if (b1b == 1) {b1v = "4";}
            if (b1b == 0) {b1v = "8";}
            if (b2b == 3) {b2v = "1";}
            if (b2b == 2) {b2v = "2";}
            if (b2b == 1) {b2v = "4";}
            if (b2b == 0) {b2v = "8";}
         }
               
         // replace appropriate character in result
         if (b1n == b2n) {                      // same nibble
            for (var i = 0; i <= 7; i++) {      // for each of 8 nibbles
               if (i == b1n) {
                  result += c;
               } else {
                  result += "0";
               }
            }
         } else {                            // different nibbles
            for (var i = 0; i <= 7; i++) {   // for each of 8 nibbles
               if (i == b1n) {               // if bit1's nibble
                  result += b1v;             // append bit1 value
               } else {
                  if (i == b2n) {            // else if bit2's nibble
                     result += b2v;          // append bit2 value
                  } else {
                     result += "0";          // else append 0
                  }
               }
            }
         }            
         return result;
      }
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// computes mux output
      function calcMux(sel, data, loc_a, loc_b, loc_d) {
         var out = "XXXXXXXX";
         result = "";
 
        switch (sel) { 
            case "NONE"  :  out = "0X" + data; break;
            case "SGL_A" :  out = calcXor(data, loc_a); break;
            case "SGL_B" :  out = calcXor(data, loc_b); break;
            case "DBL"   :  out = calcXor(data, loc_d); break;
            case "TPL"   :  out = "XXXXXXXX"; break;
            default      :  out = "XXXXXXXX";
         }
         return out;
      }      
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// parses the "a" checkbit field from the 16-bit checkbit pattern
      function findCka(x) {
         var a = "";
         var b = 0;
         
         for(var i = 0; i <= 1; i++) {
            b = x.charAt(i);
            a += b; //Math.pow(16*b, 1-i);
         }
         a = Math.floor(("0X" + a)/2);
         return toHex(a);
       }      
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// parses the "b parity" field from the 16-bit checkbit pattern
      function findPb(x) {
         var a = "0X";
         var b = 0;
         
         for(var i = 0; i <= 1; i++) {
            b = x.charAt(i);
            a += b; //Math.pow(16*b, 1-i);
         }
         a = a % 2;         
         return a;
      }     
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// parses the parity b field from the 16-bit checkbit pattern
      function findCkb(x) {
         var a = "0X";
         var b = 0;
         
         for(var i = 0; i <= 1; i++) {
            b = x.charAt(i+2);
            a += b; //Math.pow(16*b, 1-i);
         }
         return a;
       }      
//-----------------------------------------------------------------------------



//-----------------------------------------------------------------------------
//                            Utilities
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// converts binary to hex
      function bin2hex(x) {
         var a = x.length - 1;
         result = x;
         for(var i = 0; i <= a; i++) {
            if (x.charAt(i) == "1") {
               result = result - Math.pow(10, a-i) + Math.pow(2, a-i);
            }
         }
         return toHex(result);
       }      
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// check for hex value, add leading 0s, convert to uppercase
      function valIn(x) {
         var a = x.length;
         hexChars = "0123456789ABCDEF";
         var c = new Array(8);
         var d = new Array(8);
         var e = new Array(8);
         result = "";
  
        x = x.toUpperCase();
  
        for (var i = 0; i <= 7; i++) {       // for each of 8 characters 
            if (i < (8 - a)) {               // need to insert leading zeroes
               c[i] = 0X0;                   // leading nibbles=0 if length<8
            } else {
               c[i] = "0X" + x.charAt(i - 8 + a);
            }
         
            e[i] = c[i];                     //
            result += hexChars.charAt(e[i]); // append to result
         }
         return result;
       }                   
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// check for hex value, add leading 0s, convert to uppercase, 4 char input
      function valIn4(x) {
         var a = x.length;
         hexChars = "0123456789ABCDEF";
         var c = new Array(4);
         var d = new Array(4);
         var e = new Array(4);
         result = "";
  
        x = x.toUpperCase();
  
        for (var i = 0; i <= 3; i++) {       // for each of 4 characters 
            if (i < (4 - a)) {               // need to insert leading zeroes
               c[i] = 0X0;                   // leading nibbles=0 if length<8
            } else {
               c[i] = "0X" + x.charAt(i - 4 + a);
            }
         
            e[i] = c[i];                     //
            result += hexChars.charAt(e[i]); // append to result
         }
         return result;
       }                   
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// converts dec to hex
      function toHex(dec) {
         hexChars = "0123456789ABCDEF";
         if (dec > 255) {
            return null;
         }
         var i = dec % 16;
         var j = (dec - i) / 16;
         result = "0X";
         result += hexChars.charAt(j);
         result += hexChars.charAt(i);
         return result;
      }
//-----------------------------------------------------------------------------




//-----------------------------------------------------------------------------
//                            Control elements
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// counts number of ones in a syndrome
      function calcOneCnt(x) {
         var a = x.length - 1;
         result = 0;
         for(var i = 0; i <= a; i++) {
            if ((x.charAt(i) == "1") | (x.charAt(i) == "2") | 
                (x.charAt(i) == "4") | (x.charAt(i) == "8")) {
               result++;
            }
            
            if ((x.charAt(i) == "3") | (x.charAt(i) == "5") | 
                (x.charAt(i) == "6") | (x.charAt(i) == "9") | 
                (x.charAt(i) == "A") | (x.charAt(i) == "C")) {
               result += 2;
            }
            
            if ((x.charAt(i) == "7") | (x.charAt(i) == "B") | 
                (x.charAt(i) == "D") | (x.charAt(i) == "E")) {
               result += 3;
            }
            
            if (x.charAt(i) == "F") { 
                result += 4;
            }
           
         }
         return result;
      }      
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// calculates parity of a vector input
      function calcSyndPar(x) {
         var a = x.length - 1;
         result = false;
         for(var i = 0; i <= a; i++) {
            if (x.charAt(i) == "1") {
               result = !result; 
            }   
         }
         
         if (result) {
            return "1";
         } else {
            return "0";
         }
      }      
//-----------------------------------------------------------------------------


//----------------------------------------------------------------------------------------
// control function
//
// diff_a_cnt, diff_b_cnt, tpl, par_b and lb0 are control inputs
//
// control output is the err_type signal, which indicates if the error is uncorrectable
// or which corrector output to use

function calcCtl(diff_a_cnt, diff_b_cnt, tpl, par_b, lb0) {

var err_type;

   // default the err_type to none
   err_type = "NONE";
   
   switch (diff_a_cnt) {

     case 0 :
       if ((diff_b_cnt == 3) && (par_b == 0)) {
         err_type = "TRP";
       }
       break;

     case 1 :
       if ((diff_b_cnt == 1) && (par_b == 0)) {
         err_type = "TRP";
       }

       if (diff_b_cnt == 2) {
         err_type = "TRP";
       }

       if (diff_b_cnt == 3) {
         err_type = "TRP";
       }

       if (diff_b_cnt == 4) {
         err_type = "TRP";
       }

       if (diff_b_cnt == 5) {
         err_type = "TRP";
       }

       if (diff_b_cnt == 6) {
         err_type = "TRP";
       }

       if (diff_b_cnt == 7) {
         err_type = "TRP";
       }
       break;

     case 2 :
       if (diff_b_cnt == 1) {
         err_type = "TRP";
       }

       if ((diff_b_cnt == 2) && (par_b == 0)) {
         err_type = "DBL";
       }

       if ((diff_b_cnt == 2) && (par_b == 1)) {
         err_type = "TRP";
       }

       if ((diff_b_cnt == 3) && (par_b == 0)) {
         err_type = "SGL_B";
       }

       if ((diff_b_cnt == 3) && (par_b == 1)) {
         err_type = "TRP";
       }

       if ((diff_b_cnt == 4) && (par_b == 0)) {
         err_type = "DBL";
       }

       if ((diff_b_cnt == 4) && (par_b == 1)) {
         err_type = "TRP";
       }

       if (diff_b_cnt == 5) {
         err_type = "TRP";
       }

       if ((diff_b_cnt == 6) && (par_b == 0)) {
         err_type = "DBL";
       }

       if ((diff_b_cnt == 6) && (par_b == 1)) {
         err_type = "TRP";
       }

       if (diff_b_cnt == 7) {
         err_type = "TRP";
       }

       break;

     case 3 :
       if (diff_b_cnt == 0) {
         err_type = "TRP";
       }

       if (diff_b_cnt == 1) {
         err_type = "TRP";
       }

       if ((diff_b_cnt == 2) && (par_b == 0)) {
         err_type = "TRP";
       }

       if ((diff_b_cnt == 2) && (par_b == 1)) {
         err_type = "SGL_A";
       }

       if ((diff_b_cnt == 3) && (par_b == 0) && (tpl == 0) && (lb0 == 0)) {
         err_type = "SGL_A";
       }

       if ((diff_b_cnt == 3) && (par_b == 0) && (tpl == 0) && (lb0 == 1)) {
         err_type = "TRP";
       }

       if ((diff_b_cnt == 3) && (par_b == 0) && (tpl == 1)) {
         err_type = "TRP";
       }
       
       if ((diff_b_cnt == 3) && (par_b == 1) && (tpl == 0)) {
         err_type = "SGL_A";
       }

       if ((diff_b_cnt == 3) && (par_b == 1) && (tpl == 1)) {
         err_type = "TRP";
       }

       if ((diff_b_cnt == 4) && (par_b == 0)) {
         err_type = "TRP";
       }

       if ((diff_b_cnt == 4) && (par_b == 1)) {
         err_type = "SGL_A";
       }

       if (diff_b_cnt == 5) {
         err_type = "TRP";
       }

       if (diff_b_cnt == 6) {
         err_type = "TRP";
       }

       if (diff_b_cnt == 7) {
         err_type = "TRP";
       }

       break;

     case 4 :
       if (diff_b_cnt == 1) {
         err_type = "TRP";
       }

       if ((diff_b_cnt == 2) && (par_b == 0)) {
         err_type = "DBL";
       }

       if ((diff_b_cnt == 2) && (par_b == 1)) {
         err_type = "TRP";
       }

       if ((diff_b_cnt == 3) && (par_b == 0)) {
         err_type = "SGL_B";
       }

       if ((diff_b_cnt == 3) && (par_b == 1)) {
         err_type = "TRP";
       }

       if ((diff_b_cnt == 4) && (par_b == 0)) {
         err_type = "DBL";
       }

       if ((diff_b_cnt == 4) && (par_b == 1)) {
         err_type = "TRP";
       }

       if (diff_b_cnt == 5) {
         err_type = "TRP";
       }

       if ((diff_b_cnt == 6) && (par_b == 0)) {
         err_type = "DBL";
       }

       if ((diff_b_cnt == 6) && (par_b == 1)) {
         err_type = "TRP";
       }
         
       if (diff_b_cnt == 7) {
         err_type = "TRP";
       }

       break;

     case 5 :
       err_type = "TRP";
       break;

     case 6 :
       if (diff_b_cnt == 1) {
         err_type = "TRP";
       }

       if ((diff_b_cnt == 2) && (par_b == 0)) {
         err_type = "DBL";
       }

       if ((diff_b_cnt == 2) && (par_b == 1)) {
         err_type = "TRP";
       }

       if (diff_b_cnt == 3) {
         err_type = "TRP";
       }

       if ((diff_b_cnt == 4) && (par_b == 0)) {
         err_type = "DBL";
       }

       if ((diff_b_cnt == 4) && (par_b == 1)) {
         err_type = "TRP";
       }

       if (diff_b_cnt == 5) {
         err_type = "TRP";
       }

       if ((diff_b_cnt == 6) && (par_b == 0)) {
         err_type = "DBL";
       }

       if ((diff_b_cnt == 6) && (par_b == 1)) {
         err_type = "TRP";
       }

       if (diff_b_cnt == 7) {
         err_type = "TRP";
       }

       break;

     case 7 :
       err_type = "TRP";
       break;

     case 9 :
       err_type = "TRP";
       break;

     default :
       err_type = "NONE";

      }  // end case

    return err_type;
}
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// calculates text error message
      function calcErrMsg(x) {

        switch (x) {

          case "NONE" :
            return "Data Valid";
            break;

          case "SGL_A" :
            return "Data Valid";
            break;
            
          case "SGL_B" :
            return "Data Valid";
            break;
            
          case "DBL" :
            return "Data Valid";
            break;
            
          case "TRP" :
            return "Data Error!";
            break;
            
          default :
            return "!@#$%";
         }
      }      
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// calculates text error message
      function calcNote(x) {

        switch (x) {

          case "NONE" :
            return "No errors";
            break;

          case "SGL_A" :
            return "Single Bit Error Corrected";
            break;
            
          case "SGL_B" :
            return "Single Bit Error Corrected";
            break;
            
          case "DBL" :
            return "Double Bit Error Corrected";
            break;
            
          case "TRP" :
            return "Triple Bit Error Detected";
            break;
            
          default :
            return "!@#$%";
         }
      }      
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// calculates text error message
      function calcMuxMsg(x) {

        switch (x) {

          case "NONE" :
            return "sgl_A";
            break;

          case "SGL_A" :
            return "sgl_A";
            break;
            
          case "SGL_B" :
            return "sgl_B";
            break;
            
          case "DBL" :
            return "dbl";
            break;
            
          case "TRP" :
            return "XXX";
            break;
            
          default :
            return "!@#$%";
         }
      }      
//-----------------------------------------------------------------------------



//-----------------------------------------------------------------------------
// calculates if two 32-bit vectors are equal
      function calcTpl(x,y) {
         var a = 0;
         
         a = calcXor(x,y);
         
         if (a != "0X00000000") {
            return "1";
         } else {
            return "0";
         }
      }      
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// calculates if vector input is all 0
      function calcLb0(x) {
         if (x == "00000000") {
            return "1";
         } else {
            return "0";
         }
      }      
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//                            IO
//-----------------------------------------------------------------------------
// compute function of two form inputs
      function calcInCk(form) {
         var x = form.entry1.value;
         var ckin;
         var ckout;

         // calculate the check bits based on the data
         ckin = calcCk(bin2hex(calcCka(x)), calcSyndPar(calcCkb(x)), bin2hex(calcCkb(x)));
         ckout = calcCk(bin2hex(calcCka(x)), calcSyndPar(calcCkb(x)), bin2hex(calcCkb(x)));
         
         // validate inputs
         form.entry1.value = valIn(x);
         form.entry2.value = valIn(x);
         form.ckin.value = ckin;
         form.ckout.value = ckout;
                  
         // clear the rest of the form        
         form.resultn.value = "";
         form.resultm.value = "";
         // form.resulta.value = "";
         // form.resultb.value = "";
         // form.resulto.value = "";
         // form.resultp.value = "";
         // form.resultc.value = "";
         // form.resultd.value = "";
         // form.resulte.value = "";
         // form.resultf.value = "";
         // form.resultg.value = "";
         // form.resulth.value = "";
         // form.resulti.value = "";
         // form.resultj.value = "";
         // form.resultk.value = "";
         // form.resultl.value = "";
         // form.resultq.value = "";
         // form.resultr.value = "";
         // form.results.value = "";                           
      }
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// compute function of two form inputs
      function calcAll(form) {
         var x = form.entry1.value;
         var y = form.entry2.value;
         var z = form.ckout.value;

         var cka;
         var ckb;
         var pb;
         var ckin;
         var ckout;
         var synda;
         var syndb;
       
         var loc_a;
         var loc_b;
         var loc_d;
         var diff_a_cnt;
         var diff_b_cnt;
         var tpl;
         var par_b;
         var lb0;         
         var sel;
         var out;
         var err_msg;
         var note_msg;
         var mux_msg;

         // cleanup (edited) y field
         y = valIn(y);
         form.entry2.value = y;
         
         // cleanup (edited) ckout field
         z = valIn4(z);
         form.ckout.value = z;
         
         // parse ckout to find individual checkbit fields
         cka = findCka(z);
         ckb = findCkb(z);
         pb =  findPb(z);

         // find syndromes
         synda = toHex(cka ^ bin2hex(calcCka(y)));
         syndb = toHex(ckb ^ bin2hex(calcCkb(y)));

         // locators
         loc_a = calcLoca(synda);
         loc_b = calcLocb(syndb);
         loc_d = calcLocd(synda, syndb);

         // control
         diff_a_cnt = calcOneCnt(synda);
         diff_b_cnt = calcOneCnt(syndb);
         tpl = calcTpl(loc_a, loc_b);
         par_b = calcPar(calcXor1(ckb), pb);
         lb0 = calcLb0(loc_b);
         sel = calcCtl(diff_a_cnt, diff_b_cnt, tpl, par_b, lb0);

         // mux
         out = calcMux(sel, y, loc_a, loc_b, loc_d);
         err_msg = calcErrMsg(sel);
         note_msg = calcNote(sel);
         mux_msg = calcMuxMsg(sel);

         GlobalDataIn = "0X" + y;
         GlobalCka = cka;
         GlobalCkb = ckb;
         GlobalParityB = pb;
   
         GlobalCheckA = bin2hex(calcCka(y));
         GlobalSyndA = synda;
         GlobalCheckB = bin2hex(calcCkb(y));
         GlobalSyndB = syndb;
   
         GlobalSglALoc = "0X" + loc_a;
         GlobalSglBLoc = "0X" + loc_b;
         GlobalDbl = "0X" + loc_d;
         GlobalParB = par_b;
         GlobalSglTpl = tpl;
         GlobalLb0 = lb0;
   
         GlobalDataOut = out;
         GlobalError = err_msg;
         GlobalMux = mux_msg;
         
         // form.resulta.value = calcCka(x);
         // form.resultb.value = calcCka(y);
         // form.resulto.value = calcCkb(x);
         // form.resultp.value = calcCkb(y);         
         // form.resultc.value = synda;
         // form.resultd.value = syndb;
         // form.resulte.value = loc_a;
         // form.resultf.value = loc_b;
         // form.resultg.value = loc_d;
         // form.resulth.value = diff_a_cnt;
         // form.resulti.value = diff_b_cnt;
         // form.resultj.value = par_b;
         // form.resultk.value = tpl;
         // form.resultl.value = lb0;
         form.resultm.value = err_msg;
         form.resultn.value = out;
         form.resultt.value = note_msg;
         // form.resultq.value = cka;
         // form.resultr.value = ckb;
         // form.results.value = pb;
         
         // debug text boxes to be put in form
         // <b>Internal datapath values</b><br /><br />
         //   Cka(in) (binary): <input type="text" name="resulta" size="12" /><br /><br />
         //   Cka(out) (binary): <input type="text" name="resultb" size="12" /><br /><br />
         //   Ckb(in) (binary): <input type="text" name="resulto" size="12" /><br /><br />
         //   Ckb(out) (binary): <input type="text" name="resultp" size="12" /><br /><br />
         //   Synda (hex): <input type="text" name="resultc" size="12" /><br /><br />
         //   Syndb (hex): <input type="text" name="resultd" size="12" /><br /><br />
         //   Loca (hex): <input type="text" name="resulte" size="12" /><br /><br />
         //   Locb (hex): <input type="text" name="resultf" size="12" /><br /><br />
         //   Locd (hex): <input type="text" name="resultg" size="12" /><br /><br />
         //   Cnta: <input type="text" name="resulth" size="12" /><br /><br />
         //   Cntb: <input type="text" name="resulti" size="12" /><br /><br /> 
         //   Parb: <input type="text" name="resultj" size="12" /><br /><br />
         //   tpl: <input type="text" name="resultk" size="12" /><br /><br />
         //   lb0: <input type="text" name="resultl" size="12" /><br /><br />
         //   cka (parse): <input type="text" name="resultq" size="12" /><br /><br />
         //   ckb (parse): <input type="text" name="resultr" size="12" /><br /><br />
         //   parb (parse): <input type="text" name="results" size="12" /><br /><br />
      }      
//-----------------------------------------------------------------------------

      </script>
      <base target="main">
   </head>
   <body>
      <form name="inForm">
      <div align="center">
        <center>
        <table border="0" width="14%">
          <tr>
            <td width="11%" align="center">
              <p align="center"><a href="help.htm" target="_blank">Help</a></td>
            <td width="89%" align="center"><a href="help.htm" target="_blank"><img border="0" src="bd00038_.gif"></a></td>
          </tr>
        </table>
        </center>
      </div>
      <p style="margin-top: 16; margin-bottom: 0" align="left"><b><font color="#FF0000">Step 1</font> -- Enter Data
      Written To
      Memory</b>
      <p align="center" style="margin-top: 10"> 0X<input type="text" name="entry1" size="12" tabindex="1" /></p>
      <hr />
      <p style="margin-left: 0; margin-top: 0; margin-bottom: 0">
      <b><font color="#FF0000">Step 2</font> -- Calculate Check Bits Written To
      Memory</b>
      <p style="margin-left: 0; margin-top: 10; margin-bottom: 0" align="center"><input type="button" value="Calculate Check Bits" onclick="calcInCk(this.form)" style="border-style: outset" tabindex="2" />
      <p style="margin-left: 0; margin-top: 10; margin-bottom: 0" align="center">
 0X<input type="text" name="ckin" size="6" />
      <hr />
         <p style="margin-top: 0; margin-bottom: 0" align="left">
      <b><font color="#FF0000">Step 3</font> -- Edit Data and/or Check Bits Read
      From Memory</b>
      <p style="margin-top: 0; margin-bottom: 0" align="center"><b>(Edit These
      Entries to Inject Errors)</b>
         <p style="margin-top: 10; margin-bottom: 0" align="center">
      Data read from memory:&nbsp; 0X<input type="text" name="entry2" size="12" tabindex="3" />
         <p style="margin-top: 10; margin-bottom: 0" align="center"> Check bits
         read from memory:&nbsp;
         0X<input type="text" name="ckout" size="6" tabindex="4" /></p>
         <hr />
      <p style="margin-top: 0; margin-bottom: 0">
      <b><font color="#FF0000">Step 4</font> -- Decode Data and Check Bits Read
      From Memory</b>
      <p style="margin-top: 10; margin-bottom: 0" align="center">
         <input type="button" value="Decode" onclick="calcAll(this.form)" tabindex="5" />
      <p style="margin-top: 10; margin-bottom: 0" align="center">
         Data returned to processor:&nbsp; <input type="text" name="resultn" size="12" style="border-style: outset" />
      <p style="margin-top: 10; margin-bottom: 0" align="center">
         Error status returned:&nbsp; <input type="text" name="resultm" size="18" />
      <p style="margin-top: 10; margin-bottom: 0" align="center">
         Error Note:&nbsp; <input type="text" name="resultt" size="28" />         
      </form>
   </body>
</html> 