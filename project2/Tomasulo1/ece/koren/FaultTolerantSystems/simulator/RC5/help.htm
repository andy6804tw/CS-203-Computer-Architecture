<html>

<head>
<title>Help Window</title>
</head>

<body>

<p align="center"><u><span style="letter-spacing: 1"><font size="3" color="#000099"><B><U><FONT color=#000080>Simulator for Concurrent Fault Detection in a Hardware 
Implementation of the RC5 Encryption Algorithm </FONT></U></B></font></span></u></p>

<p align="center"><font size="5"><b><u>Help Window</u></b></font></p>

<p>A detailed description of the RC5 encryption algorithm can be found in [1].
In [2] you can read about concurrent fault detection in a RC5 hardware
implementation.&nbsp;</p>

<p><b><font size="4"><u>Table of Contents</u></font></b></p>

<ul>
  <li><a href="#configuration">Configuration</a></li>
  <li><a href="#encryption">Encryption</a></li>
  <li><a href="#faultinjection">Fault Injection</a></li>
  <li><a href="#keytable">Expanded Key Table</a></li>
  <li><a href="#references">References</a></li>
</ul>
<p><b><u><font size="4"><a name="configuration">Configuration</a></font></u></b></p>

<table border="1"><tr><td>
<table border="0"><tr><td>

<img border="0" src="f1.png" width="1004" height="315">
</td></tr>
<tr><td>
Figure 1: Configuration Fields
</td></tr></table>

</td></tr></table>

<p>Figure 1 shows the configuration part of the simulator.</p>

<table border="0" width="100%" cellpadding="10" bgcolor="#CCFFCC"><tr><td>

In the green fields you can configure the RC5 algorithm.&nbsp;
<p> Plaintext and secret key have to be written in hexadecimal.&nbsp;</p>
<p> 
After inserting a new secret key or a different round number you should click on the respective
&quot;Apply&quot; button, so that the 
program can update the configuration display.</p>
<p>The plaintext must have the length of two words.</p>

<p>Allowed values for the word size: 16 bit, 32 bit, 64 bit</p>

<p>Allowed values for the number of rounds: 1,2, ... ,255 (note: the RC5
specification also allows 0 rounds)</p>

<p>Allowed number of bytes in the secret key: 1,2, ... ,255 (note: the RC5
specification also allows a secret key with 0 bytes)</p>

<p>When you click on the &quot;Show Expanded Key Table&quot; button, the
expanded key table is displayed underneath the configuration fields (<a href="#keytable">see
figure 10</a>)</p>

</td></tr></table>

<table border="0"><tr><td height="5">

</td></tr></table>

<table border="0" width="100%" cellpadding="10" bgcolor="#99CCFF"><tr><td>


In the blue field you can configure the fault detection hardware namely the
number and the locations of the checkpoints.
<p>The first selectable checkpoint, which has no round number associated with
it, is located just before round 1, i.e. after the first two additions.</p>
<p>All other checkpoints are located at the end of the respective round, i.e.
the checkpoint of the last round, which is selected by default, checks the
output of the encryption, i.e. the chiphertext.&nbsp;</p>
<p>You can click on the &quot;Select all&quot; button to select all checkpoints.


</td></tr></table>

<table border="0"><tr><td height="5">

</td></tr></table>

<table border="0" width="100%" cellpadding="10" bgcolor="#E4A69E"><tr><td>





In the two brown-red fields you can configure the display which will show the
encryption steps.
<p>The data of each round will be displayed after each operation (xor, rotation,
addition) that you select. You have to select at least one operation.</p>
<p>Note: Later you can only insert faults in data which is displayed (e.g. if
you do not select rotation you will not be able to insert faults right after the
rotation operation (Note that in a real hardware implementation it is probably
only possible to inject faults into registers, because it is much more
difficult, if not impossible, to find an exact bit position in the middle of a
combinatorial circuit. Since the data is only stored after the addition
operation in each round, it is more realistic if you only inject faults there.
It is still good to display the data after each operation, if you want to see
the diffusion of an injected bit error)).</p>
<p>You can choose to display the block data (word A and word B) either in binary
(BIN) or in hexadecimal (HEX). If you use a word size of 64 bit you might want
to display the data in hexadecimal so that you do not need to scroll
horizontally. If the block data is displayed in binary you can much better see
the diffusion of the injected bit error.

</td></tr></table>

<table border="0"><tr><td height="5">

</td></tr></table>

<table border="0" width="100%" cellpadding="10" bgcolor="#FF0000"><tr><td>


Click on the &quot;Show Encryption&quot; button when you are done with the
configuration

</td></tr></table>


<p>&nbsp;</p>


<p><b><u><font size="4"><a name="encryption">Encryption</a></font></u></b></p>



<img border="0" src="f2a.png" width="1000" height="515"><img border="0" src="f2b.png" width="1003" height="470"><img border="0" src="f2c.png" width="1003" height="376"><img border="0" src="f2d.png" width="1003" height="221">







<p>&nbsp;Figure 2: Encryption Display</p>
<p>When you click on the &quot;Show Encryption&quot; button the encryption steps
are displayed underneath the configuration fields (see figure 2).&nbsp;</p>
<p>The first row shows the contents of the two registers before encryption. Note
that the order of the bytes gets reversed when the plaintext is copied into the
registers (see figure 3).</p>
<p>The second row shows the data after the first two additions before round 1.
In figure2 three rows of data are displayed for each round: The first row shows
the data after XOR, the second row shows the data after Rotation, and the third
row shows the data after Addition.</p>
<p>On the right side of each word four error detection codes (EDCs) are shown.</p>
<ul>
  <li>WP = Word Parity</li>
  <li>BP = Byte Parity</li>
  <li>R2 = Residue 2^2-1 = Radix-3 Residue</li>
  <li>R4 = Residue 2^4-1 = Radix-15 Residue&nbsp; (for word size = 32 bit)</li>
  <li>R8 = Residue 2^8-1 = Radix-255 Residue&nbsp; (for word size = 64 bit)</li>
</ul>
<p>The EDCs are calculated in the first row from the two words, and in the
following rows the EDCs are predicted using the prediction formulas which are
presented in [2]. At each checkpoint the EDCs are newly calculated from the data
and compared to the predicted EDCs. If they do not match an error is detected at
the checkpoint. Except in the first row, only the predicted EDCs are displayed.</p>
<p><img border="0" src="f3.png" width="996" height="445"></p>
<p>Figure 3: Copying the plaintext into registers</p>






<p>Figure 3 illustrates how the order is reversed. The first byte is copied to
the bit positions a7...a0 and so on. In the case of 32 bit word length the last
byte of the plaintext is copied to b31...b24.</p>






<p>Figure 4 illustrates the order in which the encrypted data is read out of the
two registers.</p>






<p><img border="0" src="f4.png" width="1002" height="172">&nbsp;</p>



<p>Figure 4</p>

<p>&nbsp;</p>

<p><b><u><font size="4"><a name="faultinjection">Fault Injection</a></font></u></b></p>

<p>You can inject faults into the data and into the EDCs. You can inject as many
faults as you want.</p>

<p>To inject a fault you type the bit number into the textbox on the right side
and hit the &quot;Enter&quot; key. <b><font color="#FF0000">Note: In some
browsers, instead of hitting &quot;Enter&quot;, you have to click outside the
textbox after inserting the bit number in order to inject the fault.</font></b></p>

<p><img border="0" src="f5.png" width="929" height="74"></p>

<p>Figure 5</p>

<p>In figure 5 a fault is injected into the second bit of word A (i.e. a1) in
the second round after the rotation operation.</p>

<p>Note (already noted previously): It is more realistic to inject faults only
after the addition operation, because that is where the intermediate result is
stored into a register. Even finding the right flip flop and inserting the fault
there can be very difficult depending on the hardware implementation and the
technology.</p>

<p><img border="0" src="f6.png" width="929" height="213"></p>

<p>Figure 6</p>
<p>After injecting a new fault the encryption is recalculated with this fault.
Figure 6 shows part of the encryption display after the fault injection into the
second bit of word A in round 2 after the rotation operation.</p>
<p>All faulty bits are displayed red. A bit is faulty if it is different from
the respective bit which was calculated without faults.</p>
<p>Checkpoints which detect errors report by which EDCs the error was detected.
In figure 6 the checkpoint after the fault reports that the error was detected
by all four EDCs.</p>
<p><img border="0" src="f7.png" width="929" height="73"></p>
<p>Figure 7</p>
<p>When injecting a fault into an EDC the fault is injected into all four EDCs.&nbsp;</p>
<p>To inject a fault into the EDCs, type the desired bit number into the textbox
on the right side of the EDCs. The fault will always be injected into the word
parity bit, no matter which bit number you choose. If you choose a bit number
bigger than one, a fault will be injected into the second bit of the two radix-3
residue bits.</p>
<p>Figure 7 shows an example. A fault is injected into the third bit of the EDCs
of word B in round 2 after the rotation operation. Figure 8 shows the result.</p>
<p><img border="0" src="f8.png" width="928" height="110"></p>
<p>Figure 8</p>
<p>Note that this error was not detected by the byte parities.</p>
<p>Figure 9 shows the entire encryption display after the error injection shown
in figure 5.</p>
<p><img border="0" src="f9a.png" width="1005" height="515"><img border="0" src="f9b.png" width="1005" height="470"><img border="0" src="f9c.png" width="1005" height="377"><img border="0" src="f9d.png" width="1004" height="215"></p>
<p>Figure 9</p>
<p>&nbsp;</p>
<p><b><u><font size="4"><a name="keytable">Expanded Key Table</a></font></u></b></p>
<p><img border="0" src="f10a.png" width="1004" height="507"><img border="0" src="f10b.png" width="1005" height="432"></p>
<p>Figure 10</p>
<p>&nbsp;&nbsp;</p>
<p><b><u><font size="4"><a name="references">References</a></font></u></b></p>
<p>[1] Ronald L. Rivest, &quot;The RC5 Encryption Algorithm&quot;, Proceedings
of the 1994 Leuven Workshop on Fast Software Encryption (Springer 1995), pages
86-96.</p>
<p>[2] G. Bertoni, L. Breveglieri, I. Koren, P. Maistri and V. Piuri, "Concurrent Fault Detection 
in a Hardware Implementation of the RC5 Encryption Algorithm&quot;, Proc. of ASAP'03 - the Internl. Conference on 
Application-Specific Systems, Architectures and Processors, pp. 423-432, 
June 2003.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

</body>

</html>
