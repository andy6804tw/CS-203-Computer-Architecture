<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>Fault Detection in AES Encoder and Decoder</TITLE>
<META http-equiv=Content-Type content="text/html">
<SCRIPT language=JavaScript 
src="rijndael.js" 
type=text/javascript>
</SCRIPT>

<SCRIPT language=JavaScript type=text/javascript><!--

// Quick and dirty functionality -- I have to study!

function doEncryption() {
  var ptArray, keyArray;
  var theForm = document.forms[0];
  keySizeInBits = theForm.keySize[theForm.keySize.selectedIndex].value;
  blockSizeInBits = theForm.blockSize[theForm.blockSize.selectedIndex].value;
  if (theForm.key.value.toLowerCase().indexOf("0x") == 0)
    theForm.key.value = theForm.key.value.substring(2);
  if (theForm.plaintext.value.toLowerCase().indexOf("0x") == 0)
    theForm.plaintext.value = theForm.plaintext.value.substring(2);
  
  if (theForm.key.value.length*4 != keySizeInBits) {
    alert("For a " + keySizeInBits + " bit key, the hex string needs to be " +
          (keySizeInBits / 4) + " hex characters long.");
    if (theForm.key.select)
       theForm.key.select();
    return;
  }

  if (theForm.plaintext.value.length*4 != blockSizeInBits) {
    alert("For a " + blockSizeInBits + " bit block, the hex plaintext string needs to be " +
          (blockSizeInBits / 4) + " hex characters long.");
    if (theForm.plaintext.select)
       theForm.plaintext.select();
    return;
  }
     
  ptArray = hexToByteArray(theForm.plaintext.value);
  keyArray = hexToByteArray(theForm.key.value);
  theForm.ciphertext.value = 
     byteArrayToHex(rijndaelEncrypt(ptArray, keyArray, "ECB"));

}

function doDecryption() {
  var ctArray, keyArray;
  var theForm = document.forms[0];
  keySizeInBits = theForm.keySize[theForm.keySize.selectedIndex].value;
  blockSizeInBits = theForm.blockSize[theForm.blockSize.selectedIndex].value;
  if (theForm.key.value.toLowerCase().indexOf("0x") == 0)
    theForm.key.value = theForm.key.value.substring(2);
  if (theForm.ciphertext.value.toLowerCase().indexOf("0x") == 0)
    theForm.ciphertext.value = theForm.ciphertext.value.substring(2);
  
  if (theForm.key.value.length*4 != keySizeInBits) {
    alert("For a " + keySizeInBits + " bit key, the hex string needs to be " +
          (keySizeInBits / 4) + " hex characters long.");
    if (theForm.key.select)
       theForm.key.select();
    return;
  }

  if (theForm.ciphertext.value.length*4 != blockSizeInBits) {
    alert("For a " + blockSizeInBits + " bit block, the hex ciphertext string needs to be " +
          (blockSizeInBits / 4) + " hex characters long.");
    if (theForm.ciphertext.select)
       theForm.ciphertext.select();
    return;
  }
     
  ctArray = hexToByteArray(theForm.ciphertext.value);
  keyArray = hexToByteArray(theForm.key.value);
  theForm.plaintext.value = 
     byteArrayToHex(rijndaelDecrypt(ctArray, keyArray, "ECB"));

}

//yongkui

function isEqual(byteArray1, byteArray2) {
  if (byteArray1.length != byteArray2.length) return false;
  for (var i=0; i<byteArray1.length; i++) {
    if (byteArray1[i] != byteArray2[i]) return false;
  }
  return true;
}

function hykByteArrayToBinary(byteArray) {
  var result = "";
  if (!byteArray)
    return;
  for (var i=0; i<byteArray.length; i++)
    result += byteArray[i].toString(10);
  
  return result;
}

function hykBinaryToByteArray(binaryString) {
  var byteArray = [];
  
  for (var i = 0; i<binaryString.length; i++) 
    byteArray[i] = parseInt(binaryString.slice(i, i+1), 16);
  return byteArray;
}

/////////
function doEncryption_HYK() {
  var theForm = document.forms[0];
  var ptArray, ctArray, keyArray;
  var parityArray; var detectArray = []; var generatedParityArray;
  
  selectedRound = theForm.round.value;
  if (selectedRound == "" || selectedRound < 0 || selectedRound > Nr) {
    alert("you must specify a round# between 0 and " + Nr + "!");
    return;
  }
  
  keySizeInBits = theForm.keySize[theForm.keySize.selectedIndex].value;
  blockSizeInBits = theForm.blockSize[theForm.blockSize.selectedIndex].value;
  if (theForm.key.value.toLowerCase().indexOf("0x") == 0)
    theForm.key.value = theForm.key.value.substring(2);
  if (theForm.plaintext.value.toLowerCase().indexOf("0x") == 0)
    theForm.plaintext.value = theForm.plaintext.value.substring(2);
  
  
  if (theForm.key.value.length*4 != keySizeInBits) {
    alert("For a " + keySizeInBits + " bit key, the hex string needs to be " +
          (keySizeInBits / 4) + " hex characters long.");
    if (theForm.key.select)
       theForm.key.select();
    return;
  }

  if (theForm.plaintext.value.length*4 != blockSizeInBits) {
    alert("For a " + blockSizeInBits + " bit block, the hex plaintext string needs to be " +
          (blockSizeInBits / 4) + " hex characters long.");
    if (theForm.plaintext.select)
       theForm.plaintext.select();
    return;
  }
       
  ptArray = hexToByteArray(theForm.plaintext.value);
  keyArray = hexToByteArray(theForm.key.value);
  theForm.ciphertext.value = 
     byteArrayToHex(rijndaelEncrypt(ptArray, keyArray, "ECB"));
 
  //print the output for intermediate round.
  
  if (selectedRound == 0) {
    theForm.SubBytes.value = "undefined";
    theForm.p_SubBytes.value = "undefined";
  }
  else {  
    theForm.SubBytes.value = byteArrayToHex(hykDataSubBytes);
    theForm.p_SubBytes.value = hykByteArrayToBinary(hykParitySubBytes);
  }
  
  if (selectedRound == 0) {
    theForm.ShiftRows.value = "undefined";
    theForm.p_ShiftRows.value = "undefined";
  }
  else {
    theForm.ShiftRows.value = byteArrayToHex(hykDataShiftRows);
    theForm.p_ShiftRows.value = hykByteArrayToBinary(hykParityShiftRows);
  }
  
  if (selectedRound == 0) {
    theForm.MixColumns.value = "undefined";
    theForm.p_MixColumns.value = "undefined";
  }
  else if (selectedRound == Nr) {
    theForm.MixColumns.value = "undefined";
    theForm.p_MixColumns.value = "undefined";
  }
  else {
    theForm.MixColumns.value = byteArrayToHex(hykDataMixColumns);
    theForm.p_MixColumns.value = hykByteArrayToBinary(hykParityMixColumns);
  }
  
  theForm.AddRoundKey.value = byteArrayToHex(hykDataAddRoundKey);
  theForm.p_AddRoundKey.value = hykByteArrayToBinary(hykParityAddRoundKey);
  
  return;
}

function doDecryption_HYK() {
  var theForm = document.forms[0];
  var ptArray, ctArray, keyArray;
  var parityArray; var detectArray = []; var generatedParityArray;
  
  selectedRound = theForm.round.value;
  if (selectedRound == "" || selectedRound < 0 || selectedRound > Nr) {
    alert("you must specify a round# between 0 and " + Nr + "!");
    return;
  }
  
  keySizeInBits = theForm.keySize[theForm.keySize.selectedIndex].value;
  blockSizeInBits = theForm.blockSize[theForm.blockSize.selectedIndex].value;
  if (theForm.key.value.toLowerCase().indexOf("0x") == 0)
    theForm.key.value = theForm.key.value.substring(2);
  if (theForm.ciphertext.value.toLowerCase().indexOf("0x") == 0)
    theForm.ciphertext.value = theForm.ciphertext.value.substring(2);
  
  if (theForm.key.value.length*4 != keySizeInBits) {
    alert("For a " + keySizeInBits + " bit key, the hex string needs to be " +
          (keySizeInBits / 4) + " hex characters long.");
    if (theForm.key.select)
       theForm.key.select();
    return;
  }

  if (theForm.ciphertext.value.length*4 != blockSizeInBits) {
    alert("For a " + blockSizeInBits + " bit block, the hex ciphertext string needs to be " +
          (blockSizeInBits / 4) + " hex characters long.");
    if (theForm.ciphertext.select)
       theForm.ciphertext.select();
    return;
  }
     
  ctArray = hexToByteArray(theForm.ciphertext.value);
  keyArray = hexToByteArray(theForm.key.value);
  theForm.plaintext.value = 
     byteArrayToHex(rijndaelDecrypt(ctArray, keyArray, "ECB"));
 
  //print the output for intermediate round.
  
  if (selectedRound == 0) {
    theForm.SubBytes.value = "undefined";
    theForm.p_SubBytes.value = "undefined";
  }
  else {  
    theForm.SubBytes.value = byteArrayToHex(hykDataSubBytes);
    theForm.p_SubBytes.value = hykByteArrayToBinary(hykParitySubBytes);
  }
  
  if (selectedRound == 0) {
    theForm.ShiftRows.value = "undefined";
    theForm.p_ShiftRows.value = "undefined";
  }
  else {
    theForm.ShiftRows.value = byteArrayToHex(hykDataShiftRows);
    theForm.p_ShiftRows.value = hykByteArrayToBinary(hykParityShiftRows);
  }
  
  if (selectedRound == 0) {
    theForm.MixColumns.value = "undefined";
    theForm.p_MixColumns.value = "undefined";
  }
  else if (selectedRound == Nr) {
    theForm.MixColumns.value = "undefined";
    theForm.p_MixColumns.value = "undefined";
  }
  else {
    theForm.MixColumns.value = byteArrayToHex(hykDataMixColumns);
    theForm.p_MixColumns.value = hykByteArrayToBinary(hykParityMixColumns);
  }
  
  theForm.AddRoundKey.value = byteArrayToHex(hykDataAddRoundKey);
  theForm.p_AddRoundKey.value = hykByteArrayToBinary(hykParityAddRoundKey);
  
  return;
}
/////////

function injectFault(index) {
  var theForm = document.forms[0];
  var i; var transform;
  injectRound = theForm.round.value;
  injectIndex = index;
    
  switch (index) {
    case 0: middleBlock = hexToByteArray(theForm.SubBytes.value);
    	    middleParity = hykBinaryToByteArray(theForm.p_SubBytes.value);
    	    transform = "SubBytes";
    	    break;
    case 1: middleBlock = hexToByteArray(theForm.ShiftRows.value);
    	    middleParity = hykBinaryToByteArray(theForm.p_ShiftRows.value);
    	    transform = "ShiftRows";
    	    break;
    case 2: middleBlock = hexToByteArray(theForm.MixColumns.value);
    	    middleParity = hykBinaryToByteArray(theForm.p_MixColumns.value);
    	    transform = "MixColumns";
    	    break;
    case 3: middleBlock = hexToByteArray(theForm.AddRoundKey.value);
    	    middleParity = hykBinaryToByteArray(theForm.p_AddRoundKey.value);
    	    transform = "AddRoundKey";
    	    break;
  }
  
  faultInjected = true; alert("Fault Injected at "+transform+" of round "+injectRound);
}

function showFaultDetectionForEncryption() {
  var theForm = document.forms[0];
  var ptArray, ctArray, keyArray;
  var parityArray; var detectArray = []; var generatedParityArray;var xixi;
  
  keySizeInBits = theForm.keySize[theForm.keySize.selectedIndex].value;
  blockSizeInBits = theForm.blockSize[theForm.blockSize.selectedIndex].value;
  
  if (theForm.key.value.length*4 != keySizeInBits) {
    alert("For a " + keySizeInBits + " bit key, the hex string needs to be " +
          (keySizeInBits / 4) + " hex characters long.");
    if (theForm.key.select)
       theForm.key.select();
    return;
  }
  if (theForm.plaintext.value.length*4 != blockSizeInBits) {
    alert("For a " + blockSizeInBits + " bit block, the hex plaintext string needs to be " +
          (blockSizeInBits / 4) + " hex characters long.");
    if (theForm.plaintext.select)
       theForm.plaintext.select();
    return;
  }
  keyArray = hexToByteArray(theForm.key.value);
  ptArray = hexToByteArray(theForm.plaintext.value);
  
  
  if (!faultInjected) {
    alert("Please inject fault! Press the inject fault button.");
    return;
  }
  
  selectedRound = theForm.round.value;
  
  if (faultInjected) {
    ctArray = encryptMiddle(middleBlock, keyArray);
    
    theForm.output.value = byteArrayToHex(ctArray);
      
    parityArray = unpackBytes(parity);
    
  theForm.parity.value = hykByteArrayToBinary(parityArray);
  generatedParityArray = generateParityArray(ctArray);
  for (var i=0; i<parityArray.length; i++) {
    detectArray[i] = parityArray[i] ^ generatedParityArray[i];
  }
  if (isEqual(parityArray, generatedParityArray)) {
    theForm.detected2.value = "No";
  }
  else {
    theForm.detected2.value = "Yes";
  }
  
  theForm.remainder.value = hykByteArrayToBinary(detectArray);
  
  generatedParityArray = generateParityArray(ctArray);
  
  if (isEqual(parityArray, generatedParityArray)) {
    theForm.detected2.value = "No";
  }
  else {
    theForm.detected2.value = "Yes";
  }
  
    //if (theForm.checkEDC.checked) {
    if (true) {
      //print the output for intermediate round with EDC.
      selectedRound = theForm.round.value;
  if (selectedRound == "" || selectedRound < 0 || selectedRound > Nr) {
    alert("you must specify a round# between 0 and " + Nr + "!");
    return;
  }
  
  
  if (selectedRound == 0) {
    theForm.SubBytes.value = "undefined";
    theForm.p_SubBytes.value = "undefined";
  }
  else {
    theForm.SubBytes.value = byteArrayToHex(hykDataSubBytes);
    theForm.p_SubBytes.value = hykByteArrayToBinary(hykParitySubBytes);
  }
  
  if (selectedRound == 0) {
    theForm.ShiftRows.value = "undefined";
    theForm.p_ShiftRows.value = "undefined";
  }
  else {
    theForm.ShiftRows.value = byteArrayToHex(hykDataShiftRows);
    theForm.p_ShiftRows.value = hykByteArrayToBinary(hykParityShiftRows);
  }
  
  if (selectedRound == 0) {
    theForm.MixColumns.value = "undefined";
    theForm.p_MixColumns.value = "undefined";
  }
  else if (selectedRound == Nr) {
    theForm.MixColumns.value = "undefined";
    theForm.p_MixColumns.value = "undefined";
  }
  else {
    theForm.MixColumns.value = byteArrayToHex(hykDataMixColumns);
    theForm.p_MixColumns.value = hykByteArrayToBinary(hykParityMixColumns);
  }
  
  theForm.AddRoundKey.value = byteArrayToHex(hykDataAddRoundKey);
  theForm.p_AddRoundKey.value = hykByteArrayToBinary(hykParityAddRoundKey);
  
  ///////////consider several exceptions
  if (parseInt(selectedRound, 16) < parseInt(injectRound, 16) ) {
    theForm.SubBytes.value = "undefined";
    theForm.p_SubBytes.value = "undefined";
    theForm.ShiftRows.value = "undefined";
    theForm.p_ShiftRows.value = "undefined";
    theForm.MixColumns.value = "undefined";
    theForm.p_MixColumns.value = "undefined";
    theForm.AddRoundKey.value = "undefined";
    theForm.p_AddRoundKey.value = "undefined";
  }
  else if (selectedRound == injectRound) {
    switch (injectIndex) {    	
   	case 3:  theForm.AddRoundKey.value = byteArrayToHex(middleBlock);
   		 theForm.p_AddRoundKey.value = hykByteArrayToBinary(middleParity);
   		 theForm.MixColumns.value = "undefined";
  		 theForm.p_MixColumns.value = "undefined";
 	case 2:  theForm.MixColumns.value = byteArrayToHex(middleBlock);
  		 theForm.p_MixColumns.value = hykByteArrayToBinary(middleParity);
  		 theForm.ShiftRows.value = "undefined";
  		 theForm.p_ShiftRows.value = "undefined";
  	case 1:  theForm.ShiftRows.value = byteArrayToHex(middleBlock);
  		 theForm.p_ShiftRows.value = hykByteArrayToBinary(middleParity);
  		 theForm.SubBytes.value = "undefined";
   		 theForm.p_SubBytes.value = "undefined";
   		 break;
   	case 0:  theForm.SubBytes.value = byteArrayToHex(middleBlock);
  		 theForm.p_SubBytes.value = hykByteArrayToBinary(middleParity);
    }
  }
  if (selectedRound == Nr) {
    theForm.MixColumns.value = "undefined";
    theForm.p_MixColumns.value = "undefined";
  }
    }
  }
  
  xixi = rijndaelEncrypt(ptArray, keyArray, "ECB");
  
  //if (isEqual (rijndaelEncrypt(ptArray, keyArray, "ECB"), ctArray)){
  if (isEqual (xixi, ctArray) ) {
    theForm.detected.value = "No";
  }
  else {
    theForm.detected.value = "Yes";
  }
}

function showFaultDetectionForDecryption() {
  var theForm = document.forms[0];
  var ptArray, ctArray, keyArray;
  var parityArray; var detectArray = []; var generatedParityArray;var xixi;
  
  keySizeInBits = theForm.keySize[theForm.keySize.selectedIndex].value;
  blockSizeInBits = theForm.blockSize[theForm.blockSize.selectedIndex].value;
  
  if (theForm.key.value.length*4 != keySizeInBits) {
    alert("For a " + keySizeInBits + " bit key, the hex string needs to be " +
          (keySizeInBits / 4) + " hex characters long.");
    if (theForm.key.select)
       theForm.key.select();
    return;
  }
  if (theForm.ciphertext.value.length*4 != blockSizeInBits) {
    alert("For a " + blockSizeInBits + " bit block, the hex ciphertext string needs to be " +
          (blockSizeInBits / 4) + " hex characters long.");
    if (theForm.ciphertext.select)
       theForm.ciphertext.select();
    return;
  }
  keyArray = hexToByteArray(theForm.key.value);
  ctArray = hexToByteArray(theForm.ciphertext.value);
  
  if (!faultInjected) {
    alert("Please inject fault! Press the inject fault button.");
    return;
  }
  
  selectedRound = theForm.round.value;  
  if (faultInjected) {
    ptArray = decryptMiddle(middleBlock, keyArray);
    
    theForm.output.value = byteArrayToHex(ptArray);
      
    parityArray = unpackBytes(parity);
    
  theForm.parity.value = hykByteArrayToBinary(parityArray);
  generatedParityArray = generateParityArray(ptArray);
  for (var i=0; i<parityArray.length; i++) {
    detectArray[i] = parityArray[i] ^ generatedParityArray[i];
  }
  if (isEqual(parityArray, generatedParityArray)) {
    theForm.detected2.value = "No";
  }
  else {
    theForm.detected2.value = "Yes";
  }
  
  theForm.remainder.value = hykByteArrayToBinary(detectArray);
  
  generatedParityArray = generateParityArray(ptArray);
  
  if (isEqual(parityArray, generatedParityArray)) {
    theForm.detected2.value = "No";
  }
  else {
    theForm.detected2.value = "Yes";
  }
  
    //if (theForm.checkEDC.checked) {
    if (true) {
      //print the output for intermediate round with EDC.
      selectedRound = theForm.round.value;
  if (selectedRound == "" || selectedRound < 0 || selectedRound > Nr) {
    alert("you must specify a round# between 0 and " + Nr + "!");
    return;
  }
      //print the output for intermediate round.
  
  if (selectedRound == 0) {
    theForm.SubBytes.value = "undefined";
    theForm.p_SubBytes.value = "undefined";
  }
  else {  
    theForm.SubBytes.value = byteArrayToHex(hykDataSubBytes);
    theForm.p_SubBytes.value = hykByteArrayToBinary(hykParitySubBytes);
  }
  
  if (selectedRound == 0) {
    theForm.ShiftRows.value = "undefined";
    theForm.p_ShiftRows.value = "undefined";
  }
  else {
    theForm.ShiftRows.value = byteArrayToHex(hykDataShiftRows);
    theForm.p_ShiftRows.value = hykByteArrayToBinary(hykParityShiftRows);
  }
  
  if (selectedRound == 0) {
    theForm.MixColumns.value = "undefined";
    theForm.p_MixColumns.value = "undefined";
  }
  else if (selectedRound == Nr) {
    theForm.MixColumns.value = "undefined";
    theForm.p_MixColumns.value = "undefined";
  }
  else {
    theForm.MixColumns.value = byteArrayToHex(hykDataMixColumns);
    theForm.p_MixColumns.value = hykByteArrayToBinary(hykParityMixColumns);
  }
  
  theForm.AddRoundKey.value = byteArrayToHex(hykDataAddRoundKey);
  theForm.p_AddRoundKey.value = hykByteArrayToBinary(hykParityAddRoundKey);
  
  ///////////consider several exceptions
  if (parseInt(selectedRound, 16) > parseInt(injectRound, 16)) {
    theForm.SubBytes.value = "undefined";
    theForm.p_SubBytes.value = "undefined";
    theForm.ShiftRows.value = "undefined";
    theForm.p_ShiftRows.value = "undefined";
    theForm.MixColumns.value = "undefined";
    theForm.p_MixColumns.value = "undefined";
    theForm.AddRoundKey.value = "undefined";
    theForm.p_AddRoundKey.value = "undefined";
  }
  else if (selectedRound == injectRound) {
    switch (injectIndex) {    	   	
 	case 0:  theForm.SubBytes.value = byteArrayToHex(middleBlock);
   		 theForm.p_SubBytes.value = hykByteArrayToBinary(middleParity);
   		 theForm.ShiftRows.value = "undefined";
  		 theForm.p_ShiftRows.value = "undefined";
  	case 1:  theForm.ShiftRows.value = byteArrayToHex(middleBlock);
  		 theForm.p_ShiftRows.value = hykByteArrayToBinary(middleParity);
  		 theForm.MixColumns.value = "undefined";
  		 theForm.p_MixColumns.value = "undefined";
  	case 2:  theForm.MixColumns.value = byteArrayToHex(middleBlock);
  		 theForm.p_MixColumns.value = hykByteArrayToBinary(middleParity);
  		 theForm.AddRoundKey.value = "undefined";
   		 theForm.p_AddRoundKey.value = "undefined";
   		 break;
    	case 3:  theForm.AddRoundKey.value = byteArrayToHex(middleBlock);
  		 theForm.p_AddRoundKey.value = hykByteArrayToBinary(middleParity);
    }
  }
  if (selectedRound == Nr) {
    theForm.MixColumns.value = "undefined";
    theForm.p_MixColumns.value = "undefined";
  }
    }
  }
  
  xixi = rijndaelDecrypt(ctArray, keyArray, "ECB");
  
  //if (isEqual (rijndaelEncrypt(ptArray, keyArray, "ECB"), ptArray)){
  if (isEqual (xixi, ptArray) ) {
    theForm.detected.value = "No";
  }
  else {
    theForm.detected.value = "Yes";
  }
}

//////////////////////

function detectFaultOfEncryption_bak() {
  var theForm = document.forms[0];
  var ptArray, ctArray, keyArray;
  var parityArray; var detectArray = []; var generatedParityArray;
  
  selectedRound = theForm.round.value;
  if (selectedRound == "" || selectedRound < 0 || selectedRound > Nr) {
    alert("you must specify a round# between 0 and " + Nr + "!");
    return;
  }
  
  keySizeInBits = theForm.keySize[theForm.keySize.selectedIndex].value;
  blockSizeInBits = theForm.blockSize[theForm.blockSize.selectedIndex].value;
  if (theForm.key.value.toLowerCase().indexOf("0x") == 0)
    theForm.key.value = theForm.key.value.substring(2);
  if (theForm.plaintext.value.toLowerCase().indexOf("0x") == 0)
    theForm.plaintext.value = theForm.plaintext.value.substring(2);
  if (theForm.ciphertext.value.toLowerCase().indexOf("0x") == 0)
    theForm.ciphertext.value = theForm.ciphertext.value.substring(2);
  
  if (theForm.key.value.length*4 != keySizeInBits) {
    alert("For a " + keySizeInBits + " bit key, the hex string needs to be " +
          (keySizeInBits / 4) + " hex characters long.");
    if (theForm.key.select)
       theForm.key.select();
    return;
  }

  if (theForm.plaintext.value.length*4 != blockSizeInBits) {
    alert("For a " + blockSizeInBits + " bit block, the hex plaintext string needs to be " +
          (blockSizeInBits / 4) + " hex characters long.");
    if (theForm.plaintext.select)
       theForm.plaintext.select();
    return;
  }
  
  if (theForm.ciphertext.value.length*4 != blockSizeInBits) {
    alert("For a " + blockSizeInBits + " bit block, the hex ciphertext string needs to be " +
          (blockSizeInBits / 4) + " hex characters long.");
    if (theForm.ciphertext.select)
       theForm.ciphertext.select();
    return;
  }
     
  ptArray = hexToByteArray(theForm.plaintext.value);
  ctArray = hexToByteArray(theForm.ciphertext.value);
  keyArray = hexToByteArray(theForm.key.value);
  
  if (isEqual (rijndaelEncrypt(ptArray, keyArray, "ECB"), ctArray)){
    theForm.detected.value = "No";
  }
  else {
    theForm.detected.value = "Yes";
  }
  
  parityArray = unpackBytes(parity);
    
  theForm.parity.value = hykByteArrayToBinary(parityArray);
  generatedParityArray = generateParityArray(ctArray);
  for (var i=0; i<parityArray.length; i++) {
    detectArray[i] = parityArray[i] ^ generatedParityArray[i];
  }
  if (isEqual(parityArray, generatedParityArray)) {
    theForm.detected2.value = "No";
  }
  else {
    theForm.detected2.value = "Yes";
  }
  
  theForm.remainder.value = hykByteArrayToBinary(detectArray);
  
  //print the output for intermediate round.
  
  if (selectedRound == 0) {
    theForm.SubBytes.value = "undefined";
    theForm.p_SubBytes.value = "undefined";
  }
  else {  
    theForm.SubBytes.value = byteArrayToHex(hykDataSubBytes);
    theForm.p_SubBytes.value = hykByteArrayToBinary(hykParitySubBytes);
  }
  
  if (selectedRound == 0) {
    theForm.ShiftRows.value = "undefined";
    theForm.p_ShiftRows.value = "undefined";
  }
  else {
    theForm.ShiftRows.value = byteArrayToHex(hykDataShiftRows);
    theForm.p_ShiftRows.value = hykByteArrayToBinary(hykParityShiftRows);
  }
  
  if (selectedRound == 0) {
    theForm.MixColumns.value = "undefined";
    theForm.p_MixColumns.value = "undefined";
  }
  else if (selectedRound == Nr) {
    theForm.MixColumns.value = "undefined";
    theForm.p_MixColumns.value = "undefined";
  }
  else {
    theForm.MixColumns.value = byteArrayToHex(hykDataMixColumns);
    theForm.p_MixColumns.value = hykByteArrayToBinary(hykParityMixColumns);
  }
  
  theForm.AddRoundKey.value = byteArrayToHex(hykDataAddRoundKey);
  theForm.p_AddRoundKey.value = hykByteArrayToBinary(hykParityAddRoundKey);
  
  return;
}

function detectFaultOfDecryption() {
  var theForm = document.forms[0];
  var ptArray, ctArray, keyArray;
  var parityArray; var detectArray = []; var generatedParityArray;
  
  
  selectedRound = theForm.round.value;
  if (selectedRound == "" || selectedRound < 0 || selectedRound > Nr) {
    alert("you must specify a round# between 0 and " + Nr + "!");
    return;
  }
  
  keySizeInBits = theForm.keySize[theForm.keySize.selectedIndex].value;
  blockSizeInBits = theForm.blockSize[theForm.blockSize.selectedIndex].value;
  if (theForm.key.value.toLowerCase().indexOf("0x") == 0)
    theForm.key.value = theForm.key.value.substring(2);
  if (theForm.plaintext.value.toLowerCase().indexOf("0x") == 0)
    theForm.plaintext.value = theForm.plaintext.value.substring(2);
  if (theForm.ciphertext.value.toLowerCase().indexOf("0x") == 0)
    theForm.ciphertext.value = theForm.ciphertext.value.substring(2);
  
  if (theForm.key.value.length*4 != keySizeInBits) {
    alert("For a " + keySizeInBits + " bit key, the hex string needs to be " +
          (keySizeInBits / 4) + " hex characters long.");
    if (theForm.key.select)
       theForm.key.select();
    return;
  }

  if (theForm.plaintext.value.length*4 != blockSizeInBits) {
    alert("For a " + blockSizeInBits + " bit block, the hex plaintext string needs to be " +
          (blockSizeInBits / 4) + " hex characters long.");
    if (theForm.plaintext.select)
       theForm.plaintext.select();
    return;
  }
  
  if (theForm.ciphertext.value.length*4 != blockSizeInBits) {
    alert("For a " + blockSizeInBits + " bit block, the hex ciphertext string needs to be " +
          (blockSizeInBits / 4) + " hex characters long.");
    if (theForm.ciphertext.select)
       theForm.ciphertext.select();
    return;
  }
     
  ptArray = hexToByteArray(theForm.plaintext.value);
  ctArray = hexToByteArray(theForm.ciphertext.value);
  keyArray = hexToByteArray(theForm.key.value);
  
  if (isEqual (rijndaelDecrypt(ctArray, keyArray, "ECB"), ptArray)){
    theForm.detected.value = "No";
  }
  else {
    theForm.detected.value = "Yes";
  }
  
  parityArray = unpackBytes(parity);
  
  theForm.parity.value = hykByteArrayToBinary(parityArray);
  generatedParityArray = generateParityArray(ptArray);
  for (var i=0; i<parityArray.length; i++) {
    detectArray[i] = parityArray[i] ^ generatedParityArray[i];
  }
  if (isEqual(parityArray, generatedParityArray)) {
    theForm.detected2.value = "No";
  }
  else {
    theForm.detected2.value = "Yes";
  }
  
  theForm.remainder.value = hykByteArrayToBinary(detectArray);
  
  //print the output for intermediate round.
  if (selectedRound == 0) {
    theForm.SubBytes.value = "undefined";
    theForm.p_SubBytes.value = "undefined";
  }
  else {  
    theForm.SubBytes.value = byteArrayToHex(hykDataSubBytes);
    theForm.p_SubBytes.value = hykByteArrayToBinary(hykParitySubBytes);
  }
  
  if (selectedRound == 0) {
    theForm.ShiftRows.value = "undefined";
    theForm.p_ShiftRows.value = "undefined";
  }
  else {
    theForm.ShiftRows.value = byteArrayToHex(hykDataShiftRows);
    theForm.p_ShiftRows.value = hykByteArrayToBinary(hykParityShiftRows);
  }
  
  if (selectedRound == 0) {
    theForm.MixColumns.value = "undefined";
    theForm.p_MixColumns.value = "undefined";
  }
  else if (selectedRound == Nr) {
    theForm.MixColumns.value = "undefined";
    theForm.p_MixColumns.value = "undefined";
  }
  else {
    theForm.MixColumns.value = byteArrayToHex(hykDataMixColumns);
    theForm.p_MixColumns.value = hykByteArrayToBinary(hykParityMixColumns);
  }
  
  theForm.AddRoundKey.value = byteArrayToHex(hykDataAddRoundKey);
  theForm.p_AddRoundKey.value = hykByteArrayToBinary(hykParityAddRoundKey);
  
  return;
}

// --></SCRIPT>

<STYLE type=text/css>H2 {
	TEXT-ALIGN: center
}
P {
	MARGIN: 20px
}
</STYLE>

<META content="MSHTML 5.50.4134.600" name=GENERATOR></HEAD>
<BODY>
<H2>Fault Detection in AES Encoder and Decoder</H2>


<FORM onsubmit="return false">
<TABLE>
  <TBODY>
  <TR>
    <TD><B>Key size in bits: </B></TD>
    <TD><SELECT name=keySize> <OPTION value=128 selected>128</OPTION> 
        <OPTION value=192>192</OPTION> <OPTION value=256>256</OPTION></SELECT> 
        &nbsp; &nbsp;  &nbsp; &nbsp;
  </TD> 
  
    <TD><B>Block size in bits: </B></TD>
    <TD><SELECT name=blockSize> <OPTION value=128 selected>128</OPTION> 
        <OPTION value=192>192</OPTION> <OPTION value=256>256</OPTION></SELECT> 
  </TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TD><B>Key in hex: </B></TD>
    <TD><INPUT size=46 name=key value="bdcd5efadc6028ced26689cc72aa928b"></TD></TR>
  <TR>
    <TD><B><font color="#6666FF">Plaintext in hex: </font></B></TD>
    <TD><INPUT size=46 name=plaintext value="48de8f32cc374bf284e6334418bb3c6e"></TD></TR>
  <TR>
    <TD><B><font color="#FF6666">Ciphertext in hex: </font></B></TD>
    <TD><INPUT size=46 name=ciphertext></TD></TR>
  <TR>
    <TD>&nbsp; </TD>
    <TD><INPUT onclick=doEncryption_HYK() type=button value=Encrypt> &nbsp; &nbsp; 
<INPUT onclick=doDecryption_HYK() type=button value=Decrypt> &nbsp; &nbsp; 
<INPUT type=reset value=Reset> &nbsp; </TD></TR></TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>
    <TD><B>Round #: </B></TD>
    <TD><INPUT size=16 name=round value="3"></TD>
        </TR>
  <TR>
    <TD>&nbsp; </TD>
    <TD><B>Data Block</B></TD>
    <TD><B>Parity Block</B></TD></TR>
  <TR>
    <TD><B>SubBytes: </B></TD>
    <TD><INPUT size=40 name=SubBytes></TD>
    <TD><INPUT size=18 name=p_SubBytes></TD>
    <TD><INPUT onClick=injectFault(0) type=button value="Inject Fault"> </TD></TR>
  <TR>
    <TD><B>ShiftRows: </B></TD>
    <TD><INPUT size=40 name=ShiftRows></TD>
    <TD><INPUT size=18 name=p_ShiftRows></TD>
    <TD><INPUT onClick=injectFault(1) type=button value="Inject Fault"> </TD></TR>
  <TR>
    <TD><B>MixColumns: </B></TD>
    <TD><INPUT size=40 name=MixColumns></TD>
    <TD><INPUT size=18 name=p_MixColumns></TD>
    <TD><INPUT onClick=injectFault(2) type=button value="Inject Fault"> </TD></TR>
  <TR>
    <TD><B>AddRoundKey: </B></TD>
    <TD><INPUT size=40 name=AddRoundKey></TD>
    <TD><INPUT size=18 name=p_AddRoundKey></TD>
    <TD><INPUT onClick=injectFault(3) type=button value="Inject Fault"> </TD></TR>
            </TBODY></TABLE>
<TABLE>
  <TBODY>
  <TR>    
    <TD><INPUT onClick=showFaultDetectionForEncryption() type=button value="Show Fault Detection for  Encryption"></TD>
    <TD><INPUT onClick=showFaultDetectionForDecryption() type=button value="Show Fault Detection for Decryption"> </TD></TR>
  <TR>
    <TD><B>Fault detected by hardware redundancy? </B></TD>
    <TD><INPUT size=46 name=detected></TD></TR>
  <TR>
    <TD><B>output of AEC coder/decoder with EDC: </B></TD>
    <TD><INPUT size=46 name=output></TD></TR>
  <TR>
    <TD><B>Parity matrix of EDC: </B></TD>
    <TD><INPUT size=46 name=parity></TD></TR>
  <TR>
    <TD><B>Error indicator matrix of EDC: </B></TD>
    <TD><INPUT size=46 name=remainder></TD></TR>
  <TR>
    <TD><B>Fault detected by EDC? </B></TD>
    <TD><INPUT size=46 name=detected2></TD></TR>    
    </TBODY></TABLE>
            </FORM></P>
<P><EM><font color="red">Notice</font></EM>: the input should be in hexadecimal format. e.g. 
<CODE>C34C052CC0DA8D73451AFE5F03BE297F</CODE>. 
you can change the key size and block size from the drop-down box. 
<p>the round # is defined with regard to the encryption process. so  
you should notice that for decryption the round 0 is the last round performed.
<H3><a href="help.htm">Instructions</a> </H3>
<HR>
</BODY></HTML>
