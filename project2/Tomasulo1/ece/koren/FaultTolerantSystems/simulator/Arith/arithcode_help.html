<html>
<head>
  <title>Arithmetic Encoder/Decoder - Instructions</title>
      
  <meta http-equiv="content-type"
 content="text/html; charset=ISO-8859-1">
</head>
  <body>
 
<h1 align="center">Instructions &amp; Information about the Arithmetic Encoder/Decoder</h1>
 
<hr width="100%" size="2"> 
<h2>Arithmetic Codes</h2>

Data in arithmetic codes are preserved under a set of arithmetic operations. We say that an error code is preserved under an arithmetic operation * if for any two operands X and Y and the corresponding encoded entities X' and Y' there is an operation # for the operands satisfying X' # Y' = (X * Y)'. The results of the arithmetic operation # when applied to the encoded operands X' and Y' will yield the same result as encoding the outcome of applying the original operation * the original operands X and Y. <br>
Arithmetic codes can be sorted into non-separable arithmetic codes and separable arithmetic codes. The simplest non-separable codes is AN codes, and the simplest separable codes is residue codes.
AN codes are formed by multiplying the operands by a constant. 
Residue code are formed by attaching the operands with a separate check symbol, which is the residue of the operands divided by a constant.
<div align="left">
<h2>Help with the single word encoder and decoder</h2>
The single word encoder calculates the code words of AN codes and Residue codes. The user can make a choice of these two sorts of encoding method. The data words and encoding constants should be binary or hexadecimal numbers of at most 32 bits. The encoded word can be displayed by pushing the encode button. The decoder shows how bit-flip errors of the encoded word can or cannot be detected by comparing the remainder the expected remainder.
<br>
 
<h2>Help with the Addition of X and Y encoder and decoder<br>
</h2>
This encoder and decoder shows how a error that happens during the process of an adding operation can or cannot be detected. The data words and encoding constants should be binary or hexadecimal numbers of at most 32 bits. All the intermediate numbers are displayed as binary number or should be input as binary numbers. The user can push "calculate next bit" button to get the next bit of the partial sum from the least significant bit to the most significant bit. Errors can be injected by modifying the most significant bit of the carry-ins or by modifying a bit of the encoded words when the order of the most significant bit of the partial sum is less than the order of the modified bit. If the user injected two errors, error cancellation may occur. Here are simple examples: <br><br>
AN codes: <br>
Input data words and encoding constant: <br>
&nbsp;&nbsp;&nbsp;&nbsp;Data Word X: 11011, Data Word Y: 1100, Encoding Constant: 11 <br>
&nbsp;&nbsp;&nbsp;&nbsp;Encoded Word X: 1010001, Encoded Word Y: 100100 <br>
Modify the 2nd-order bit of Encoded Word Y <br>
&nbsp;&nbsp;&nbsp;&nbsp;Encoded Word X: 1010001, Encoded Word Y: 100110 <br>
Push the "Calculate Next Bit" button for 4 times, <br>
&nbsp;&nbsp;&nbsp;&nbsp;Carry-in: 0000, Partial sum: 0111 <br>
Modify the MSB of the carry-in: <br>
&nbsp;&nbsp;&nbsp;&nbsp;Carry-in: 1000, Partial sum: 0111 <br>
Push "calculate next bit" button until we get the final sum (Encoded Word Z): <br>
&nbsp;&nbsp;&nbsp;&nbsp;Encoded Word Z: 10000111 <br>
Decode the final sum: <br>
&nbsp;&nbsp;&nbsp;&nbsp;Correct Word Z: &nbsp;&nbsp;100111, Correct Remainder: 0 <br>
&nbsp;&nbsp;&nbsp;&nbsp;Decoded Word Z: 101101, Remainder: 0 <br><br>
Residue codes: <br>
Input data words and encoding constant: <br>
&nbsp;&nbsp;&nbsp;&nbsp;Data Word X: 11011, Data Word Y: 1100, Encoding Constant: 3 <br>
&nbsp;&nbsp;&nbsp;&nbsp;Encoded Word X: 11011 00, Encoded Word Y: 1100 00 <br>
Modify the LSB bit of Encoded Word Y <br>
&nbsp;&nbsp;&nbsp;&nbsp;Encoded Word X: 11011 00, Encoded Word Y: 1101 00 <br>
Push the "Calculate Next Bit" button for 4 times, <br>
&nbsp;&nbsp;&nbsp;&nbsp;Carry-in: 1111, Partial sum: 1000 <br>
Modify the MSB of the carry-in: <br>
&nbsp;&nbsp;&nbsp;&nbsp;Carry-in: 0111, Partial sum: 1000 <br>
Push "calculate next bit" button until we get the final sum (Encoded Word Z): <br>
&nbsp;&nbsp;&nbsp;&nbsp;Encoded Word Z: 011000 00 <br>
Decode the final sum: <br>
&nbsp;&nbsp;&nbsp;&nbsp;Correct Word Z: &nbsp;&nbsp;100111, Correct Remainder: 00 <br>
&nbsp;&nbsp;&nbsp;&nbsp;Decoded Word Z: 011000, Remainder: 00 <br>



<h2>Help with the Multiplication of X and Y encoder and decoder<br>
</h2>
This encoder and decoder shows how a error that happens during the process of a multiplying operation can or cannot be detected. The data words and encoding constants should be binary or hexadecimal numbers of at most 32 bits. All the intermediate numbers are displayed as binary number or should be input as binary numbers. The user can push "calculate partial product" button to get the partial product in the text area. Errors can be injected by modifying one or more bits of the partial product. If the user injected two errors, error cancellation may occur. Here are simple examples, <br>
<br> 
AN codes: <br>
Input data words and encoding constant: <br>
&nbsp;&nbsp;&nbsp;&nbsp;Data Word X: 11011, Data Word Y: 1100, Encoding Constant: 11 <br>
&nbsp;&nbsp;&nbsp;&nbsp;Encoded Word X: 1010001, Encoded Word Y: 100100 <br>
Push the "Calculate Partial Product" button: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0000000 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      0000000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10</font><font color="#990000">1</font>0001<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0000000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0000000<br>
&nbsp;&nbsp;&nbsp;101000</font><font color="#990000">1</font>      <br>
Flip the two red bits: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0000000 <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;           0000000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10</font><font color="#990000">0</font>0001<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0000000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0000000<br>
&nbsp;&nbsp;&nbsp;101000</font><font color="#990000">0</font>      <br>
Calculate the final product (Encoded Word Z): <br>
&nbsp;&nbsp;&nbsp;&nbsp;Encoded Word Z: 101100000100 <br>
Decode the final product: <br>
&nbsp;&nbsp;&nbsp;&nbsp;Correct Word Z: &nbsp;&nbsp;101000100, Correct Remainder: 0 <br>
&nbsp;&nbsp;&nbsp;&nbsp;Decoded Word Z: 100111001, Remainder: 0 <br>

<br>
Residue Codes: <br>
Input data words and encoding constant: <br>
&nbsp;&nbsp;&nbsp;&nbsp;Data Word X: 11011, Data Word Y: 1100, Encoding Constant: 11 <br>
&nbsp;&nbsp;&nbsp;&nbsp;Encoded Word X: 11011 00, Encoded Word Y: 1100 00 <br>
Push the "Calculate Partial Product" button: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#990000">1</font>1011<br>
&nbsp;&nbsp;&nbsp;1101</font><font color="#990000">1</font><br>
Flip the two red bits: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#990000">0</font>1011<br>
&nbsp;&nbsp;&nbsp;1101</font><font color="#990000">0</font><br>
Calculate the final product (Encoded Word Z): <br>
&nbsp;&nbsp;&nbsp;&nbsp;Encoded Word Z: 11111100  00 <br>
Decode the final product: <br>
&nbsp;&nbsp;&nbsp;&nbsp;Correct Word Z: 101000100, Correct Remainder: 00 <br>
&nbsp;&nbsp;&nbsp;&nbsp;Decoded Word Z: 11111100, Remainder: 00 <br> 

<br>
<br>
</body>
</html>
