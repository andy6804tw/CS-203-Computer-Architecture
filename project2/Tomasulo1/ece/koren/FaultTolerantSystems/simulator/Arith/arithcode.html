<HTML>

<HEAD>

<TITLE>Arithmetic Code</TITLE>


<SCRIPT language="JavaScript">

var iteration=0;

function binNumber(value) {

  for (i=0;i<value.length;i++) {
    if ((parseFloat(value.substring(i,i+1)) != 1) && 
        (parseFloat(value.substring(i,i+1)) != 0)) {
      return false
    }
  }

return true

}

function hexNumber(value) {

  for (i=0; i<value.length; i++) {
  //alert(value.substring(i,i+1));
  //alert(parseInt(value.substring(i,i+1), 16));
    if ((parseInt(value.substring(i,i+1), 16) != 0) &&
        (parseInt(value.substring(i,i+1), 16) != 1) &&
        (parseInt(value.substring(i,i+1), 16) != 2) &&
        (parseInt(value.substring(i,i+1), 16) != 3) &&
        (parseInt(value.substring(i,i+1), 16) != 4) &&
        (parseInt(value.substring(i,i+1), 16) != 5) &&
        (parseInt(value.substring(i,i+1), 16) != 6) &&
        (parseInt(value.substring(i,i+1), 16) != 7) &&
        (parseInt(value.substring(i,i+1), 16) != 8) &&
        (parseInt(value.substring(i,i+1), 16) != 9) &&
        (parseInt(value.substring(i,i+1), 16) != 10) &&
        (parseInt(value.substring(i,i+1), 16) != 11) &&
        (parseInt(value.substring(i,i+1), 16) != 12) &&
        (parseInt(value.substring(i,i+1), 16) != 13) &&
        (parseInt(value.substring(i,i+1), 16) != 14) &&
        (parseInt(value.substring(i,i+1), 16) != 15)) {
         
      return false
    }
  }

  return true

}   

         
function dec2binString(d2b_word) {

  //alert(d2b_word);

  binString = "";
  
  if(d2b_word < 2) {
    return d2b_word
  }

  d2b_quotient = d2b_word;
  do {
    d2b_remainder = d2b_quotient % 2;
    d2b_quotient = Math.floor(d2b_quotient / 2);
    binString = d2b_remainder + binString;
  } while (d2b_quotient > 1)
  binString = d2b_quotient + binString;

  //alert(binString);

  return binString
}

function checkPartialProduct (strValue)
{
	for( var i=0; i<strValue.length; i++ )
	{
		if( strValue.charAt(i)>='0' && strValue.charAt(i)<='1' )
			continue;
		else if( strValue.charAt(i)=='\t' || strValue.charAt(i)==' ' )
			continue;
		else if( strValue.charAt(i)=='\n' || strValue.charAt(i)=='\r' )
			continue;
		else {
			alert("Invalid partial product: " + strValue.charAt(i));
                        return;
                }
	}
	
      return;

}

function readNumericValue( strValue, ith )
{

	var beg = 0;
	var strTmp;

	strTmp = strValue;
	for( i=0; i<ith; i++ )
	{
	    beg = strTmp.search("\r");
            while( beg==0 ) {
              strTmp = strTmp.slice(beg+1);
              beg = strTmp.search("\r");
            }
            if( beg==-1 )
		return -1;
		strTmp = strTmp.slice(beg+1);
	}

      //form.encodedWordZ.value = strTmp.search("\r");   
	
	numberRet = parseInt(strTmp, 2);
	if( isNaN(numberRet) )
		return -1;
	else
		return numberRet;
	
}

function resetSingle(form) {
  
  form.dataWord.value = "";
  form.constant.value = "";
  form.encodedWord.value = "";
  form.correctDecodedWord.value = "";
  form.decodedWord.value = "";
  form.correctRemainder.value = "";
  form.remainder.value = "";
  form.faultDetected.value = "";
  
}

function resetAdd(form) {

  iteration = 0;
  
  //form.dataWordX1.value = "";
  //form.dataWordY1.value = "";
  //form.constant1.value = "";
  form.encodedWordX1.value = "";
  form.encodedWordY1.value = "";
  form.carryIn.value = "";
  form.partialSum.value = "";
  form.encodedWordZ1.value = "";
  form.correctDecodedWordZ1.value = "";
  form.decodedWordZ1.value = "";
  form.correctRemainderZ1.value = "";
  form.remainderZ1.value = "";
  form.faultDetectedZ1.value = "";
  
}

function resetMul(form) {

  //form.dataWordX2.value = "";
  //form.dataWordY2.value = "";
  //form.constant2.value = "";
  form.encodedWordX2.value = "";
  form.encodedWordY2.value = "";
  form.partialProduct.value = "";
  form.encodedWordZ2.value = "";
  form.correctDecodedWordZ2.value = "";
  form.decodedWordZ2.value = "";
  form.correctRemainderZ2.value = "";
  form.remainderZ2.value = "";
  form.faultDetectedZ2.value = "";
  
}

function encodeAN(dataWord, constant, base) {

  dataWord = parseInt(dataWord.value, base);
  constant = parseInt(constant.value, base);
  
  encodedWord = dataWord * constant;

  if ( encodedWord  > Math.pow(2,31) ) {
    alert("Data word or encoding constant is too large");
    return
  }

  return dec2binString(encodedWord);

}


function encodeResidue(dataWord, constant, base) {

  encodedWord = parseInt(dataWord.value, base);
  cons = parseInt(constant.value, base);
  checkWord = encodedWord % cons;

  constantBinString = new String(dec2binString(cons));
  checkWordString = new String(dec2binString(checkWord));
  
  pad = "";
  padLength = constantBinString.length - checkWordString.length;
  for(i=0; i<padLength; i++) pad += "0";
  
  encodedWordString = dec2binString(encodedWord) + "  " + pad + dec2binString(checkWord);
  
  return encodedWordString;
  
}

function encode(form) {

  if (form.dataWord.value == "") {
    alert("Please input a data word");
    return
  }

  if (form.constant.value == "") {
    alert("Please input an encoding constant");
    return
  }

  if (form.base[0].checked && !binNumber(form.dataWord.value)) {
    alert("Data word must be in binary form");
    return
  }

  if (form.base[0].checked && !binNumber(form.constant.value)) {
    alert("Constant word must be in binary form");
    return
  }

  if (form.base[1].checked && !hexNumber(form.dataWord.value)) {
    alert("Data word must be in hexdecimal form");
    return
  }

  if (form.base[1].checked && !hexNumber(form.constant.value)) {
    alert("Constant word must be in hexdecimal form");
    return
  }
  
  if(form.base[0].checked) base = 2;
  else base = 16;

  if(form.type[0].checked) {
    encodedWord = encodeAN(form.dataWord, form.constant, base);
  }
  
  if(form.type[1].checked) {
    encodedWord = encodeResidue(form.dataWord, form.constant, base);
  }

  form.encodedWord.value = encodedWord;
  //form.constant2.value = form.constant.value;

  return
}


function decodeAN(form) {

  if(form.base[0].checked) base = 2;
  else base = 16;
  
  dataWord = parseInt(form.dataWord.value, base);
  codeWord = parseInt(form.encodedWord.value, 2);
  constant = parseInt(form.constant.value, base);

  if ( codeWord  > Math.pow(2,31) ) {
    alert("Code word is too large");
    return
  }

  if (constant >= codeWord) {
    alert("Decoding constant is too large");
    return
  }
  
  form.correctDecodedWord.value = dec2binString(dataWord);
  form.correctRemainder.value = "0";

  decodedWord = Math.floor(codeWord / constant);
  remainder = codeWord % constant;
  form.decodedWord.value = dec2binString(decodedWord);
  //alert(remainder);
  form.remainder.value = dec2binString(remainder);

  if(remainder == 0) form.faultDetected.value = "No";
  else form.faultDetected.value = "Yes";

  return

}


function decodeResidue(form) {

  //alert("hello");
  if(form.base[0].checked) base = 2;
  else base = 16;

  dataWord = parseInt(form.dataWord.value, base);
  dataBinString = new String(dec2binString(dataWord));
  dataWordLength = dataBinString.length;
  constant = parseInt(form.constant.value, base);
  consBinString = new String(dec2binString(constant));
  constantLength = consBinString.length;
  encodedWordLength = form.encodedWord.value.length;
  
  decodedWord = parseInt(form.encodedWord.value.substring(0, dataWordLength), 2);
  

  if ( decodedWord  > Math.pow(2,31) ) {
    alert("Code word is too large");
    return
  }

  correctRemainder = dataWord % constant;
  
  remainder = decodedWord % constant;

  checkWordString = form.encodedWord.value.substring(encodedWordLength-constantLength, 
                                                     encodedWordLength);
  checkWord = parseInt(checkWordString, 2);
  
  remainderString = new String( dec2binString(remainder) );
  pad = "";
  padLength = constantLength - remainderString.length;
  for(i=0; i<padLength; i++) pad += "0";
  
  form.correctDecodedWord.value = dataBinString;
  form.correctRemainder.value = checkWordString;    
  
  form.decodedWord.value = dec2binString(decodedWord);
  form.remainder.value = pad + remainderString;

  if(remainder == checkWord) form.faultDetected.value = "No";
  else form.faultDetected.value = "Yes";

  return
}


function decode(form) {

  if (form.constant.value == "") {
    alert("Please input an encoding constant");
    return
  }

  if(form.type[0].checked) {
    decodeAN(form);
    return
  }
  
  if(form.type[1].checked) {
    decodeResidue(form);
    return
  }

  return
}

function unitAdder(valueX, valueY, carryIn) {
  
  returnSumCarryin = new Array(2);
  
  sum = valueX + valueY + carryIn;
  
  switch(sum) {
    case 3:  
      returnSumCarryin[0] = 1;
      returnSumCarryin[1] = 1;
      break;
    case 2:
      returnSumCarryin[0] = 1;
      returnSumCarryin[1] = 0;
      break;
    case 1:
      returnSumCarryin[0] = 0;
      returnSumCarryin[1] = 1;
      break;    
    case 0:
      returnSumCarryin[0] = 0;
      returnSumCarryin[1] = 0;
  }
  
  return returnSumCarryin;
}


function encodeSumPartial(form) {

  if (form.dataWordX1.value == "") {
    alert("Please input data word X");
    return
  }

  if (form.dataWordY1.value == "") {
    alert("Please input data word Y");
    return
  }

  if (form.constant1.value == "") {
    alert("Please input an encoding constant");
    return
  }

  if(form.base1[0].checked) base = 2;
  else base = 16;
  
  if (form.base1[0].checked && !binNumber(form.dataWordX1.value)) {
    alert("Data word X must be in binary form");
    return
  }

  if (form.base1[0].checked && !binNumber(form.dataWordY1.value)) {
    alert("Data word Y must be in binary form");
    return
  }

  if (form.base1[0].checked && !binNumber(form.constant1.value)) {
    alert("Constant word must be in binary form");
    return
  }

  if (form.base1[1].checked && !hexNumber(form.dataWordX1.value)) {
    alert("Data word X must be in hexdecimal form");
    return
  }

  if (form.base1[1].checked && !hexNumber(form.dataWordY1.value)) {
    alert("Data word Y must be in hexdecimal form");
    return
  }

  if (form.base1[1].checked && !hexNumber(form.constant1.value)) {
    alert("Constant word must be in hexdecimal form");
    return
  }

  if(form.type1[0].checked) {
     if(form.encodedWordX1.value == "" && 
       form.encodedWordY1.value == ""){ 
      encodedWordX = encodeAN(form.dataWordX1, form.constant1, base);
      encodedWordY = encodeAN(form.dataWordY1, form.constant1, base);
      form.encodedWordX1.value = encodedWordX;
      form.encodedWordY1.value = encodedWordY;
      return;
    }
    
    valueX = parseInt(form.encodedWordX1.value, 2);
    valueY = parseInt(form.encodedWordY1.value, 2);
    lengthX = form.encodedWordX1.value.length;
    lengthY = form.encodedWordY1.value.length;
  }
  else {
    if(form.encodedWordX1.value == "" && 
       form.encodedWordY1.value == ""){
      encodedWordX = encodeResidue(form.dataWordX1, form.constant1, base);
      encodedWordY = encodeResidue(form.dataWordY1, form.constant1, base);
      form.encodedWordX1.value = encodedWordX;
      form.encodedWordY1.value = encodedWordY;
      return;
    }
  
    //valueX = parseInt(form.dataWordX1.value, base);
    //valueY = parseInt(form.dataWordY1.value, base);
    wholeWordLengthX1 = form.encodedWordX1.value.length;
    encodedWordLengthX1 = 0;
    for(i=0; i<wholeWordLengthX1; i++) {
      if(form.encodedWordX1.value.substring(i, i+1) != " ") encodedWordLengthX1++;
      else break;
    }
    dataWordStringX = form.encodedWordX1.value.substring(0, encodedWordLengthX1);
    
    wholeWordLengthY1 = form.encodedWordY1.value.length;
    encodedWordLengthY1 = 0;
    for(i=0; i<wholeWordLengthY1; i++) {
      if(form.encodedWordY1.value.substring(i, i+1) != " ") encodedWordLengthY1++;
      else break;
    }
    dataWordStringY = form.encodedWordY1.value.substring(0, encodedWordLengthY1);
        
    if (!binNumber(dataWordStringX) || !binNumber(dataWordStringY)) {
      alert("Code word must be in binary form");
      return
    }

    //dataBinStringX = new String(dec2binString(valueX));
    //dataBinStringY = new String(dec2binString(valueY));

    valueX = parseInt(dataWordStringX, 2);
    valueY = parseInt(dataWordStringY, 2);
     
    lengthX = dataWordStringX.length;
    lengthY = dataWordStringY.length;  
  }
  
  lengthMax = Math.max(lengthX, lengthY);

  if(form.carryIn.value.length < iteration) {
    alert("There should be " + iteration  + " carry-in bit(s)");
  }
    
  if(form.carryIn.value != "") {
    allCarryIn = parseInt(form.carryIn.value, 2);
    lengthCarryIn = form.carryIn.value.length;
    bitCarryIn = allCarryIn >> (lengthCarryIn -1);
  }
  else bitCarryIn = 0;
    
  bitValueX = (valueX >> iteration) & 1;
  bitValueY = (valueY >> iteration) & 1;
  
  sumCarryin = unitAdder(bitValueX, bitValueY, bitCarryIn);

  if(form.partialSum.value.length > lengthMax) return;

  form.partialSum.value = sumCarryin[1] + form.partialSum.value;
    
  if(iteration >= lengthMax) {
    if(form.type1[0].checked) {
      form.encodedWordZ1.value = form.partialSum.value;
    }
    else {
      constant = parseInt(form.constant1.value, base);
      consBinString = new String(dec2binString(constant));
     
      originalValueX = parseInt(form.dataWordX1.value, base);
      originalValueY = parseInt(form.dataWordY1.value, base);
      
      checkCode = ( (originalValueX % constant) + (originalValueY % constant) ) % constant;
      checkCodeBinString = new String(dec2binString(checkCode));
      
      pad = "";
      for(i=0; i<consBinString.length - checkCodeBinString.length; i++) {
        pad = pad + "0";
      }
          
      form.encodedWordZ1.value = form.partialSum.value + "  " + pad + checkCodeBinString;
    }
    iteration = 0;
    return;
  }
  
  form.carryIn.value = sumCarryin[0] + form.carryIn.value;
  
  iteration++;
}


function decodeAdd (form) {

  if (form.encodedWordZ1.value == "") {
    alert("Please input data word Z");
    return
  }

  if (form.constant1.value == "") {
    alert("Please input a decoding constant");
    return
  }

  if (form.base1[0].checked && !binNumber(form.constant1.value)) {
    alert("Constant word must be in binary form");
    return
  }

  if (form.base1[1].checked && !hexNumber(form.constant1.value)) {
    alert("Constant word must be in hexdecimal form");
    return
  }

  if(form.base1[0].checked) base = 2;
  else base = 16;

  dataWordX = parseInt(form.dataWordX1.value, base);
  dataWordY = parseInt(form.dataWordY1.value, base);
  dataBinStringX = new String(dec2binString(dataWordX));
  dataBinStringY = new String(dec2binString(dataWordY));
  constant = parseInt(form.constant1.value, base);
  consBinString = new String(dec2binString(constant));   
    
  if(form.type1[0].checked) {
    if (!binNumber(form.encodedWordZ1.value)) {
      alert("Code word must be in binary form");
      return
    }
    codeWord = parseInt(form.encodedWordZ1.value, 2);
    
    if ( codeWord  > Math.pow(2,31) ) {
      alert("Code word is too large");
      return
    }

    if (constant > codeWord) {
      alert("Encoding constant is too large");
      return
    }
    
    form.correctDecodedWordZ1.value = dec2binString(dataWordX + dataWordY);
    form.correctRemainderZ1.value = 0;

    decodedWord = Math.floor(codeWord / constant);
    remainder = codeWord % constant;
    form.decodedWordZ1.value = dec2binString(decodedWord);
    //alert(remainder);
    form.remainderZ1.value = dec2binString(remainder);

    if(remainder == 0) form.faultDetectedZ1.value = "No";
    else form.faultDetectedZ1.value = "Yes";
  }

  else {
    wholeWordLength = form.encodedWordZ1.value.length;
    encodedWordLength = 0;
    for(i=0; i<form.encodedWordZ1.value.length; i++) {
      if(form.encodedWordZ1.value.substring(i, i+1) != " ") encodedWordLength++;
      else break;
    }
    dataWordString = form.encodedWordZ1.value.substring(0, encodedWordLength);
    checkWordString = form.encodedWordZ1.value.substring(wholeWordLength-consBinString.length, 
                      wholeWordLength);
                              
    if (!binNumber(dataWordString) || !binNumber(checkWordString)) {
      alert("Code word must be in binary form");
      return
    }
  
    if (dataWordString.length  > 31) {
      alert("Code word is too large");
      return
    }

    if (consBinString.length > 31) {
      alert("Encoding constant is too large");
      return
    }
  
    form.correctDecodedWordZ1.value = dec2binString(dataWordX + dataWordY);
    form.decodedWordZ1.value = dataWordString;
    
    remainder = parseInt(dataWordString, 2) % constant;
    checkWord = parseInt(checkWordString, 2);
    remainderString = new String(dec2binString(remainder));
    
    pad = "";
    padLength = consBinString.length - remainderString.length;
    for(i=0; i<padLength; i++) pad += "0";

    form.remainderZ1.value = pad + remainderString;
    form.correctRemainderZ1.value = checkWordString;

    if(remainder == checkWord) form.faultDetectedZ1.value = "No";
    else form.faultDetectedZ1.value = "Yes";
    
  }
}



function encodeMulPartial(form) {

  if (form.dataWordX2.value == "") {
    alert("Please input data word X");
    return
  }

  if (form.dataWordY2.value == "") {
    alert("Please input data word Y");
    return
  }

  if (form.constant2.value == "") {
    alert("Please input an encoding constant");
    return
  }

  if(form.base2[0].checked) base = 2;
  else base = 16;

  if (form.base2[0].checked && !binNumber(form.dataWordX2.value)) {
    alert("Data word X must be in binary form");
    return
  }

  if (form.base2[0].checked && !binNumber(form.dataWordY2.value)) {
    alert("Data word Y must be in binary form");
    return
  }

  if (form.base2[0].checked && !binNumber(form.constant2.value)) {
    alert("Constant word must be in binary form");
    return
  }

  if (form.base2[1].checked && !hexNumber(form.dataWordX2.value)) {
    alert("Data word X must be in hexdecimal form");
    return
  }

  if (form.base2[1].checked && !hexNumber(form.dataWordY2.value)) {
    alert("Data word Y must be in hexdecimal form");
    return
  }

  if (form.base2[1].checked && !hexNumber(form.constant2.value)) {
    alert("Constant word must be in hexdecimal form");
    return
  }
  
  if(form.type2[0].checked) {
    encodedWordX = encodeAN(form.dataWordX2, form.constant2, base);
    encodedWordY = encodeAN(form.dataWordY2, form.constant2, base);
    form.encodedWordX2.value = encodedWordX;
    form.encodedWordY2.value = encodedWordY;

    lengthOfWordX = encodedWordX.length;
    lengthOfWordY = encodedWordY.length;
    
    allZero = "";
    for(i=0; i<lengthOfWordX; i++) allZero = allZero + "0";

    partialProduct = "";
    for(i=0; i<lengthOfWordY; i++) {
      padding = "";
      for(j=0; j<lengthOfWordY - i; j++) padding = padding + " ";

      if(encodedWordY.substring(lengthOfWordY - i - 1, lengthOfWordY - i) == "1")
        partialProduct = partialProduct + padding + encodedWordX;
      else
        partialProduct = partialProduct + padding + allZero;
        
      if(i < lengthOfWordY - 1) partialProduct = partialProduct + "\n";  

      //alert("***");
      //form.partialProduct.value = partialProduct;
    }    

  }
  else {
    dataWordX = parseInt(form.dataWordX2.value, base);
    dataWordY = parseInt(form.dataWordY2.value, base);
    dataBinStringX = new String(dec2binString(dataWordX));
    dataBinStringY = new String(dec2binString(dataWordY));
    //constant = form.constant2.value;
    
    encodedWordX = encodeResidue(form.dataWordX2, form.constant2, base);
    encodedWordY = encodeResidue(form.dataWordY2, form.constant2, base);
    form.encodedWordX2.value = encodedWordX;
    form.encodedWordY2.value = encodedWordY;
    
    lengthOfWordX = dataBinStringX.length;
    lengthOfWordY = dataBinStringY.length;

    allZero = "";
    for(i=0; i<lengthOfWordX; i++) allZero = allZero + "0";

    partialProduct = "";
    for(i=0; i<lengthOfWordY; i++) {
      padding = "";
      for(j=0; j<lengthOfWordY - i; j++) padding = padding + " ";

      if(encodedWordY.substring(lengthOfWordY - i - 1, lengthOfWordY - i) == "1")
        partialProduct = partialProduct + padding + dataBinStringX;
      else
        partialProduct = partialProduct + padding + allZero;

      if(i < lengthOfWordY - 1) partialProduct = partialProduct + "\n";
   }
    
  }
  
  form.partialProduct.value = partialProduct;

}


function encodeMulFinal(form) {

  checkPartialProduct(form.partialProduct.value);

  if(form.base2[0].checked) base = 2;
  else base = 16;

  dataWordX = parseInt(form.dataWordX2.value, base);
  dataWordY = parseInt(form.dataWordY2.value, base);
  dataBinStringX = new String(dec2binString(dataWordX));
  dataBinStringY = new String(dec2binString(dataWordY));
  constant = parseInt(form.constant2.value, base);
  consBinString = new String(dec2binString(constant));   
    
  if(form.type2[0].checked) {
    wordLength = form.encodedWordY2.value.length;
  }
  else {
    wordLength = dataBinStringY.length;
  }

  var finalProduct = 0;
  
  for(i=0; i < wordLength; i++) {
    partialProduct = readNumericValue(form.partialProduct.value, i);
    if(partialProduct == -1) {
      alert("Invalid partial product");
      return;
    }

    finalProduct = finalProduct + partialProduct * Math.pow(2, i);
  }

  if(form.type2[0].checked) {
    form.encodedWordZ2.value = dec2binString(finalProduct);
  }  
  else {
    checkWordZ = ( (dataWordX % constant) * (dataWordY % constant) ) % constant;
    checkWordZBinString = new String(dec2binString(checkWordZ));
    
    pad = "";
    for(i=0; i<constantBinString.length - checkWordZBinString.length; i++) {
      pad = pad + "0";
    }
            
    form.encodedWordZ2.value = dec2binString(finalProduct) + "  " + pad + checkWordZBinString;  
  }

}

function decodeMul(form) {
  
  if (form.encodedWordZ2.value == "") {
    alert("Please input data word Z");
    return
  }

  if (form.constant2.value == "") {
    alert("Please input an decoding constant");
    return
  }

  if (form.base2[0].checked && !binNumber(form.constant2.value)) {
    alert("Constant word must be in binary form");
    return
  }

  if (form.base2[1].checked && !hexNumber(form.constant2.value)) {
    alert("Constant word must be in hexdecimal form");
    return
  }

  if(form.base2[0].checked) base = 2;
  else base = 16;

  dataWordX = parseInt(form.dataWordX2.value, base);
  dataWordY = parseInt(form.dataWordY2.value, base);
  dataBinStringX = new String(dec2binString(dataWordX));
  dataBinStringY = new String(dec2binString(dataWordY));
  constant = parseInt(form.constant2.value, base);
  consBinString = new String(dec2binString(constant));   
  
  codeWord = parseInt(form.encodedWordZ2.value, 2);
  
  if ( codeWord  > Math.pow(2,31) ) {
    alert("Code word is too large");
    return
  }

  if (constant > codeWord) {
    alert("Encoding constant is too large");
    return
  }

  if(form.type2[0].checked) {
    if (!binNumber(form.encodedWordZ2.value)) {
      alert("Code word must be in binary form");
      return
    }
  
    form.correctDecodedWordZ2.value = dec2binString(dataWordX * dataWordY);
    form.correctRemainderZ2.value = 0;

    decodedWord = Math.floor(codeWord / constant / constant);
    remainder = codeWord % constant;
    form.decodedWordZ2.value = dec2binString(decodedWord);
    //alert(remainder);
    form.remainderZ2.value = dec2binString(remainder);

    if(remainder == 0) form.faultDetectedZ2.value = "No";
    else form.faultDetectedZ2.value = "Yes";
  }

  else {
    wholeWordLength = form.encodedWordZ2.value.length;
    encodedWordLength = 0;
    for(i=0; i<form.encodedWordZ2.value.length; i++) {
      if(form.encodedWordZ2.value.substring(i, i+1) != " ") encodedWordLength++;
      else break;
    }
    dataWordString = form.encodedWordZ2.value.substring(0, encodedWordLength);
    checkWordString = form.encodedWordZ2.value.substring(wholeWordLength-consBinString.length, 
                      wholeWordLength);
                              
    if (!binNumber(dataWordString) || !binNumber(checkWordString)) {
      alert("Code word must be in binary form");
      return
    }                  
                      
    form.correctDecodedWordZ2.value = dec2binString(dataWordX * dataWordY);
    form.decodedWordZ2.value = dataWordString;
  
    remainder = parseInt(dataWordString, 2) % constant;
    checkWord = parseInt(checkWordString, 2);
    remainderString = new String(dec2binString(remainder));

    pad = "";
    padLength = consBinString.length - remainderString.length;
    for(i=0; i<padLength; i++) pad += "0";

    form.remainderZ2.value = pad + remainderString;
    form.correctRemainderZ2.value = checkWordString;

    if(remainder == checkWord) form.faultDetectedZ2.value = "No";
    else form.faultDetectedZ2.value = "Yes";

  }

}


</SCRIPT>

</HEAD>



<BODY bgcolor="dddddd">

<font size="+4"><B>Arithmetic Encoder/Decoder </B></font>

<BR><a href="arithcode_help.html"><font color="#0000ff">Help and Information</font></a>

<FORM>

<table cellpadding=10>

<font size="+3"><B>Single data word</B></font><BR>

<font size="+2"><B>AN code</B></font><input type="radio" name="type" value="ANCode" checked>
<font size="+2"><B>Residue code</B></font><input type="radio" name="type" value="residueCode"><BR>

<font size="+2"><B>Bin</B></font><input type="radio" name="base" value="Bin" checked>
<font size="+2"><B>Hex</B></font><input type="radio" name="base" value="Hex"><BR>

<tr>
<td><B>Data word: </B><BR><INPUT type="text" name="dataWord" size=16><BR></td>
<td><B>Encoding constant:</B><BR><INPUT type="text" name="constant" size=16></td>
</tr>

<tr>
<td><INPUT type="button" name="enter1" value="Encode" onClick="encode(this.form)"></td>
</tr>

<tr>
<td><B>Encoded word:</B><BR><INPUT type="text" name="encodedWord" size=16></td>
<td><BR><INPUT type="button" name="reset0" value="Reset" onClick="resetSingle(this.form)"</td>
</tr>

<tr>
<td><INPUT type="button" name="enter2" value="Decode" onClick="decode(this.form)"></td>
</tr>

<tr>
<td><B>Correct word:</B><BR><INPUT type="text" name="correctDecodedWord" size=16></td>
<td><B>Correct Remainder:</B><BR><INPUT type="text" name="correctRemainder" size=16></td>
</tr>

<tr>
<td><B>Decoded word:</B><BR><INPUT type="text" name="decodedWord" size=16><BR></td>
<td><B>Remainder: </B><BR><INPUT type="text" name="remainder" size=16><BR></td>
<td><B>Fault detected:</B><BR><INPUT type="text" name="faultDetected" size=4></td>
</tr>

</table>


<BR><BR><BR><BR>

<font size="+3"><B>Data words with arithmetic operation</B></font><BR><BR>
<font size="+2"><B>Addition of X and Y</B></font><BR>
<font size="+2"><B>AN code</B></font><input type="radio" name="type1" value="ANCode" checked>
<font size="+2"><B>Residue code</B></font><input type="radio" name="type1" value="residueCode"><BR>
<font size="+2"><B>Bin</B></font><input type="radio" name="base1" value="Bin" checked>
<font size="+2"><B>Hex</B></font><input type="radio" name="base1" value="Hex"><BR>

<table cellpadding=5>
<tr>
<td><B>Data word X: </B><BR><INPUT type="text" name="dataWordX1" size=16></td>
<td><B>Data word Y: </B><BR><INPUT type="text" name="dataWordY1" size=16></td>
<td><B>Encoding constant:</B><BR><INPUT type="text" name="constant1" size=16></td>
</tr>
</table>

<table cellpadding=5>
<tr><td><INPUT type="button" name="addPartial" value="Calculate next bit" onClick="encodeSumPartial(this.form)"></td></tr>
</table>

<table cellpadding=5>
<td><B>Encoded word X:</B><BR><INPUT type="text" name="encodedWordX1" size=16></td>
<td><B>Encoded word Y:</B><BR><INPUT type="text" name="encodedWordY1" size=16></td>
</table>

<table cellpadding=5>
<tr><td><B>Carry-in: </B><BR><INPUT type="text" name="carryIn" size=16></td></tr>
<tr><td><B>Partial sum: </B><BR><INPUT type="text" name="partialSum" size=16></td></tr>
<tr><td><B>Encoded word Z:</B><BR><INPUT type="text" name="encodedWordZ1" size=16></td>
<td><BR><INPUT type="button" name="reset1" value="reset" onClick="resetAdd(this.form)"></td></tr>
</table>

<table cellpadding=5>

<tr>
<td><INPUT type="button" name="enter5" value="Decode" onClick="decodeAdd(this.form)"></td>
</tr>

<tr>
<td><B>Correct word Z:</B><BR><INPUT type="text" name="correctDecodedWordZ1" size=16></td>
<td><B>Correct Remainder:</B><BR><INPUT type="text" name="correctRemainderZ1" size=16></td>
</tr>

<tr>
<td><B>Decoded word Z:</B><BR><INPUT type="text" name="decodedWordZ1" size=16></td>
<td><B>Remainder: </B><BR><INPUT type="text" name="remainderZ1" size=16></td>
<td><B>Fault Detected:</B><BR><INPUT type="text" name="faultDetectedZ1" size=4></td>
</tr>




</table>


<BR><BR><BR><BR>

<font size="+2"><B>Multiplication of X and Y</B></font><BR>
<font size="+2"><B>AN code</B></font><input type="radio" name="type2" value="ANCode" checked>
<font size="+2"><B>Residue code</B></font><input type="radio" name="type2" value="residueCode"><BR>
<font size="+2"><B>Bin</B></font><input type="radio" name="base2" value="Bin" checked>
<font size="+2"><B>Hex</B></font><input type="radio" name="base2" value="Hex"><BR>

<table cellpadding=5>
<tr>
<td><B>Data word X: </B><BR><INPUT type="text" name="dataWordX2" size=16></td>
<td><B>Data word Y: </B><BR><INPUT type="text" name="dataWordY2" size=16></td>
<td><B>Encoding constant:</B><BR><INPUT type="text" name="constant2" size=16></td>
</tr>
</table>

<table cellpadding=5>
<tr><td><INPUT type="button" name="mulPartial" value="Calculate Partial Product" onClick="encodeMulPartial(this.form)"></td></tr>
</table>

<table cellpadding=5>
<td><B>Encoded word X:</B><BR><INPUT type="text" name="encodedWordX2" size=16></td>
<td><B>Encoded word Y:</B><BR><INPUT type="text" name="encodedWordY2" size=16></td>
</table>

<table cellpadding=5>
<tr><td><textarea rows="6" name="partialProduct" cols="30" tabindex="5"></textarea></td></tr>
<tr><td><INPUT type="button" name="mulFinal" value="Calculate Final Product" onClick="encodeMulFinal(this.form)"></td></tr>
<tr><td><B>Encoded word Z: </B><BR><INPUT type="text" name="encodedWordZ2" size=16></td>
<td><BR><INPUT type="button" name="reset1" value="reset" onClick="resetMul(this.form)"></td></tr>
</table>

<table cellpadding=5>

<tr>
<td><INPUT type="button" name="enter5" value="Decode" onClick="decodeMul(this.form)"></td>
</tr>

<tr>
<td><B>Correct word Z:</B><BR><INPUT type="text" name="correctDecodedWordZ2" size=16></td>
<td><B>Correct Remainder:</B><BR><INPUT type="text" name="correctRemainderZ2" size=16></td>
</tr>

<tr>
<td><B>Decoded word Z:</B><BR><INPUT type="text" name="decodedWordZ2" size=16></td>
<td><B>Remainder: </B><BR><INPUT type="text" name="remainderZ2" size=16></td>
<td><B>Fault Detected:</B><BR><INPUT type="text" name="faultDetectedZ2" size=4></td>
</tr>




</table>

</FORM>

</BODY>

</HTML>
