<html>
<head>
<title>Locating faults in an implementation of AES</title>
<style type="text/css"><!--
h2 { text-align: center }
p { margin: 20px; }
--></style>
</head>
<body>
<h2>Detecting and locating faults in AES</h2>
<hr>
<center>[<a href="main.html">Simulator</a>] [Help] </center>
<p>

<H3>Glossary of Terms and Acronyms</H3><p>
<font color="blue">Cipher Key</font> Secret, cryptographic key that is used by the Key Expansion routine to
generate a set of Round Keys; can be pictured as a rectangular array of
bytes, having four rows and Nk columns.<p>
<font color="blue">Plaintext Data</font> input to the Cipher or output from the Inverse Cipher.<p>
<font color="blue">Ciphertext</font> Data output from the Cipher or input to the Inverse Cipher.<p>
<font color="blue">Rijndael</font> Cryptographic algorithm specified in this Advanced Encryption
Standard (AES).<p>
for more details about the AES standard, please refer 
to <a href="../../../../../../csrc.nist.gov/CryptoToolkit/aes/default.htm">AES home page</a>.

<H3>AES encryption process in rounds</H3>
<img src="round.jpg">

<H3>Fault Detection and Location in AES</H3><p>

<u>Fault detection using Error detecting codes (EDCs)</u><p> 
Associates one parity bit with each byte element of the state matrix S, 
for a total of 16 parity bits. These parity bits can be
arranged as a 4X4 parity matrix, the bit elements of which
are in one-to-one correspondence to the byte elements of the
state matrix S . Each parity bit is computed so that the parity
of the data byte and the associated parity bit will be even. 
To implement this coding scheme, it is necessary to
develop, for each round transformation, a method for
predicting the output parity, given the input state and the
input parity. <p>
The follwing section provides more information about the calculation of
predicted parity. <p>
<font color="blue">SubBytes (or Sbox)</font>. The Sbox is usually implemented as a
256X8 bits memory, consisting of a data storage section
and an address decoding circuit. The incoming data bytes
will normally have properly generated even parity bits. To
generate the outgoing parity bits, an even parity bit can be
stored with each data byte in the Sbox memory, which will
now be of size 256X9 bits. <p>
<font color="blue">ShiftRows</font>. The prediction of the output parity bits is
straightforward: It is simply a rotated version of the input
parity bits following the same rule.<p>
<font color="blue">MixColumns</font>. The prediction of the output parity bits of
MixColumns is the most mathematically complex one. The
detailed solution is described in Appendix A of the paper. The final set
of equations for predicting the parity bits are, however,
quite simple.<p>
<font color="blue">AddRoundKey</font>. The prediction of the output parity bits is
almost straightforward: It consists of adding the input
parity matrix associated with the data block to the parity
matrix associated with the current round key.<p>
The complete prediction scheme for one round is
obtained by cascading the prediction schemes of the four
round transformations. To check the parity bits and
generate a parity error flag, we need a set of byte parity
generators and comparators which will compare the
predicted parity bits to the generated parity bits.<p>
This method can detect all the faults of odd order, and can detect most of the faults of even order.<p>
For more details about this EDC method, please refer to the article:
 G. Bertoni, L. Breveglieri, I. Koren, P. Maistri and V.
Piuri, <a href="../../../../../../euler.ecs.umass.edu/research/aes03.pdf">
"Error Analysis and Detection Procedures for a Hardware
Implementation of the Advanced Encryption Standard," </a> (<font
color="red">pdf file</font>),<I> IEEE Trans. on
Computers,</I> April 2003.<br><br>

<u> Fault location</u><p>
In order to study the propogation of incorrect parity state, an error state matrix E is defined. It is of the same size as the 
the parity error and contains a 1 in each position where the expected parity and the actual parity dont match.
When a fault is inject in a round, the error state matrix will show a single entry of value 1. As the fault propogates through the 
system, the error state matrix changes at the end of each round. After eight rounds, the error state matrices start repeating again
in a cycle. The figure below shows the error state matrices (in decimal form) for each round when a fault is injected in a particular 
byte. <p>
<img src="esm.jpg"><p>
X1 - X16 are the different bytes in which the faults can be injected. Z0 - Z7 are the error state matrices for rounds 0 (current round)
to the 7th round following the fault inject round. It is obvious from the figure that all the error state matrices are unique, giving
us the ability to detect the round and the byte in which the fault was detected with a latency of atmost eight rounds. <p>
 
For more details about this method, please refer to the article:
 G. Bertoni, L. Breveglieri, I. Koren, P. Maistri and V.
Piuri, <a href="../../../../../../euler.ecs.umass.edu/research/aes-dft03.pdf">
 "Detecting and Locating Faults in VLSI Implementations of the Advanced Encryption Standard," </a> (<font
color="red">pdf file</font>),<I> Proc. of the 2003 IEEE International Symposium on Defect and Fault Tolerance in VLSI Systems,</I> April 2003.<br><br>


<H3>Usage </H3><p>

<font color="blue">Key size in bits</font>:<p>
Select the desired secret key size. It can be one of 128, 195 or 256 bits.<p> 
<font color="blue">Block size in bits</font>:<p>
Select the desired block size. It can be one of 128, 195 or 256 bits.<p>
<font color="blue">Key in hex</font>:<p>
Enter the secret key in hex. For 128 bits, enter 32 hex characters, for 194 bits, enter 48 hex characters and for 256 bits, enter 64 hex characters.<p>
<font color="blue">Plain or Cypher text in Hex</font>:<p>
Enter the Plain text or encrypted text in hex. For 128 bits, enter 32 hex characters, for 194 bits, enter 48 hex characters and for 256 bits, enter 64 hex characters.<p>
<font color="blue">Experiment</font>:<p>
Choose the experiment you want to run. Choose 'None' if you want to run the AES algorithm without injecting faults. Choose 'Fault detection' if you want to use the scheme
described by the first paper above. Choose 'Fault Location' if you want to use the scheme described by the second paper above. <p>
<font color="blue">Round Number</font>:<p>
Applicable only if 'Fault Detection' or 'Fault Location' is choosen above. Enter the round number in which the fault should be injected. <p>
<font color="blue">Round Transformation</font>:<p>
Applicable only if 'Fault Detection' is choosen above. For fault location, the fault is injected before the start of the round. Choose the appropriate transformation that you want to inject the fault into. <p>
<font color="blue">Byte number</font>:<p>
Applicable only if 'Fault Detection' or 'Fault Location' is choosen above. Enter the byte number that should be injected with a fault. A random bit will be flipped in that byte. <p>
<font color="blue">Round to check fault detection in</font>:<p>
Applicable only if 'Fault Detection' or 'Fault Location' is choosen above. Enter the round in which the fault should be detected.<P>
<font color="blue">Action buttons</font>:<p>
Click 'Encrypt' or 'Decrypt' to run the simulation. 'Click' clear to clear all the fields. <p>
<font color="blue">Expected Output (plaintext or encrypted text)</font>:<p>
The expected plaintext or encrypted text will be shown in hex. <p>
<font color="blue">Actual Output (plaintext or encrypted text)</font>:<p>
The actual plaintext or encrypted text will be shown in hex. It will match the previous field if the experiment is 'None'. <p>
<font color="blue">Fault detection/Location results</font>:<p>
The results of the fault detection or location experiments will be shown here. Note that for fault location, the results shown
can be wrong if the round in which the fault is checked is separated from the injection round by 8 rounds or greater. Refer to the second
paper above for more details.<p>
<font color="blue">Expected Parity</font>:<p>
The expected parity of the state matrix at the fault detection round. <p>
<font color="blue">Actual Parity</font>:<p>
The actual parity of the state matrix at the fault detection round. <p>
<font color="blue">Error State Matrix</font>:<p>
The error state matrix is only shown for the 'Fault Location' experiment. In the ideal case, it will be all zeros. Refer to the second
paper above for more details.<p>
</body>
</html>