<html><head><title>Locating faults in an implementation of AES</title>
<script src="rijndael.js" type="text/javascript" language="JavaScript">
</script>

<script type="text/javascript" language="JavaScript"><!--

function processInputs() {
  var ptArray, keyArray;
  var theForm = document.forms[0];
   
  maxRoundNumber = 10;
  maxByteNumber = 16;
  keySizeInBits = theForm.keySize[theForm.keySize.selectedIndex].value;
  blockSizeInBits = theForm.blockSize[theForm.blockSize.selectedIndex].value;
  inputTypeSel = theForm.inputType[theForm.inputType.selectedIndex].value;
   
  if (theForm.experiment[0].checked == true) {
    experiment = "None";
  }  else if (theForm.experiment[1].checked == true) {
    experiment = "Fault detection";
  } else if (theForm.experiment[2].checked == true) {
    experiment = "Fault location";
  } 

  roundNumber = parseInt(theForm.roundNumber.value);
  checkInRound = parseInt(theForm.checkInRound.value);
  transformation = theForm.transformation[theForm.transformation.selectedIndex].value;
  byteNumber = parseInt(theForm.byteNumber.value);

  switch (keySizeInBits) {
      case 128:
          maxRoundNumber = 10;
          maxByteNumber = 16;
          break;
      case 196:
          maxRoundNumber = 12;
          maxByteNumber = 24;
          break;
      case 256:
          maxRoundNumber = 14;
          maxByteNumber = 32;
          break;
  }
  
  if (theForm.key.value.toLowerCase().indexOf("0x") == 0)
      theForm.key.value = theForm.key.value.substring(2);
  if (theForm.input.value.toLowerCase().indexOf("0x") == 0)
      theForm.input.value = theForm.input.value.substring(2);
  
  if (theForm.key.value.length*4 != keySizeInBits) {
      alert("For a " + keySizeInBits + " bit key, the hex string needs to be " +
            (keySizeInBits / 4) + " hex characters long.");
      if (theForm.key.select)
          theForm.key.select();
      return;
  }

  if (theForm.input.value.length*4 != blockSizeInBits) {
      if (inputTypeSel == "CipherText") {	
          alert("For a " + blockSizeInBits + " bit block, the hex ciphertext string needs to be " +
                (blockSizeInBits / 4) + " hex characters long.");
      } else {
            alert("For a " + blockSizeInBits + " bit block, the hex plaintext string needs to be " +
                  (blockSizeInBits / 4) + " hex characters long.");
      }
      if (theForm.input.select)
          theForm.input.select();
      return;
  }

  if (experiment != "None") {    
      if (isNaN(roundNumber) || roundNumber < 1 || roundNumber > maxRoundNumber) {
          alert("For a key size of " + keySizeInBits + ", the round number must be in the range: " +
                "1 - " + maxRoundNumber);
          return;      
      }
      if (isNaN(checkInRound) || checkInRound < 1 || checkInRound > maxRoundNumber) {
          alert("For a key size of " + keySizeInBits + ", the check in round field must be in the range: " +
                "1 - " + maxRoundNumber);
          return;      
      }
      if (isNaN(byteNumber) || byteNumber < 1 || byteNumber > maxByteNumber) {
          alert("For a key size of " + keySizeInBits + ", the byte number must be in the range: " +
                "1 - " + maxByteNumber);
          return;
      }
  }
    
  if (experiment == "Fault location") {
      alert("Fault will be injected at the beginning of round " + roundNumber + " in byte " + byteNumber + ".\nFault location will occur in round "  + checkInRound + ".");
  } else if (experiment == "Fault detection") {
      alert("Fault will be injected in round " + roundNumber + " before " + transformation + " in byte " + byteNumber + ".\nFault detection will occur in round "  + checkInRound + ".");
  }

  ptArray = hexToByteArray(theForm.input.value);
  keyArray = hexToByteArray(theForm.key.value);
  
  if (inputTypeSel == "CipherText") {
      var res = rijndaelDecrypt(ptArray, keyArray, "ECB");
      theForm.output.value = byteArrayToHex(res[0]);
      theForm.outputExpected.value = byteArrayToHex(res[1]);
  } else {
      var res = rijndaelEncrypt(ptArray, keyArray, "ECB");
      theForm.output.value = byteArrayToHex(res[0]);
      theForm.outputExpected.value = byteArrayToHex(res[1]);
  }

  if (experiment == "None") {
      theForm.faultDetected.value = "N/A";
      theForm.faultLocated.value = "N/A";
      theForm.whichRound.value = "N/A";
      theForm.whichByte.value = "N/A";
      theForm.errorStatusString.value = "N/A";
      theForm.expectedParityString.value = "N/A";
      theForm.actualParityString.value = "N/A";	      
  }
  if (experiment == "Fault detection") {
      theForm.faultDetected.value = faultDetected;
      theForm.faultLocated.value = "N/A"; 
      theForm.whichRound.value = "N/A"; 
      theForm.whichByte.value = "N/A";
      theForm.errorStatusString.value = "N/A";
      theForm.expectedParityString.value = expectedParityString;
      theForm.actualParityString.value = actualParityString;	    
  }
 
  if (experiment == "Fault location") {
     theForm.faultDetected.value = faultDetected;
     theForm.faultLocated.value = faultLocated;
     theForm.whichRound.value = whichRound;
     theForm.whichByte.value = whichByte;
     theForm.errorStatusString.value = errorStatusString;
     theForm.expectedParityString.value = expectedParityString;
     theForm.actualParityString.value = actualParityString;	    
  }
}

function changeOutputType() {
  var theForm = document.forms[0];
  inputTypeSel = theForm.inputType[theForm.inputType.selectedIndex].value;
  if (inputTypeSel == "CipherText") {
      theForm.outputType.value = "Plain text (actual)";
      theForm.outputTypeExpected.value = "Plain text (expected)"; 
      theForm.processButton.value = "Decrypt";
  } else {
      theForm.outputType.value = "Cipher text (actual)";
      theForm.outputTypeExpected.value = "Cipher text (expected)";
      theForm.processButton.value = "Encrypt";
  }
}

function clearInputs() {
  roundNumber = 0;
  transformation = "SubBytes";
  byteNumber = 0;
  faultDetected = "";
  faultLocated = "";
  whichRound = "";
  whichByte = "";
  checkInRound = 0;
  theForm.expectedParityString.value = "";
  theForm.actualParityString.value = "";
  theForm.errorStatusString.value = "";
  
  var theForm = document.forms[0];
  theForm.processButton.value = "Encrypt";
  theForm.experiment.value = "None";
}

// --></script>

<style type="text/css"><!--
h2 { text-align: center }
p { margin: 20px; }
--></style>

</head>
<body>
<h2>Detecting and locating faults in AES</h2>
<hr>
<center>[Simulator] [<a href="help.html">Help</a>] </center>
<p>

<form onsubmit="return false">
<table>
<tr>
   <td></td>
   <td><i>Step 1: Enter key and plaintext or encrypted text </i></td>
</tr>
<tr>
   <td><b>Key size in bits: </b></td>
   <td><select name="keySize">
	<option value="128" selected="selected">128</option>
	<option value="192">192</option>
	<option value="256">256</option>
       </select></td>
</tr>
<tr>
   <td><b>Block size in bits: </b></td>
   <td><select name="blockSize">
	<option value="128" selected="selected">128</option>
	<option value="192">192</option>
	<option value="256">256</option>
      </select></td>
</tr>
<tr>
   <td><b>Key in hex: </b> </td>
   <td><input type="text" value="bdcd5efadc6028ced26689cc72aa928b" size="66" name="key"></td>
</tr>
<tr>
   <td><select name="inputType" onchange="return changeOutputType()">
   	<option value="PlainText" selected="selected">Plain Text (hex)</option>
   	<option value="CipherText">Cipher text (hex)</option>
       </select></td>	
   <td><input type="text" value="48de8f32cc374bf284e6334418bb3c6e" size="66" name="input"></td>
</tr>
<tr>
   <td></td>
   <td><i>Step 2: Enter fault injection information </i></td>
</tr>
<tr>
   <td><b>Experiment:</b></td>
   <td>
      <input type="radio" name="experiment" value="None" checked>None
      <input type="radio" name="experiment" value="Fault detection">Fault detection
      <input type="radio" name="experiment" value="Fault location">Fault location
   </td>
</tr>
<tr>
   <td><b>Round number: </b></td>
   <td><input type="text" size="3" name="roundNumber"></td>
</tr>
<tr>
   <td><b>Round transformation: </b></td>
   <td><select name="transformation">
	<option value="SubBytes" selected="selected">SubBytes</option>
	<option value="ShiftRows">ShiftRows</option>
	<option value="MixColumns">MixColumns</option>
	<option value="AddRoundKey">AddRoundKey</option>
      </select></td>
</tr>
<tr>
   <td><b>Byte number: </b></td>
   <td><input type="text" size="3" name="byteNumber"></td> 
</tr>
<tr>
   <td><b>Round to check fault detection in:</b></td>
   <td><input type="text" size="3" name="checkInRound"></td>
</tr>
<tr>
   <td></td>
   <td><i>Step 3: Run or reset the simulation </i></td>
</tr>
<tr>
   <td> &nbsp; </td>
   <td><input type="button" name="processButton" value="Encrypt" onclick="processInputs()"> &nbsp; &nbsp; 
	<input type="reset" value="Clear" onclick="clearInputs()"></td>
</tr>
<tr></tr>
<tr>
   <td></td>
   <td><i>Step 4: Simulation results</i></td>
</tr>
<tr>
   <td><input type="text" size="20" name="outputTypeExpected" value="Cipher text (Expected)" readonly="true"></td>
   <td><input type="text" size="66" name="outputExpected" readonly="true"></td>
</tr>
<tr>
   <td><input type="text" size="20" name="outputType" value="Cipher text (Actual)" readonly="true"></td>
   <td><input type="text" size="66" name="output" readonly="true"></td>
</tr>
<tr>
   <td></td>
   <td><table>
          <tr>
            <td>Fault detected?</td>
            <td><input type="text" size="3" name="faultDetected" readonly="true"></td> 
            <td>Fault located?</td>
            <td><input type="text" size="3" name="faultLocated" readonly="true"></td> 
          </tr>
          <tr>
            <td>Which round?</td>
            <td><input type="text" size="3" name="whichRound" readonly="true"></td> 
            <td>Which byte?</td>
            <td><input type="text" size="3" name="whichByte" readonly="true"></td> 
          </tr>
       </table></tr>
</tr>
<tr>
   <td></td>
   <td><u>The following parity and error matrices were generated during the fault detection round specified above.</u></td>  
</tr>
<tr>
   <td>Expected parity:</td>
   <td><input type="text" size="20" name="expectedParityString" readonly="true"></td> 
</tr>
<tr>
   <td>Actual parity:</td>
   <td><input type="text" size="20" name="actualParityString" readonly="true"></td> 
</tr>
<tr>
   <td>Error state matrix (LSB - MSB):</td>
   <td><input type="text" size="20" name="errorStatusString" readonly="true"></td> 
</tr>
</table>
</form>
</p>

<p>

<hr>
<small> Many thanks to <a href="../../../../../../www.cs.ucsd.edu/~fritz/rijndael.html">Fritz Schneider</a> whose implementation 
of the Rijndael algorithm has been used in this project.
<br><br>
Last Modified: <script><!--
document.write(document.lastModified);
// --></script>
</small>


</body>
</html>
