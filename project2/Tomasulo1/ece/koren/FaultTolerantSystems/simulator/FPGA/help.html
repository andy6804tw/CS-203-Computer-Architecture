<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Single Event Upset Simulator</title>
             
  <meta http-equiv="content-type"
 content="text/html; charset=ISO-8859-1">
</head>
  <body>
 
<h1 align="center"> FPGA Single Event Upset Simulator</h1>
  <br>
 
<h2> Introduction</h2>
  Single events upsets (SEUs) are a commonly seen problem affecting memory
cells. &nbsp;When a SEU occurs, a memory cell is flipped from a logical  '1'
to a logical '0', or from a '0' to a '1', due to environmental factors, such as radiation.
&nbsp;They remain in the flipped state until overwritten.&nbsp; In FPGAs,
SEUs can cause problems since SRAM memory cells store the configuration information.
&nbsp;When an upset occurs, the configuration changes which can cause the
FPGA to operate in an undesired behavior. &nbsp;For example a 2 input LUT
that is set to be an AND gate would have a configuration of "0001" where
the last bit represents the case where both inputs are 1. &nbsp;Suppose an
upset occurs and changes the configuration to "0101". &nbsp;This makes the
LUT operate as a buffer which always passes the value of the second input
to the output.<br>
 <br>
 To handle the SEUs, a common technique is used to detect and correct the
errors. &nbsp;The detection is done by continually performing cyclic redundancy
check (CRCs) on the configuration bitstream. &nbsp;When a readback is performed
on the FPGA, a CRC is automatically calculated by the hardware. &nbsp;This
value is compared to the originally calculated CRC and if they differ an
error is detected. &nbsp;Since the configuration bitstream is so big, the
configuration is broken up into frames. &nbsp;Frames are groups of configuration
data spanning the entire device vertically that are readback together. &nbsp;The
error detection circuitry (outside of the FPGA) will cycle through the many
frames in the FPGA, reading them back in order. &nbsp;When a error is detected,
a reconfiguration of the frame is performed. &nbsp;This will overwrite the
"bad" memory cell with the known "good" configuration stored in a presumed
reliable medium off chip - such as a PROM.<br>
 <br>
 The simulator demonstrates the technique of using CRC checks along with
partial reconfiguration to detect and correct upsets. &nbsp;It has the feature
of allowing the user to specify the design, specify how long the readback/reconfiguration 
takes, and specifying which bit gets upset and when. &nbsp;The simulator allows
the user to step through the events to get a better idea of how this technique
is used in practice. &nbsp;A simplified FPGA is used, but all of the principles
are consistent with state of the art FPGAs.<br>
<font color="#ff0000"><br>
Note: The applet was designed and tested on Java 1.4. &nbsp;It was compiled
with the "-target 1.3" option and should support Java 1.3 JVMs. &nbsp;If
there are problems running the applet, it may be due to Java version differences.<br>
</font> <br>
 <br>
<br>
 
<h2> Simulator Interface</h2>
   
<h3> Create Design </h3>
 &nbsp;The first step is to enter the FPGA design. &nbsp;Clicking the "<font
 color="#cc33cc">Create Design</font>" button opens a text area on the right
hand side of the screen. &nbsp;To choose an example design pull down the
menu labeled "<font color="#cc33cc">choose design</font>". &nbsp;This  will
fill in  the text area below with command to configure the FPGA. &nbsp;Whether that step is  taken
or skipped, commands to set the configuration of the FPGA can then be entered
 into the text area. &nbsp;The form of the command is shown below:<br>
 
<p> <i>set &lt;row&gt; &lt;column&gt; &lt;resource&gt; &lt;value&gt;</i><br>
  <br>
  The first word is the command name - set. &nbsp;The remaining arguments are the parameters
of the command. &nbsp;The first two parameters take the CLB row and CLB column
of the device where the resource is located. &nbsp;The resource is the name of 
the configurable
resource (e.g. a routing mux, an input mux, or a LUT) that is to be set. &nbsp;The value is
the value that the resource should be set to. &nbsp;For a LUT, the value
must be a 16 character string representing  the contents of the 4 input LUT 
(i.e. it can use the characters 0 or 1).&nbsp; Note that the string is unquoted. &nbsp;For
a mux the value will be the name of the  resource that &nbsp;the mux will select
(i.e. for a NBEG0 resource with a NEND0  value means that the mux that drives
the NBEG0 resource will select NEND0).&nbsp;  For example:</p>
   
<p><i>set 2 2 NBEG0 NEND0</i><br>
  </p>
   
<p>When the design is complete, clicking the ok button will bring back the 
graphical view of the FPGA.&nbsp; The FPGA now shows the design that was just entered.&nbsp; 
 The blue coloring indicate resources that are in use.<br>
</p>
<p><font color="#ff0000">Note: resource names are case sensitive.</font>&nbsp;</p>
      
<h3>SEU Probability</h3>
   
<p>After the design was entered, the text field labeled "<font
 color="#cc33cc">Care bit ratio</font>" was  filled in.&nbsp; This represents
the number of bits used in the particular  design as a fraction of the total
bits in the configuration bitstream.&nbsp;  This is commonly low in FPGAs
due to a lot of resources being unused.&nbsp;  Next, the probability of
a SEU occurring is to be entered in the "<font color="#cc33cc">SEU Prob</font>&quot; 
text field.&nbsp; The SEU probability must lie 
between 0  and 1.&nbsp; The probability differs depending on various environmental 
factors.&nbsp;  The most common one is exposure to radiation - in space SEUs
are more probable than at the top of a mountain, which in turn has a higher
SEU rate than at sea  level.&nbsp; When that is filled in, the "<font color="#cc33cc">Prob{Impact}</font>"
field will then show the probability that a SEU will  affect the design.&nbsp; 
This is simply the care bit ratio times the SEU  probability.&nbsp;</p>
      
<h3>Simulation Fields</h3>
   
<p>There are three pieces of information that need to be filled out in order 
to  proceed to the simulation.&nbsp; The first field is the readback time.&nbsp; 
 Recall that the SEU is detected by continually performing readbacks on each 
of  the frames in the FPGA and comparing the CRC against a known good CRC 
value.&nbsp;  The time it takes to readback is to be entered in the "<font
 color="#cc33cc">Readback time</font>" text  field.&nbsp; The time has no
fixed time unit and can be interpreted by the user - typically it is microseconds.&nbsp; 
Note that all of the time fields should be whole numbers.&nbsp; Any fraction 
will be ignored.
</p>
   
<p>The second property to be entered is the reconfiguration time.&nbsp; This 
is the  time it takes, once an upset is detected, to fix the problem.&nbsp; 
Recall that  it is fixed by  reconfiguring the frame with a known good 
configuration  which is stored in, for example, a PROM. &nbsp;Like the readback
time, the value entered in the "<font color="#cc33cc">Reconfig. time</font>"
does not have a time unit associated with it.</p>
   
<p>The next property is about the SEU - 4 fields.&nbsp; The first field "<font
 color="#cc33cc">time</font>" is the  time when the upset occurs.&nbsp; The row and column, entered in the "<font
 color="#cc33cc">row</font>" and "<font color="#cc33cc">col</font>" text
fields respectively, determine the CLB where the affected bit is located.&nbsp;
The bit, set with the "<font color="#cc33cc">bit</font>" text field, is within
that CLB  which bit is affected.&nbsp; As seen in the Architecture Guide
below, the row  must lie between 0 and 3, the column between 0 and 3, and
the bit between 0 and  83. &nbsp;Note that while the time of the SEU is in
the same time unit as the readback and reconfiguration times, this is only
to simplify the simulation. &nbsp;In reality the SEU would more likely be
on a several orders of magnitude longer scale (i.e. days instead of microseconds).</p>
   
<p>Finally, there is a check box labeled "<font color="#cc33cc">find SEU bit</font>".
&nbsp;There are two possible ways to handle an error. &nbsp;The first way
is to detect the error, and always reconfigure the frame. &nbsp;In this case,
the application can tolerate temporary faults and there is no need to recover.
&nbsp;For example, in a telephone switch if a few milliseconds of audio are
lost the conversation will hardly be affected. &nbsp;Alternately, some applications,
such as lossless compression, may require the operation performed completely
without any errors. &nbsp;In this case, a rollback to a checkpoint is required
on faults. &nbsp;To minimize the number of rollbacks required and to take
advantage of the low care bit ratio, the second way to handle an error is to check the readback
bitstream against the known good bitstream and determine if the bit was part
of the design. &nbsp;This has the advantage that it can be detected if there is
a need to recover from the error or simply fix the error and continue operating.
&nbsp;Fixing errors that do not affect the design is still necessary since
the error detection is not guaranteed to find multiple errors. &nbsp;Checking
the check box will perform the check to determine if the SEU was part of
the design or not. &nbsp;It will print out a message detailing the findings.</p>
   
<h3>Simulation Control</h3>
   
<p>Once all of the fields are filled in, the simulation is ready to be run.&nbsp; 
 Clicking the "<font color="#cc33cc">start simulation</font>" button will
prepare the system for simulation.&nbsp;  It downloads the design to the
virtual FPGA, performs validation of the input fields,  and other initialization.&nbsp;
The simulation can then be stepped with the "<font color="#cc33cc">step</font>"
button.&nbsp;  Stepping performs advances in time based on significant events
(i.e. it is not  necessarily a regular time interval).&nbsp; The significant
events are a  readback with CRC check, an upset as set by the user in the
text fields, and a  reconfiguration when an upset is detected.&nbsp; </p>
   
<p>The yellow highlighted column represents the current column that the CRC 
 checker is working on.&nbsp; When an upset occurs, the affected resource 
will  turn red.&nbsp; After the CRC checker detects the error and the reconfiguration 
 fixes the upset the resource will turn back to its original color (blue if
used,  gray if not).</p>
   
<p>After an upset occurs and has been fixed a second SEU can be added to the
 simulation.&nbsp; Pressing the "<font color="#cc33cc">pause</font>" button
will pause the simulation and  allow the user to enter in a new SEU in the
SEU time, row, col, and bit text fields.&nbsp;  Note that the time must be
greater than the current time.&nbsp; To go back to  the simulation, press
the "<font color="#cc33cc">unpause</font>" button (which is the same button
as the pause  button).</p>
   
<p>&nbsp;<br>
 <br>
 </p>
   
<h2>Architecture Guide</h2>
   
<p>The example FPGA is a 4 by 4 array of configurable logic blocks (CLB) with 
the bottom left being (row=0, col=0).&nbsp; 
 Each CLB has a lookup table (LUT), inputs and outputs to the LUT, wires 
connecting to other CLBS, and a switch box for connecting wires.&nbsp; The 
 diagram below marks the different features of the FPGA.</p>
   
<p><img border="0" src="FPGA.GIF" width="535" height="480">
 </p>
   
<h3>LUT and Inputs/Outputs</h3>
   
<p>The LUT is a four input, one output lookup table.&nbsp; It can implement
any  function and therefore requires sixteen configuration bits to describe
the  functionality.&nbsp; The inputs are named IN0, IN1, IN2, IN3.&nbsp; The 
output is named OUT.&nbsp; The LUT resource is named LUT.</p>
   
<h3>&nbsp;Wires </h3>
    
<p>There is are four vertical channels of wires. &nbsp;Each channel has four
wires in each of the two directions - North and South (i.e. the total channel
is 8 wide). &nbsp;Likewise, there are four horizontal channels of wires with
four wires in each of the two directions - East,  and West.&nbsp; The wires
are all single  length, which means they span one CLB and need to be connected
to another wire in the next switch box.&nbsp;  The wires are unidirectional,
which means they can only be driven from one end. &nbsp;Within the channel
they alternate in direction.&nbsp; For example,  looking at a horizontal
channel the top wire flows in the east direction and is  indexed as the 0th
wire.&nbsp; The wire below that flows in the west direction  and is also
indexed 0.&nbsp; The wire below that flows in the east direction and  is
indexed 1.&nbsp; The trend continues for the entire channel.&nbsp; The part
 of the wire that is an input to the switch box is labeled the end of the wire.&nbsp;
 The part of the wire that is an output of the switch box is labeled the beginning.&nbsp;
 In the vertical direction, the left most wire flows in  the north direction 
and is indexed as the 0th wire.&nbsp; The diagram below  shows a graphical 
representation. &nbsp;To summarize the naming convention, there are three
parts to a name. &nbsp;The first is a one letter representation of the
direction. &nbsp;N for north, S for south, E for East, and W for west. &nbsp;The
second part represents which end of the wire is being referred to - BEG for
the beginning, END for the end. &nbsp;The last part is the index of the wire
within the channels - from 0 to 3.</p>
   
<p><img border="0" src="wires.JPG" width="354" height="278">
 </p>
   
<h3>Switch Box</h3>
   
<p>The connectivity between wires occurs in the switch box.&nbsp; Recall that
 only BEG wires (e.g. NBEG3) and the LUT inputs can be driven.&nbsp; They
can  only be driven by END wires (e.g. NEND3) and the LUT output.&nbsp; Each
wire can  be driven by wires with the same index that are not on the same
side of the  switch box.&nbsp; For example NBEG2 can be driven by NEND2, WEND2,
and EEND2.&nbsp;  Notice that it cannot be driven by SEND2 since they are
on the same side of the  switch box.&nbsp; Additionally every wire can be
driven by the LUT output.&nbsp;  The inputs to the LUT can be driven by any
END wire and not the LUT output.&nbsp; That is there is a 16  input mux for each of the LUT inputs
and a 4 input mux for each of the routing  resources.</p>
      
<h3>Bitstream Format</h3>
   
<p>The bitstream is organized into frames. &nbsp;Each frame is the configuration 
data for a single column of CLBs. &nbsp;In a real FPGA there would be several 
frames per column of CLBs. &nbsp;Within each frame there are four groups of
bits for the four CLBs in the column. &nbsp;Each CLB configuration data has
the same structure. &nbsp;Within the frame the most significant bit is the
most significant bit of row 0. &nbsp;The least significant bit is the least
significant bit of row 3. &nbsp;Within the CLB, the configuration data is
organized as follows (most significant bits listed first):<br>
 <br>
 NBEG0 - 3 bits representing the configuration of the mux (4 inputs plus
an OFF value).<br>
 NBEG1 - 3 bits representing the configuration of the mux (4 inputs plus
an OFF value).<br>
 NBEG2 - 3 bits representing the configuration of the mux (4 inputs plus
an OFF value).<br>
 NBEG3 - 3 bits representing the configuration of the mux (4 inputs plus
an OFF value).<br>
 SBEG0 - 3 bits representing the configuration of the mux (4 inputs plus
an OFF value).<br>
  SBEG1 - 3 bits representing the configuration of the mux (4 inputs plus 
an OFF value).<br>
  SBEG2 - 3 bits representing the configuration of the mux (4 inputs plus 
an OFF value).<br>
  SBEG3 - 3 bits representing the configuration of the mux (4 inputs plus 
an OFF value).<br>
 EBEG0 - 3 bits representing the configuration of the mux (4 inputs plus
an OFF value).<br>
  EBEG1 - 3 bits representing the configuration of the mux (4 inputs plus 
an OFF value).<br>
  EBEG2 - 3 bits representing the configuration of the mux (4 inputs plus 
an OFF value).<br>
  EBEG3 - 3 bits representing the configuration of the mux (4 inputs plus 
an OFF value).<br>
 WBEG0 - 3 bits representing the configuration of the mux (4 inputs plus
an OFF value).<br>
  WBEG1 - 3 bits representing the configuration of the mux (4 inputs plus 
an OFF value).<br>
  WBEG2 - 3 bits representing the configuration of the mux (4 inputs plus 
an OFF value).<br>
  WBEG3 - 3 bits representing the configuration of the mux (4 inputs plus 
an OFF value).<br>
 IN0 - 5 bits representing the configuration of the mux (16 inputs plus an 
OFF value).<br>
  IN1 - 5 bits representing the configuration of the mux (16 inputs plus
an OFF value).<br>
 IN2 - 5 bits representing the configuration of the mux (16 inputs plus an 
OFF value).<br>
  IN3 - 5 bits representing the configuration of the mux (16 inputs plus
an OFF value).<br>
 LUT &nbsp;- 16 bits representing the configuration of the LUT.<br>
</p>
<h3>CRC Calculation<br>
</h3>
<p>Upon readback, a 16 bit cyclic redundancy check (CRC) calculation is performed.
&nbsp;The generator polynomial is: <br>
CRC-16 = X<sup>16</sup> + X<sup>15</sup> + X<sup>2</sup> + 1<br>
</p>
<p>The configuration data is shifted in with the least significant bit first
as shown in the figure below.</p>
<p><img src="CRC.GIF" alt="" width="570" height="132">
 </p>
 
<hr width="100%" size="2">Project by <a
 href="mailto:eric_keller@earthlink.net">Eric Keller</a> for ECE655 - Fault
Tolerant Systems 8/7/2003   <br>
 <br>
</body>
</html>
