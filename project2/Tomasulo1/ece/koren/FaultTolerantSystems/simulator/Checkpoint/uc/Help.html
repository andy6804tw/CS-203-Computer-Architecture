<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="author" content="Chris K. Caldwell">
   <meta http-equiv="PICS-Label" content="(PICS-1.1">
   <meta name="description" content="The definitive pages on the Mersenne primes and the related mathematics!">
   <meta name="keywords" content="Mersenne, Mersennes, prime, primes, perfect numbers, number theory, mathematics">
   <meta name="GENERATOR" content="Mozilla/4.77 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
   <meta name="Author" content="Giyasettin OZCA">
   <meta name="Description" content="Help manulal for the applet">
   <meta name="KeyWords" content="Mersenne, Mersennes, prime, primes, perfect numbers, number theory, mathematics">
   <title>Uniprocessor CheckPointing.</title>
<!-- saved from url=(0049)http://www.utm.edu/research/primes/mersenne.shtml -->
<link rev=made 
href="mailto:caldwell@utm.edu">
</head>
<body text="#000000" bgcolor="#CCFFFF" link="#0000EE" vlink="#551A8B" alink="#FF0000">

<center>
<h3>
<b><font color="#CC33CC"><font size=+2>CheckPointing</font></font></b></h3></center>

<dl>
<dd>
<font size=+0>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#000000">Two
common forms of time redundancy in processors consist repeating an instruction
or a section of a program which has failed. These techniques require relatively
few hardware and software resources and have proved to be very efficient
against transient faults.</font></font></dd>

<dd>
&nbsp;</dd>

<dd>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Checkpointing
consist of saving the process state every so often. If the process fails,
it can be started from the last checkpoint, rather than having to go back
to the very beginning. Here, the issue is where to place the checkpoints
along the execution path, so that some measure of the performance is optimized.</dd>

<dd>
&nbsp;</dd>

<h4>
&nbsp;</h4>

<dl>
<h4>
<font color="#CC33CC"><font size=+1>Running the Applet</font></font></h4>
User will need to fill textboxes, shown in orange color.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; First textbox is&nbsp;&nbsp;
"Probability that fault is permanent". This is defined as S in the formulas
shown below.. As we know failure may be either transient&nbsp; or permanent.
It is a fact that
<br>Prob(failure is transient) + Prob(failure is permanent) = 1.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Second is&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: "Average Number of Instructions per program". This is defined as 'L'
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Third is&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: "Required setup time, when a permanent failure happens."&nbsp; This is
defined as delta1.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fourth is&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: "Required Diagnosis and repair time when a permanent failure happens".
This is defines as 'delta2'
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Second&nbsp; ScrollPane is
also an input field which consist of&nbsp; each instructions failure, recover
rates. Also time and frequnce values. Key point here is total frequnce
for all instructions should be 1.
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Finally output :
<br>Outputs are in an order way: P <sup>( C ) </sup>, P <sup>(RB1 ) </sup>,
P <sup>(RB2 ) </sup>and&nbsp; P <sup>(PF )&nbsp;</sup> , tau1, tau2 that
we tried to formulate below.
<br>&nbsp;</dl>

<dd>
<font color="#CC33CC">Some other variables that have been defined in the
formulas are </font>:</dd>

<dl>&nbsp;
<br>W&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -->&nbsp; Mean time spent for
one instruction . This can be found by addition of each instructions time
value multiplied by its frequence.
<br>M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -->&nbsp; Number of instructions
between two checkpoints. In this java applet it is limited by at most 10.
In real it may be 150 or more.
<br>delta1 -->&nbsp; Required setup time, which is a user input
<br>delta2 -->&nbsp; Required diagnosis and&nbsp; repair time., which was
an&nbsp;&nbsp; user input as well.
<br>f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -->&nbsp; Frequency
of a specific type of instruction.
<br>t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -->&nbsp;&nbsp; Time
cost of a specific type of instruction.
<br>tau1&nbsp;&nbsp;&nbsp; -->&nbsp;&nbsp; Required time for&nbsp; one
rollback run.
<br>tau2&nbsp;&nbsp;&nbsp; -->&nbsp;&nbsp; Required time for two rollback
run.
<br>&nbsp;</dl>

<dd>
The aim of this applet is finding probability measures for a process, which
may consist of at most 10 different instructions.&nbsp; If we define these
mutually exclusive events occuring during the execution of an instruction:</dd>

<ul>
<li>
H <sup>( C )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </sup>- The instruction
is completed successfully when first executed.</li>

<li>
H <sup>( RB1 )&nbsp; </sup>- The instruction fails and the failure is identified;
the instruction is completed successfully after the program rollback to
the last checkpoint.</li>

<li>
H <sup>( RB2 )&nbsp; </sup>- The instruction rolledback, but had a second
failure, rollbacked to the same checkpoint for the second time.</li>

<li>
H <sup>(PF )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </sup>- The instruction
fails and the failure is identified but the program rollback fails, resulting
in a program failure after which the program is reloaded and restarted.</li>
</ul>

<dd>
</dd>
</dl>

<dd>
We denote P <sup>( C ) </sup>, P <sup>(RB1 ) </sup>, P <sup>(RB2 ) </sup>and&nbsp;
P <sup>(PF )&nbsp;</sup>&nbsp; the probabilities of events H <sup>( C )
</sup>,
H <sup>(RB1 ) </sup>, H <sup>(RB2 ) </sup>and&nbsp; H <sup>(PF ) </sup>.</dd>

<dd>
These probabilities should satisfy: P <sup>( C ) </sup>+ P <sup>(RB1 )
</sup>+
P <sup>(RB2 ) </sup>+&nbsp; P <sup>(PF )&nbsp; </sup>= 1.</dd>

<dl>
<ul>
<ul>
<li>
We denote P<sub>0</sub>(lambda, t)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= e <sup>(-lambda * t );</sup></li>

<li>
We denote P<sub>00</sub>(lambda, &micro; , t)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= &micro; / ( &micro;+lambda ) +( lambda / ( &micro;+lambda ) ) *&nbsp;
e <sup>( (-lambda+&micro;) * t )</sup></li>

<li>
We denote P&macr;<sub>00</sub>(lambda, &micro;, t<sub>1</sub>, t)&nbsp;
=&nbsp; P<sub>00</sub>(lambda, &micro; , t) -&nbsp; e <sup>(-lambda * t<sub>1</sub>
) </sup>* P<sub>00</sub>(lambda, &micro; , t-t<sub>1</sub>)</li>
</ul>
</ul>

<dd>
</dd>
</dl>

<dd>
Let<font size=+1> </font>P<sub>i</sub> <sup>( C ) </sup>, P<sub>i</sub><sup>(RB1
) </sup>, P<sub>i</sub> <sup>(RB2 ) </sup>and&nbsp; P<sub>i</sub><sup>(PF
)&nbsp; </sup>denote the conditional probabilities of the above events,
given that the instruction is of type of i. Once these conditional probabilities
are calculated, the unconditional probabilities are obtained by averaging
over i with respect to f<sub>1</sub>, ....f<sub>N</sub></dd>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
P <sup>(J )&nbsp; </sup>= (&nbsp;&nbsp;&nbsp; f<sub>1</sub> * P<sub>1</sub><sup>(J
)</sup>&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp; f<sub>2</sub> * P<sub>2</sub><sup>(J
)</sup>&nbsp;&nbsp;&nbsp; +........+&nbsp;&nbsp;&nbsp; f<sub>N</sub> *
P<sub>N</sub><sup>(J )&nbsp;&nbsp;&nbsp;&nbsp; </sup>)&nbsp;&nbsp; where
(j = C,RB1,RB2,PF)
<p>We proceed now to calculate these conditional probabilities. First:
<br>&nbsp;
<blockquote>P<sub>i</sub> <sup>( C )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </sup>=&nbsp;
P<sub>0</sub>(lambda<sub>i </sub>, T <sub>i </sub>) = e
<sup>(- lambda<sub>i</sub>
* T<sub>i</sub> )</sup>
<p>P<sub>i</sub> <sup>(RB1 )&nbsp;&nbsp;&nbsp;&nbsp; </sup>=&nbsp; P&macr;<sub>00</sub>(
(1-S) * lambda<sub>i</sub>, &micro;<sub>i</sub>, t<sub>i</sub>, t<sub>i</sub>)
*&nbsp; P<sub>0</sub>(S*lambda<sub>i </sub>, T <sub>i </sub>) *&nbsp; (P<sub>i</sub><sup>(
C )</sup> / M)&nbsp;&nbsp; *&nbsp;&nbsp; ( ( (1 -P<sup> C </sup>)<sup>M
</sup>)/(1
-P<sup> C </sup>) )
<p>P<sub>i</sub> <sup>(RB2 )&nbsp;&nbsp;&nbsp; </sup>=&nbsp; P&macr;<sub>00</sub>(
(1-S) * lambda<sub>i</sub>, &micro;<sub>i</sub>, t<sub>i</sub>, t<sub>i</sub>)
*&nbsp; P<sub>0</sub>(S*lambda<sub>i </sub>, T <sub>i </sub>) * P<sub>i</sub><sup>(RB1
)</sup>
<p>P<sub>i</sub> <sup>(PF )&nbsp;&nbsp;&nbsp;&nbsp; </sup>=&nbsp; 1 - P<sub>i</sub><sup>(
C ) </sup>- P<sub>i</sub> <sup>( RB1 ) </sup>- P<sub>i</sub> <sup>(RB2
)</sup></blockquote>
If we denote T&not;&nbsp; =<sup> </sup>( f<sub>1</sub>*T<sub>1</sub> +
f<sub>2</sub>* T<sub>2</sub> +...+ f<sub>N</sub>* T<sub>N</sub>)
<p>Mean time required to successfully execute an instruction with a one
rollback will be :
<blockquote>tau1 =&nbsp; T&not;&nbsp; + P <sup>(RB1 ) </sup>* (delta1 +
((M+1)/2) * (T&not;)&nbsp;&nbsp; ) + P <sup>(PF )</sup>* (delta1 + ((M+1)/2)
* (T&not;) + delta2 +(L+1)*(W/2)&nbsp;&nbsp; )</blockquote>

<p><br>Mean time required to successfully execute an instruction with two
rollback will be :
<blockquote>tau2 =&nbsp; T&not;&nbsp; + P <sup>(RB1 ) </sup>* (delta1 +
((M+1)/2) * (T&not;)&nbsp;&nbsp; )+ P <sup>(RB2 )</sup>* ( (2* delta1)
+ (M+1)* (T&not;) )+ P <sup>(PF )</sup>* ( (2*delta1)+(M+1)* (T&not;) +
delta2 + (L+1)*(W/2) )
<br>&nbsp;</blockquote>

</body>
</html>
