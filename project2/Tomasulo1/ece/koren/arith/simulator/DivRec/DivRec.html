<HTML>
<HEAD>
<TITLE> Division by Reciprocation  </TITLE>
<SCRIPT language="JavaScript">

function PrintError(Message) {
        Error = "<CENTER><H1> ERROR </H1></CENTER> <P>\n"
        Error += "<CENTER> <EM>" + Message + "</EM> </CENTER>\n"
	Error += "<CENTER> <EM>" + NotBinaryNum + "</EM> </CENTER>\n"
        return Error
}

function ParseBinary (BinNum, NumDecs, String) {
        // Turns a binary number into a decimal, sets a flag to true if
        // BinNum is not actually binary

        IsNeg = false
        if (BinNum < 0) { //BinNum are stored in strings as positive bin nums
				//with a negative sign at the start.
                IsNeg = true
                BinNum *= -1
        }
        RealNum = 0
        LogBaseTen = Math.log(BinNum)/Math.LN10
        HighestPlace = Math.ceil(LogBaseTen)
        for (CurPlace = HighestPlace; CurPlace >= -NumDecs; CurPlace--) {
                CurEntry = Math.round(BinNum / Math.pow(10, CurPlace))
                if (CurEntry != 0 && CurEntry != 1) {
                        NotBinary = true
			NotBinaryNum = String //to tell the user which number is						 //not being accepted
                        CurEntry = 1 // feed it something normal, to avoid
                                         // wierd Javascript errors
                }
                if (CurEntry == 1) {
                        RealNum += Math.pow(2, CurPlace)
                        BinNum -= Math.pow(10, CurPlace )
                }
        }
        if (IsNeg) {RealNum *= -1} // reverse it back at the end

        // now check if the number was negative according to two's complement
        // representation - if it was, set the decimal value to this negative
        // number
        if (HighestPlace == NumDecs) {
                RealNum -= Math.pow(2, NumBits)
        }

        return RealNum
}

function RoundOff (TheNum, NumDecs) {
        // returns the value TheNum would have if it were represented by
	//NumDecs bits after the decimal point
        Scaling = Math.pow(2, NumDecs)
        return (Math.round(TheNum * Scaling) / Scaling)
}


function OrderOfMagnitude (TheNum) {
        // returns the highest place which has a "1" in TheNum's
        // binary representation - special non-2's complement version

        LogBaseTwo = Math.log(TheNum)/Math.LN2;
        return Math.floor(LogBaseTwo)
}

function PrintBinary(TheNum, NumDecs) {

        // initialize the string
        S = "";
        // deal with negative numbers
        if (TheNum < 0) {
                S += "-"
                TheNum *= -1
        }
        StartPlace = OrderOfMagnitude(TheNum)
        if (StartPlace < 0) {StartPlace = 0}

        for (CurPlace = StartPlace; CurPlace >= -NumDecs; CurPlace--) {
                if (CurPlace == -1) {S += "."}
                CurPower = Math.pow(2, CurPlace)
                if (TheNum >= CurPower) {
                        S += "1"
                        TheNum -= CurPower
                } else  {
                        S += "0"
                }
        }
        return S
}

function GetInterval(TheNum ) {
	TheInterval = Math.floor( (TheNum - 0.5) * (Math.pow(2, (NumInBitsROM + 1)))) + 1
        return TheInterval
	}

function Calc_x0(TheInterval){
	x0 = Math.pow(2, NumInBitsROM + 1)/ (Math.pow(2, NumInBitsROM) + TheInterval- 0.5) 
	return x0 
          
	}


function DivRecip(form) {
        N = parseFloat(form.N.value)
        D = parseFloat(form.D.value)
        ChoseBin = form.Base[0].checked
        NumDecimals = parseFloat(form.NumDecimals.value)
        NumInBitsROM = parseFloat(form.NumInBitsROM.value)
	NumOutBitsROM = parseFloat(form.NumOutBitsROM.value)
        NumBits = NumDecimals
	OutputPrecision = Math.max(NumOutBitsROM, NumDecimals)
        NotBinary = false
	NotBinaryNum = 0
        if (ChoseBin) {
                N = ParseBinary(N, NumDecimals, "N")
                D = ParseBinary(D, NumDecimals, "D")
        }
        

//Set Flags to generate necessary ERROR messages

	RealQuotient =  N/D
        Fractions = (Math.abs(N) < 1 & Math.abs(D) < 1 & Math.abs(D) >= 0.5)
        NegD = (D < 0)
        DivByZero = (D == 0)




        Top = "<HTML><HEAD><TITLE>Tablet</TITLE></HEAD><BODY bgcolor=white>"
	
	Middle ="In Binary :" + "<BR>\n"
	Middle += "N = " + PrintBinary(N, NumDecimals) + "<BR>\n"
	Middle +=  "D = " + PrintBinary(D, NumDecimals) + "<BR>\n"
	Middle += "<BR>\n"
	Middle +="In Decimal:" + "N = " + N + ", D = " + D + "<P>\n" 

        k = GetInterval(D)
        xnext = Calc_x0( k) // Determine the value of x0 for D 
	xnextbin = PrintBinary(xnext, NumOutBitsROM)

	Middle += "Size of ROM is 2" + "<sup>"+ NumInBitsROM+ " </sup>" + "x" + NumOutBitsROM + "<BR>\n" 	
	Middle += "Desired ROM Table entry for D = " + PrintBinary(D, NumInBitsROM) + "<BR>\n"
 	Middle += "is x0 = " + xnextbin + "<BR>\n"	
	Middle += "= " + ParseBinary(xnextbin, NumOutBitsROM, "xnextbin") + "<BR>\n" 

// Print the table to show successive iteration values
	
	Middle += "<TABLE border>"
	Middle += "<TR><TD> <var>x <sub> i </sub> </var></TD> <TD> value </TD></TR>"
 	xiCol = " "
	valCol = " "

/*  Calculates the values of 1/D by the Newton Raphson Method until successive approximations are equal */
	i = 0	
	deltaI = Math.abs(1/D - ParseBinary(xnextbin, NumOutBitsROM,"line 157" ))
	Middle += "|1/D -  x0| = " + deltaI + "<BR>\n"
/* Declare and initialize xprev so that you can use it in the eq., StopIterations - otherwise it'll give a not declared  error!!
*/
	StopIterations = 0
	xnextbin = PrintBinary(ParseBinary(xnextbin,NumOutBitsROM,"itertableval") , OutputPrecision) //this is the x0 entry in //the iteration values table. Print x0 in same precision as x1,x2 etc.

	Middle += "xnextbin just before 167 = " + xnextbin + "<BR>\n"

	while(StopIterations == 0){
	xprevbin = xnextbin
	xiCol += "<var>x</var>" +  i + "<BR>\n"
	valCol += xprevbin + "<BR>\n"
	xnext = ParseBinary(xprevbin,OutputPrecision, "line 167,1")*(2 - D*(ParseBinary(xprevbin,OutputPrecision , "line 167,2")))//MSSP - 24 TBC to OutputPrecision
	xnextbin = PrintBinary(xnext, OutputPrecision)
	i++
	
	deltaInext = D*deltaI*deltaI
        StopIterations = (deltaInext < Math.pow(2, -NumOutBitsROM))|| (i == Math.ceil(Math.log(NumDecimals)/Math.LN2))
	deltaI = deltaInext
	}

	xiCol += "<var>x</var>" + i + "<BR>\n"
	valCol += xnextbin + "<BR>\n"
	Middle += "<TR> <TD> " + xiCol + "</TD><TD align=right> " + valCol + "</TD></TR><BR>\n"
        Middle += "</TABLE> <P>\n"
	Middle += "<BR>\n"

	xnextdec = ParseBinary(xnextbin, OutputPrecision, "line 182")
	DivByRecipError = Math.abs(RealQuotient - N*xnextdec)
        DBRErrorBin = PrintBinary(DivByRecipError, 32)
        Middle += "1/D from Newton Raphson method = " + xnextbin  + "<BR>\n"
	Middle += "= " + ParseBinary(xnextbin, OutputPrecision, "line 185") + " In decimal" + "<BR>\n"
	Middle += "<BR>\n"
        Middle += "Quotient = " + "N*1/D" + "<BR>\n"
        Middle += "= " + PrintBinary(N, NumDecimals) + "*" + xnextbin 
	Middle += "= " + PrintBinary(N*xnextdec, OutputPrecision) + "<BR>\n"
	Middle += "= " + N*xnextdec + "<BR>\n" 
	Middle += "<BR>\n"
	Middle += "Actual Value = " + PrintBinary(RealQuotient, 32) + "<BR>\n"
	Middle += "= " + N/D + "<BR>\n" 
	Middle += "<BR>\n"
	Middle += "Error = " + PrintBinary(DivByRecipError, 32) +"<BR>\n" 
	Middle += "= " + DivByRecipError + "actual value In decimal" + "<BR>\n"

        Bottom = "</BODY> </HTML>"

        if (! Fractions) {Middle = PrintError("Only fractions allowed")}
        if (NegD) {Middle = PrintError ("D can't be negative")}
        if (DivByZero) {Middle = PrintError ("Divide by zero")}
        if (NotBinary) {Middle = PrintError("At least one non-binary number") + NotBinaryNum}

        parent.frames[1].document.open()
        parent.frames[1].document.write(Top);
        parent.frames[1].document.write(Middle);
        parent.frames[1].document.write(Bottom);
        parent.frames[1].document.close()

}


</SCRIPT>
</HEAD>

<BODY bgcolor="#FFFF7C">

<CENTER> <H2> Division by Reciprocation </H2> </CENTER>
<FORM>
N (Enter a fraction): <INPUT type="text" name="N" >
<P>
D (Enter a fraction between 0.5 and 1.0): <INPUT type="text" name="D" >
<P>
<EM>bin</EM> <INPUT type="radio" name="Base" value="Binary" checked>
<EM>dec</EM> <INPUT type="radio" name="Base" value="Decimal">
<P>
No. of bits:
<INPUT type="text" name="NumDecimals" >
<P>
No. of input bits to ROM :
<INPUT type="text" name="NumInBitsROM" >
<P>
No. of output bits from ROM:
<INPUT type="text" name="NumOutBitsROM" >
<P>
<CENTER>
<INPUT type="button" name="enter" value="Compute"
onClick="DivRecip(this.form)">
<P>
<INPUT type="button" value="Help"
onClick=parent.frames[1].location.href="help.html">

</CENTER>
</FORM>

</BODY>
</HTML>

