<HTML>
<HEAD>
<TITLE> Radix-2 SRT Divison </TITLE>
<SCRIPT language="JavaScript">

function MakeLine(NumColumns) {
	return "<TR> <TD colspan=" + NumColumns + "> <HR noshade size=1>\n";
}

function PrintError(Message) {
	Error = "<CENTER><H1> ERROR </H1></CENTER> <P>\n"
	Error += "<CENTER> <EM>" + Message + "</EM> </CENTER>\n"
	return Error
}

function ParseBinary (BinNum) {
	// Turns a binary number into a decimal, sets a flag to true if
	// BinNum is not actually binary

	IsNeg = false
	if (BinNum < 0) {
		IsNeg = true
		BinNum *= -1
	}
	RealNum = 0
	LogBaseTen = Math.log(BinNum)/Math.LN10
	HighestPlace = Math.ceil(LogBaseTen)
	for (CurPlace = HighestPlace; CurPlace >= -NumBits; CurPlace--) {
		CurEntry = Math.round(BinNum / Math.pow(10, CurPlace))
		if (CurEntry != 0 && CurEntry != 1) {
			NotBinary = true
			CurEntry = 1 // feed it something normal, to avoid
					 // wierd Javascript errors
		}
		if (CurEntry == 1) {
			RealNum += Math.pow(2, CurPlace)
			BinNum -= Math.pow(10, CurPlace)
		}
	}
	if (IsNeg) {RealNum *= -1} // reverse it back at the end

	// now check if the number was negative according to two's complement
	// representation - if it was, set the decimal value to this negative
	// number
	if (HighestPlace == NumBits) {
		RealNum -= Math.pow(2, NumBits)
	}

	return RealNum
}

function OrderOfMagnitude (TheNum) {
	// returns the highest place which has a "1" in TheNum's
	// binary representation

        TheNum += Math.pow(10, -1 - NumBits) // kludge so processor
                                            // won't mess up

	// to account for 2's complement representation...
	TheNum < 0 ? TheNum *= -2 : TheNum *= 2


	LogBaseTwo = Math.log(TheNum)/Math.LN2;
	return Math.floor(LogBaseTwo)
}

function TwosComp(TheNum, StartPlace) {
	NumStarted = false;
	NumDigits = StartPlace + NumDecimals + 1;

	// first deal with negative numbers...
	if (StartPlace < 0) {StartPlace == 0}
	if (TheNum < 0) {TheNum += Math.pow(2, StartPlace + 1)}

	// now initialize the string
	S = "";
	for (TheDigit = 1; TheDigit <= NumDigits; TheDigit++) {
		CurPlace = NumDigits - NumDecimals - TheDigit;
		if (CurPlace == 0) {NumStarted = true}
		if (CurPlace == -1) {S += "."}
		CurPower = Math.pow(2, CurPlace);
		if (TheNum >= CurPower) {
			NumStarted = true;
			S += "1";
			TheNum -= CurPower
		} else if (NumStarted) {
			S += "0";
		} // otherwise, print nothing
	}
	return S;
}

function RoundOff (TheNum) {
	// returns the value TheNum would have if it were represented by
	// NumDecimals bits after the decimal point
	Scaling = Math.pow(2, NumDecimals)
	return (Math.round(TheNum * Scaling) / Scaling)
}

function PrintTwosComp(TheNum, StartPlace) {

	if (StartPlace < 0) {StartPlace = 0}
	// first deal with negative numbers...
	if (TheNum < 0) {TheNum += Math.pow(2, StartPlace + 1)}

	// now initialize the string
	S = "";
	for (CurPlace = NumCols - NumDecimals; CurPlace > StartPlace; CurPlace--) {
		S += "<TD> "
	}
	for (CurPlace = StartPlace; CurPlace >= -NumDecimals; CurPlace--) {
		S += "<TD> ";
		if (CurPlace == -1) {
			S += ".";
		}
		CurPower = Math.pow(2, CurPlace);
		if (TheNum >= CurPower) {
			S += "1 ";
			TheNum -= CurPower
		} else {S += "0 "} 
	}
	return S;
}

function SRT(form) {
	X = parseFloat(form.X.value)
	D = parseFloat(form.D.value)
	// Global variables... assigned from within a procedure...
	// JavaScript is pretty cool!

	NumBits = parseInt(form.NumBits.value)
	ChoseBin = form.Base[0].checked
	NotBinary = false
	if (ChoseBin) {
		X = ParseBinary(X)
		D = ParseBinary(D)
	}
	NumDigits = Math.max(OrderOfMagnitude(X), OrderOfMagnitude(D)) + 1
	if (NumDigits < 1) {NumDigits = 1}
	NumDecimals = NumBits - NumDigits
	NumCols = NumDecimals + NumDigits

	TheTop = "<HTML><HEAD><TITLE>Tablet</TITLE></HEAD><BODY bgcolor=white>"
	X = RoundOff(X)
	D = RoundOff(D)
	Middle = "X = " + X + ", D = " + D + "<P>\n"
	Middle = "<TABLE>"

	Q = 0;
	r = X;
	ZeroRem = false

	Middle += "<TR> <TD> r<SUB>0</SUB> = X <TD>";
	Middle += PrintTwosComp(r, OrderOfMagnitude(r) + 1);
	Middle += "<TD>\n"

	for (i = 0; i < NumDecimals; i++) {
		// "qi" is a horrible misnomer because it's actually
		// q(i + 1).
		LessThanHalf = Math.abs(2 * r) < 1/2
		EqualsHalf = Math.abs(2 * r) == 1/2
		LessThanHalf ? qi = 0 : r / D >= 0 ? qi = 1 : qi = -1
                if (EqualsHalf && qi == -1) { qi = 0 }
		SumSize = Math.max (OrderOfMagnitude(2 * r),
					  Math.max(OrderOfMagnitude(D * qi * -1),
						     OrderOfMagnitude(2 * r - qi * D)))
		// alert ("SumSize is now " + SumSize)
		// 1st line
		Middle += "<TR> <TD> 2r<SUB>" + i + "</SUB>"
		if (qi == 0) {
 			Middle += " =&gt; r<sub>" + (i+1) + "</sub>"
		}
		Middle += "<TD>"
		Middle += PrintTwosComp(2 * r, SumSize);
		Middle += "<TD> "
		if (LessThanHalf) {
			Middle += (r >= 0 ? "< 1/2 " : ">= -1/2 ")
		} else {
			if (EqualsHalf) {
				Middle += ">= -1/2"
			} else {
				Middle += (r > 0 ? ">= 1/2 " : "< -1/2 ")
			}
		}
		// Middle += " (r = " + r + ") "
		// if (LessThanHalf) Middle += " (LessThanHalf) "
		// if (EqualsHalf) Middle += " (EqualsHalf) "
		Middle += "set q<SUB>" + (i + 1) + "</SUB> = ";
		Q += Math.pow(2, -i - 1) * qi;
		Middle += qi + "\n";

		// 2nd line - printed only if qi is 1 or -1
		if (qi != 0) {
			Middle += "<TR> <TD> Add "
			if (qi == 1) {Middle += "-";}
			Middle += "D <TD> + ";
			Middle += PrintTwosComp(D * qi * -1, SumSize);
			Middle += "<TD>\n"
			Middle += MakeLine(NumCols + 3);
		}
		r = RoundOff(2 * r - qi * D)

		// 3rd line - printed only if qi is 1 or -1
		if (qi != 0) {
			Middle += "<TR> <TD> r<SUB>" + (i + 1) + "</SUB> "
		// if (qi == 0) {Middle += "= 2r<sub>" + i + "</sub> "}
			Middle += "<TD> " + PrintTwosComp(r, SumSize) + "<TD>"
		}
	}

	Middle += "</TABLE> <P>\n";
	Middle += "Q = " + TwosComp(Q, 0) + " = " + Q + "<BR>\n"
	if (r/D < 0) { // if sign is different
		ulp = Math.pow(2, -NumDecimals)
		Middle += "R<i><sub>corrected</sub></i> = r<sub>" + i + "</sub>"
		if (Q/D > 0 || ZeroRem) {
			Middle += " + D = " + TwosComp(r, 0) + " + " +
			TwosComp(D, 0) + " = " + TwosComp(r + D, 0) + " = " +
			(r + D) + "<BR>\n"
			Middle += "Q<i><sub>corrected</sub></i> = Q - <i>ulp</i> = " +
			TwosComp(Q, 0) + " - " + TwosComp(ulp, 0) + " = " +
			TwosComp(Q - ulp, 0) + " = " + (Q - ulp)
		} else {
			Middle += " - D = " + TwosComp(r, 3) + " - " +
			TwosComp(D, 0) + " = " + TwosComp(r - D, 0) + " = " +
			(r - D) + "<BR>\n"
			Middle += "Q<i><sub>corrected</sub></i> = Q + <i>ulp</i> = " +
			TwosComp(Q, 0) + " + " + TwosComp(ulp, 3) + " = " +
			TwosComp(Q + ulp, 0) + " = " + (Q + ulp)
		}

	}
	Bottom = "</BODY> </HTML>";

	if (NumDecimals < 0) {Middle = PrintError("Overflow")}
	if (X > D) {Middle = PrintError("X cannot be larger than D")}
	if (D == 0) {Middle = PrintError("Divide by zero")}
	if (NotBinary) {Middle = PrintError("At least one non-binary number")}

	parent.frames[1].document.open()
	parent.frames[1].document.write(TheTop);
	parent.frames[1].document.write(Middle);
	parent.frames[1].document.write(Bottom);
	parent.frames[1].document.close()

}

</SCRIPT>
</HEAD>

<BODY bgcolor="#FFFF7C">

<CENTER> <H2> SRT Radix-2 Division </H2> </CENTER>
<FORM>
X: <INPUT type="text" name="X">
<P>
D: <INPUT type="text" name="D">
<P>
<EM>bin</EM> <INPUT type="radio" name="Base" value="Binary" checked>
<EM>dec</EM> <INPUT type="radio" name="Base" value="Decimal">
<P>
Number of bits:<BR>
<INPUT type="text" name="NumBits">
<P>
<CENTER>
<INPUT type="button" name="enter" value="Compute"
onClick="SRT(this.form)">
</CENTER>
</FORM>

</BODY>
</HTML>
