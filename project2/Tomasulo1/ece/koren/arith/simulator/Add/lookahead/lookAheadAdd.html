<HTML>
<HEAD>
<TITLE> Carry Look Ahead Adder with Timing</TITLE>
<SCRIPT language="JavaScript">

function MakeLine(NumColumns) 
{
	return "<TR> <TD colspan=" + NumColumns + "> <HR noshade size=1>\n";
}

function PrintError(Message) 
{
	Error = "<CENTER><H1> ERROR </H1></CENTER> <P>\n"
	Error += "<CENTER> <EM>" + Message + "</EM> </CENTER>\n"
	return Error
}

function IsInteger(Num) 
{
	return (Num == Math.floor(Num))
}

function OrderOfMagnitude (TheNum) 
{
	// returns the highest place which has a "1" in TheNum's
	// binary representation

	// to account for 2's complement representation...
	//alert ("TheNum is now " + TheNum)
	TheNum < 0 ? TheNum = (TheNum * -2) - 2 : TheNum *= 2
	//alert ("TheNum is now " + TheNum)

	LogBaseTwo = Math.log(TheNum)/Math.LN2;
	return Math.floor(LogBaseTwo)
}

function ParseBinary (BinNum) 
{
	// Turns a binary number into a decimal, sets a flag to true if
	// BinNum is not actually binary

	IsNeg = false
	if (BinNum < 0) 
	{
		IsNeg = true
		BinNum *= -1
	}
	RealNum = 0
	BinNum += Math.pow(10, -1 - NumBits) // kludge so processor
					     // won't mess up
	LogBaseTen = Math.log(BinNum)/Math.LN10
	HighestPlace = Math.ceil(LogBaseTen)
	for (CurPlace = HighestPlace; CurPlace >= -NumBits; CurPlace--) 
	{
		CurEntry = Math.floor(BinNum / Math.pow(10, CurPlace))
		if (CurEntry != 0 && CurEntry != 1) 
		{
			NotBinary = true
			CurEntry = 1 // feed it something normal, to avoid
					 // wierd Javascript errors
		}
		if (CurEntry == 1) 
		{
			RealNum += Math.pow(2, CurPlace)
			BinNum -= Math.pow(10, CurPlace)
		}
	}
	if (IsNeg) {RealNum *= -1} // reverse it back at the end

	// now check if the number was negative according to two's complement
	// representation - if it was, set the decimal value to this negative
	// number
	if (HighestPlace == NumBits)
		RealNum -= Math.pow(2, NumBits)

//	if (HighestPlace == 1)
//		RealNum -= Math.pow(2, 1)

	return RealNum
}

function RoundOff (TheNum) 
{
	// returns the value TheNum would have if it were represented by
	// NumDecimals bits after the decimal point
	Scaling = Math.pow(2, NumDecimals)
	return (Math.floor(TheNum * Scaling) / Scaling)
}



function PrintTwosComp(TheNum, StartPlace) 
{

	// first deal with negative numbers...
	if (TheNum < 0) {TheNum += Math.pow(2, StartPlace)}

	// now initialize the string
	S = "";
	S += "<TD> ";
	for (CurPlace = StartPlace - 1; CurPlace >= -NumDecimals; CurPlace--) 
	{
		if (CurPlace == -1) 
		{
			S += ".";
		}
		CurPower = Math.pow(2, CurPlace);
		if (TheNum >= CurPower) 
		{
			S += "1 ";
			TheNum -= CurPower
		} 
		else 
		{
			S += "0 "
		} 
	}
	return S;
}


function FeedIntoVariable(TheNum, StartPlace, ReturnArray) 
{
	if (TheNum < 0) {TheNum += Math.pow(2, StartPlace)}

	// now initialize the string
	index = StartPlace - 1
	for (CurPlace = StartPlace - 1; CurPlace >= -NumDecimals; CurPlace--) 
	{
		if (CurPlace == -1) 
		{
			ReturnArray[index] = 2;
			index --
		}
		CurPower = Math.pow(2, CurPlace);
		if (TheNum >= CurPower) 
		{
			ReturnArray[index] = 1;
			index --
			TheNum -= CurPower
		} 
		else 
		{
			ReturnArray[index] = 0;
			index --;
		} 
	}
	return ReturnArray
}


function PrintSumCarry(Middle)
{
	Middle += MakeLine(NumCols + 3)
    Middle += "<TR><TD><TD>"
    Middle += "<TR><TD>Carry     :    <TD><TD>" 
	for (loop=NumDigits;loop>=1;loop--)
 		Middle += " " + FinalCarry[loop];
	Middle += "<TR><TD>Generate     :    <TD><TD>" 
	for (loop=NumDigits-1;loop>=0;loop--)
 		Middle += " " + Generate[loop];
	Middle += "<TR><TD>Propagate     :    <TD><TD>" 
	for (loop=NumDigits-1;loop>=0;loop--)
 		Middle += " " + Propagate[loop];
    Middle += "<TR><TD>Sum       :    <TD><TD>"
	for (loop=NumDigits-1;loop>=0;loop--)
		Middle += " " + FinalSum[loop]
	

	return Middle
}


//Next function returns the larger of two numbers
function GetMax(Number1, Number2)
{
	if (Number1 > Number2)
		bigger = Number1
	else
		bigger = Number2

	return bigger
}


//Next function returns the smaller of two numbers
function GetMin(Number1, Number2)
{
	if (Number1 < Number2)
		smaller = Number1
	else
		smaller = Number2

	return smaller
}


//Next function returns the time needed to Calculate the Sum-time of this adder block
function CalculateSumTime(AToSum, CinToSum, PrevCarryTime)
{
	if (PrevCarryTime == 0)
		finalTime = GetMax(AToSum, CinToSum)
	else
	{
		if (CinToSum > AToSum)
			finalTime = PrevCarryTime + CinToSum
		else
		{
			if (PrevCarryTime < AToSum)
			{
				difference = AToSum - CinToSum
				finalTime = GetMax(difference, CinToSum) + PrevCarryTime
			}
			else
				finalTime = CinToSum + PrevCarryTime
		}
	}

	//Cross-checking for trivial case
	if (finalTime < AToSum)
		finalTime = AToSum
	if (finalTime < CinToSum)
		finalTime = CinToSum

	return finalTime	
}


//Next function returns the time needed to Calculate the Carry-time of this adder block
function CalculateCarryTime(AToCout, CinToCout, PrevCarryTime)
{
	if (PrevCarryTime == 0)
		CarryOutTime = GetMax(AToCout, CinToCout)
	else
	{
		if (CinToCout > AToCout)
			CarryOutTime = PrevCarryTime + CinToCout
		else
		{
			if (PrevCarryTime < AToCout)
			{
				difference = AToCout - CinToCout
				CarryOutTime = GetMax(difference, CinToCout) + PrevCarryTime
			}
			else
				CarryOutTime = CinToCout + PrevCarryTime
		}
	}

	//Cross-checking for trivial case
	if (CarryOutTime < AToCout)
		CarryOutTime = AToCout
	if (CarryOutTime < CinToCout)
		CarryOutTime = CinToCout

	return CarryOutTime	
}




function CarryLookAheadAdd(form) 
{
	TheTop = "<HTML><HEAD><TITLE>Tablet</TITLE></HEAD><BODY bgcolor=white>";
	
	A = parseFloat(form.A.value)
	B = parseFloat(form.B.value)

	GroupSize = parseInt(form.GroupSize.value)
//	GateDelay = parseFloat(form.GateDelay.value)
	AndOrDelay = parseFloat(form.AndOrDelay.value)
	XorDelay = parseFloat(form.XorDelay.value)
	FanIn = parseFloat(form.FanIn.value)

	ChoseBin = form.Base[0].checked
	ChoseDec = form.Base[1].checked
	NumBits = parseInt(form.NumBits.value)
	NotBinary = false
	if (ChoseBin) 
	{
		A = ParseBinary(A)
		B = ParseBinary(B)
	}


	Mixed = false
	Overflow = false
	FractionalNum = (Math.abs(A) < 2) && (Math.abs(B) < 2)
	// bit to left of dec. pt. is sign bit 
	if (IsInteger(A) & IsInteger(B)) 
	{
		NumDecimals = 0
		NumDigits = NumBits
		if (Math.max(OrderOfMagnitude(A), OrderOfMagnitude(B)) + 1 > NumDigits) 
		{
			NumDigits = 0
			NumDecimals = 0
			Overflow = true
		}
	} 
	else 
	{
		if (FractionalNum) 
		{
			NumDigits = 1
			NumDecimals = NumBits - 1
		} 
		else 
		{
			Mixed = true
			NumDigits = 0
			NumDecimals = 0    // just filler values 
		}
	}

	NumCols = (2 * NumDigits - 1) + NumDecimals

	NumberOfCla0Blocks = Math.ceil(NumDigits/GroupSize)
	NumberOfCla1Blocks = Math.ceil(NumberOfCla0Blocks/GroupSize)

	A = RoundOff(A)
	B = RoundOff(B)

	Middle = "<TABLE>"

	// now initialize two Input Arrays & two 
	// output arrays & two intermediate arrays
	FirstNumber = new Array(NumDigits)
	FeedIntoVariable(A, NumDigits,FirstNumber)
	SecondNumber = new Array(NumDigits)
	FeedIntoVariable(B, NumDigits,SecondNumber)

	Generate = new Array(2*NumDigits)
	Propagate = new Array(2*NumDigits)
	GenerateStar = new Array(NumDigits)
	PropagateStar = new Array(NumDigits)
	FinalCarry = new Array(NumDigits)
	FinalSum = new Array(NumDigits)
	SumTime = new Array(NumDigits * 2)
	CarryTime = new Array(NumDigits * 2)
	BasicCarryTime = new Array(GroupSize * 2)
	BasicSumTime = new Array(GroupSize * 2)

		
	//calculate G, P
	for (index=0;index < 2 * NumDigits;index++)
		Propagate[index] = 1

	for (index=0;index < NumDigits;index++)
	{
		Generate[index] = FirstNumber[index] & SecondNumber[index]
		Propagate[index] = FirstNumber[index] | SecondNumber[index]
		FinalCarry[index] = 0
	}

	//calculate G*, P*
	for (countStar=0;countStar < NumberOfCla0Blocks;countStar++)
	{
		PropagateStar[countStar] = 1
		done=0;
		countBasic = countStar * GroupSize
		while (done == 0)
		{
			if ( (countBasic == NumDigits) || (countBasic == ((countStar+1) * GroupSize)) )
				done=1;
			else
			{
				PropagateStar[countStar] = PropagateStar[countStar] & Propagate[countBasic]
				countBasic++
			}
		}
	}
	for (countStar=0;countStar < NumberOfCla0Blocks;countStar++)
	{
		GenerateStar[countStar] = 0
		done=0;
		startLocation = countStar * GroupSize
		endLocation = (countStar+1) * GroupSize
		for (countBasic=startLocation;countBasic < endLocation;countBasic++)
		{
			finalResult = Generate[countBasic]
			for (loop = countBasic+1; loop < endLocation; loop++)
				finalResult = finalResult & Propagate[loop]


			GenerateStar[countStar] = GenerateStar[countStar] | finalResult
		
			if (countBasic == (NumDigits-1))	//terminate the operation
				countBasic = endLocation
		}
	}

	for (index=1;index <= NumDigits;index++)
	{
		FinalCarry[index] = 0
		lastCarry = 0
		
		for (Pcounter=1;Pcounter <= index; Pcounter++)
		{
			tempCarry = Generate[Pcounter-1]
			for (count=Pcounter;count < index;count++)
				tempCarry = tempCarry & Propagate[count]

			lastCarry = lastCarry | tempCarry
		}
		FinalCarry[index] = lastCarry		
	}

	for (counter = 0; counter < NumDigits; counter++) 
		FinalSum[counter] = FirstNumber[counter] ^ SecondNumber[counter] ^ FinalCarry[counter];

	
	// Print A & B values above Adder Block
	Middle += "<PRE>"
	Middle += "<BR>"
	Middle += "<IMG SRC = ./../images/blank.gif>"

	//print the incoming bits files
	for (counter = NumDigits-1; counter >= NumDecimals; counter--) 
	{
		if ((FirstNumber[counter] == 0) && (SecondNumber[counter] == 0))
			Middle += "<IMG SRC = ./../images/00.gif>"
		if ((FirstNumber[counter] == 0) && (SecondNumber[counter] == 1))
			Middle += "<IMG SRC = ./../images/01.gif>"
		if ((FirstNumber[counter] == 1) && (SecondNumber[counter] == 0))
			Middle += "<IMG SRC = ./../images/10.gif>"
		if ((FirstNumber[counter] == 1) && (SecondNumber[counter] == 1))
			Middle += "<IMG SRC = ./../images/11.gif>"
	}
	Middle += "<BR>" 
	Middle += "<IMG SRC = ./../images/blank.gif>"

	for (counter = NumDigits; counter >= NumDecimals+1; counter--)
	{
		if (counter != NumDigits)
			Middle += "<IMG SRC = ./lookgif/cin.gif>"

		Middle += "<IMG SRC = ./../images/plusbox.gif>"
	}
	Middle += "<IMG SRC = ./../images/carry0.gif>"

	Middle += "<BR>"

	// Print G , P and SUM values below Adder Block
	Middle += "<BR>" 
	Middle += "<IMG SRC = ./../images/blank.gif>"
	for (counter = NumDigits-1; counter >= NumDecimals; counter--) 
	{
		//Print generate arrow
		if (Generate[counter] == 1)
			Middle += "<IMG SRC = ./lookgif/GP_L0_1.gif>"
		else
			Middle += "<IMG SRC = ./lookgif/GP_L0_0.gif>"
		
		//Print propagate arrow
		if (Propagate[counter] == 1)
			Middle += "<IMG SRC = ./lookgif/GP_L0_1.gif>"
		else
			Middle += "<IMG SRC = ./lookgif/GP_L0_0.gif>"


		//Print final sum arrow
		if (FinalSum[counter] == 1)
			Middle += "<IMG SRC = ./lookgif/sum_1.gif>"
		else
			Middle += "<IMG SRC = ./lookgif/sum_0.gif>"


		//Print blank gif between two basic adder blocks
		if (counter != 0)
		{
			if (FinalCarry[counter] == 0)
				Middle += "<IMG SRC = ./lookgif/vertical_0.gif>"
			else
				Middle += "<IMG SRC = ./lookgif/vertical_1.gif>"
		}

		//if (counter != 0)
		//	Middle += "<IMG SRC = ./lookgif/vertical.gif>"
	}

	//Print the first level CLAs
	Middle += "<BR>" 
	Middle += "<IMG SRC = ./../images/blank.gif>"
	newBlockStart=1;
	for (counter = NumDigits-1; counter >= NumDecimals; counter--) 
	{
		if (newBlockStart == 1)
		{
			if ((counter %  GroupSize) == 0)  //Single member CLA
			{
				Middle += "<IMG SRC = ./lookgif/cla_total.gif>"
				newBlockStart = 1
			}
			else		//This CLA has multiple members
			{
				Middle += "<IMG SRC = ./lookgif/cla_start.gif>"
				newBlockStart = 0
			}
		}
		else
		{
			if ((counter % GroupSize) == 0)  //End of a block
			{
				Middle += "<IMG SRC = ./lookgif/cla_finish.gif>"
				newBlockStart = 1
			}
			else  //Middle of a block
				Middle += "<IMG SRC = ./lookgif/cla_mid.gif>"
		}

		//Print the middle portion of block
		if (newBlockStart == 0)      // A CLA is being continued
			Middle += "<IMG SRC = ./lookgif/cla_blank.gif>"
		else	//New CLA will be started				 
		{
			if (counter != 0)        //Not the 0-th CLA, so, Cout is needed
				Middle += "<IMG SRC = ./lookgif/cla_cin_cout.gif>"

		}
	}
	Middle += "<IMG SRC = ./../images/carry0.gif>"


	//print the G* and P* arrows from the first level CLAs
	Middle += "<BR>" 
	Middle += "<IMG SRC = ./../images/blank.gif>"
	for (counter = NumDigits-1; counter >= NumDecimals; counter--) 
	{
		if ((((counter+1) % GroupSize) == 0)  || (counter == NumDigits-1) )//Starting of a level 0 CLA
		{
			BigGroupCounter = Math.floor(counter/GroupSize)
			//Print generate* arrow
			if (GenerateStar[BigGroupCounter] == 1)
				Middle += "<IMG SRC = ./lookgif/GP_L0_1.gif>"
			else
				Middle += "<IMG SRC = ./lookgif/GP_L0_0.gif>"
		
			//Print propagate* arrow
			if (PropagateStar[BigGroupCounter] == 1)
				Middle += "<IMG SRC = ./lookgif/GP_L0_1.gif>"
			else
				Middle += "<IMG SRC = ./lookgif/GP_L0_0.gif>"
	
			Middle += "<IMG SRC = ./lookgif/small_blank.gif>"
		}
		else   //Middle of a level 1 CLA
			Middle += "<IMG SRC = ./lookgif/big_blank.gif>"

		//Print blank gif between two basic adder blocks
		if ((counter != 0) && ((counter % GroupSize) == 0))    //End of a CLA level 0 group
		{
			if (FinalCarry[counter] == 0)
				Middle += "<IMG SRC = ./lookgif/vertical_0.gif>"
			else
				Middle += "<IMG SRC = ./lookgif/vertical_1.gif>"
		}
		else		// NOT End of a CLA level 0 group
			Middle += "<IMG SRC = ./../images/blank.gif>"
	}


	//Print the 2nd level CLAs
	Middle += "<BR>" 
	Middle += "<IMG SRC = ./../images/blank.gif>"
	BigGroupSize = GroupSize * GroupSize
	newBlockStart=1;
	for (counter = NumDigits-1; counter >= NumDecimals; counter--) 
	{
		if (newBlockStart == 1)
		{
			if ((counter %  BigGroupSize) == 0)  //Single member CLA
			{
				Middle += "<IMG SRC = ./lookgif/cla_total.gif>"
				newBlockStart = 1
			}
			else		//This CLA has multiple members
			{
				Middle += "<IMG SRC = ./lookgif/cla_start.gif>"
				newBlockStart = 0
			}
		}
		else
		{
			if ((counter % BigGroupSize) == 0)  //End of a block
			{
				Middle += "<IMG SRC = ./lookgif/cla_finish.gif>"
				newBlockStart = 1
			}
			else  //Middle of a block
				Middle += "<IMG SRC = ./lookgif/cla_mid.gif>"
		}

		//Print the middle portion of block
		if (newBlockStart == 0)      // A CLA is being continued
			Middle += "<IMG SRC = ./lookgif/cla_blank.gif>"
		else	//New CLA will be started				 
		{
			if (counter != 0)        //Not the 0-th CLA, so, Cout is needed
				Middle += "<IMG SRC = ./lookgif/cla_cout_sp.gif>"
		}
	}
	Middle += "<IMG SRC = ./../images/carry0.gif>"



	Middle +="</PRE>"

	ActualSum = A + B

	Middle += "<TABLE>"
    Middle += "<TR> <TD>A<TD>"	
    Middle += PrintTwosComp(A, NumDigits)   
	Middle += "<TD>  <TD>  :  " + A + "<br>"
	Middle += "<TR> <TD>B<TD>+"
	Middle += PrintTwosComp(B, NumDigits)	
	Middle += "<TD>  <TD>  :  " + B + "<br>"
	Middle += MakeLine(NumCols + 3)
	Middle += "<TR> <TD>Sum<TD>"	
    Middle += PrintTwosComp(ActualSum, NumDigits)   
	Middle += "<TD>  <TD>  :  <B>" + ActualSum + "</B><br>"
	Middle += "</TABLE><BR><BR>"

	//Middle += "Group Size " + GroupSize + "<br>"
	//Middle += "Gate Delay " + GateDelay + "<br>"
	//Middle += "CLA Level 0 " + NumberOfCla0Blocks + "<br>"
	//Middle += "CLA Level 1 " + NumberOfCla1Blocks + "<br>"




	//TIMING

	for (counter = NumDecimals; counter <= NumDigits-1; counter++) 
	{
		SumTime[counter]  = 0
	}
	

	AndLevels = Math.floor((Math.log(GroupSize-1)/Math.log(FanIn)))+1
	OrLevels = Math.floor((Math.log(GroupSize)/Math.log(FanIn)))+1
	numberOfBigGroups = Math.ceil(NumDigits/(GroupSize *GroupSize));
	for (index = 0; index < NumDigits; index++)
	{
		BigGroupNumber = index/GroupSize;
		BigGroupNumber = Math.floor(BigGroupNumber/GroupSize)+1;
		if (index < GroupSize)
			BigGroupNumber = BigGroupNumber - 1
		SumTime[index] = AndOrDelay + 2 * XorDelay + (AndOrDelay * (OrLevels + AndLevels)) + (BigGroupNumber * (AndOrDelay * (OrLevels + AndLevels)))
		//SumTime[index] = BigGroupNumber
	}



	SumTime[NumDigits-1] = 1000 * SumTime[NumDigits-1]
	SumTime[NumDigits-1] = Math.round(SumTime[NumDigits-1])/1000;
	Middle += "Time taken to generate all Sum bits - (" + SumTime[NumDigits-1]  + ")units<BR>"
	//CarryTime[NumDigits-1] = 1000 * CarryTime[NumDigits-2]
	//CarryTime[NumDigits-1] = Math.round(CarryTime[NumDigits-2])/1000
	//Middle += "Time taken to generate all Carryout - (" + CarryTime[NumDigits-2] + ")units<BR>"


	Middle += "<BR><BR><HR><BR>Delays to calculate Sum in each bit position <BR><BR>"
	bigwidth = 150 * (NumDigits-NumDecimals)
	bigwidth = bigwidth/2
	Middle += "<TABLE BORDER CELLSPACING=4 BORDERCOLOR=#000000 CELLPADDING=7 WIDTH=" + bigwidth +">"
	bigwidth = 100/(NumDigits-NumDecimals);
	Middle += "<P ALIGN=CENTER>"
	Middle += "<TR>"
	Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER> BitNumber </TD>"
	for (counter = NumDigits-1; counter >= NumDecimals; counter--) 
	{
			Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER>" + counter + "</TD>"
	}
	Middle += "</TR>"
	Middle += "<TR>"
	Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER>  SumDelay </TD>"
	for (counter = NumDigits-1; counter >= NumDecimals; counter--) 
	{
			SumTime[counter] = 1000 * SumTime[counter];
            SumTime[counter] = Math.round(SumTime[counter])/1000;   
			Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER>"  + "(" + SumTime[counter] + ")units" + "</TD>"
	}
	Middle += "</TR>"
	Middle += "</P>"
	Middle += "</TABLE>"


	Middle += "<BR>"
	

	Bottom = "</BODY> </HTML>";

	if (Overflow)  { Middle = PrintError("Overflow") }
	if (Mixed)     { Middle = PrintError("Mixed numbers") }
	if (NotBinary) { Middle = PrintError("At least one number is non-binary ") }

	parent.frames[1].document.open()
	parent.frames[1].document.write(TheTop);
	parent.frames[1].document.write(Middle);
	parent.frames[1].document.write(Bottom);
	parent.frames[1].document.close()

}



</SCRIPT>
</HEAD>

<BODY bgcolor="#8FC844">

<CENTER> <H2> Carry Look Ahead Adder</H2> </CENTER>

<FORM>
A: <INPUT type="text" name="A"><BR>
B: <INPUT type="text" name="B"><BR>

<EM>bin</EM> <INPUT type="radio" name="Base" value="Binary" checked>
<EM>dec</EM> <INPUT type="radio" name="Base" value="Decimal"><P>

<TABLE>
<TR>
<TD>Total Bits</TD>
<TD><INPUT type="text" name="NumBits" value=12 size=4></TD>
<TD>Group Size</TD>
<TD><INPUT type="text" name="GroupSize" value=3 size=4></TD>
</TR>
</TABLE>
<HR>
	
<CENTER>
<TABLE BORDER>
<CAPTION><B>Signal Delays</B></CAPTION>

<TR>
<TD>AND/OR Gate Delay</TD>
<TD><INPUT type="text" name="AndOrDelay" value=1.0 size=4></TD>
</TR>

<TR>
<TD>XOR Gate Delay</TD>
<TD><INPUT type="text" name="XorDelay" value=1.6 size=4></TD>
</TR>

<TR>
<TD>Maximum Fan-in</TD>
<TD><INPUT type="text" name="FanIn" value=4 size=4></TD>
</TR>
</TABLE>

<P>
<INPUT type="button" name="enter" value="Compute" onClick="CarryLookAheadAdd(this.form)">
</CENTER>
</p>

<p>
<CENTER>
<INPUT TYPE="Reset"  VALUE="   Reset   " onClick=parent.frames[1].location.href="../tablet.html">
</CENTER>
</P>

<p>
<CENTER>
<INPUT TYPE="button"  VALUE="   Help    " onClick=parent.frames[1].location.href="help.html">
</CENTER>
</P>


</FORM>

</BODY>
</HTML>
