<html>
<head>
<title>Generalized Conditional Sum Adder</title>
<script language="JavaScript">

//************************************
//	BEGIN SCRIPT
//************************************


function MakeLine(NumColumns) 
{
	return "<TR> <TD colspan=" + NumColumns + "> <HR noshade size=1>\n";
}

function PrintError(Message) 
{
	Error = "<CENTER><H1> ERROR </H1></CENTER> <P>\n"
	Error += "<CENTER> <EM>" + Message + "</EM> </CENTER>\n"
	return Error
}

function IsInteger(Num) 
{
	return (Num == Math.floor(Num))
}

function OrderOfMagnitude (TheNum) 
{
	// returns the highest place which has a "1" in TheNum's
	// binary representation

	// to account for 2's complement representation...
	//alert ("TheNum is now " + TheNum)
	TheNum < 0 ? TheNum = (TheNum * -2) - 2 : TheNum *= 2
	//alert ("TheNum is now " + TheNum)

	LogBaseTwo = Math.log(TheNum)/Math.LN2;
	return Math.floor(LogBaseTwo)
}

function ParseBinary (BinNum) 
{
	// Turns a binary number into a decimal, sets a flag to true if
	// BinNum is not actually binary

	IsNeg = false
	if (BinNum < 0) 
	{
		IsNeg = true
		BinNum *= -1
	}
	RealNum = 0
	BinNum += Math.pow(10, -1 - NumBits) // kludge so processor
					     // won't mess up
	LogBaseTen = Math.log(BinNum)/Math.LN10
	HighestPlace = Math.ceil(LogBaseTen)
	for (CurPlace = HighestPlace; CurPlace >= -NumBits; CurPlace--) 
	{
		CurEntry = Math.floor(BinNum / Math.pow(10, CurPlace))
		if (CurEntry != 0 && CurEntry != 1) 
		{
			NotBinary = true
			CurEntry = 1 // feed it something normal, to avoid
					 // wierd Javascript errors
		}
		if (CurEntry == 1) 
		{
			RealNum += Math.pow(2, CurPlace)
			BinNum -= Math.pow(10, CurPlace)
		}
	}
	if (IsNeg) {RealNum *= -1} // reverse it back at the end

	// now check if the number was negative according to two's complement
	// representation - if it was, set the decimal value to this negative
	// number
	if (HighestPlace == NumBits)
		RealNum -= Math.pow(2, NumBits)

	// if (HighestPlace == 1)
	// 	RealNum -= Math.pow(2, 1)

	return RealNum
}

function RoundOff (TheNum) 
{
	// returns the value TheNum would have if it were represented by
	// NumDecimals bits after the decimal point
	Scaling = Math.pow(2, NumDecimals)
	return (Math.floor(TheNum * Scaling) / Scaling)
}



function PrintTwosComp(TheNum, StartPlace) 
{

	// first deal with negative numbers...
	if (TheNum < 0) {TheNum += Math.pow(2, StartPlace)}

	// now initialize the string
	S = "";
	S += "<TD> ";
	for (CurPlace = StartPlace - 1; CurPlace >= -NumDecimals; CurPlace--) 
	{
		if (CurPlace == -1) 
		{
			S += ".";
		}
		CurPower = Math.pow(2, CurPlace);
		if (TheNum >= CurPower) 
		{
			S += "1 ";
			TheNum -= CurPower
		} 
		else 
		{
			S += "0 "
		} 
	}
	return S;
}


function FeedIntoVariable(TheNum, StartPlace, ReturnArray) 
{
	if (TheNum < 0) {TheNum += Math.pow(2, StartPlace)}

	// now initialize the string
	index = StartPlace - 1
	for (CurPlace = StartPlace - 1; CurPlace >= -NumDecimals; CurPlace--) 
	{
		if (CurPlace == -1) 
		{
			ReturnArray[index] = 2;
			index --
		}
		CurPower = Math.pow(2, CurPlace);
		if (TheNum >= CurPower) 
		{
			ReturnArray[index] = 1;
			index --
			TheNum -= CurPower
		} 
		else 
		{
			ReturnArray[index] = 0;
			index --;
		} 
	}
	return ReturnArray
}


function PrintSumCarry(Middle, counter)
{
	Middle += MakeLine(NumCols + 3)
    Middle += "<TR><TD><TD>"
	if (counter == 1)
		Middle += "<TR><TD><h4>Time =  t</h4><TD><TD>"
	else
		Middle += "<TR><TD><h4>Time =  " + counter + "t</h4><TD><TD>"
    Middle += "<TR><TD>Carry     :    <TD><TD>" 
	for (loop=NumDigits-1;loop>=0;loop--)
 		Middle += " " + FinalCarry[loop];
    Middle += "<TR><TD>Sum       :    <TD><TD>"
	for (loop=NumDigits-1;loop>=0;loop--)
		Middle += " " + FinalSum[loop]
	

	return Middle
}


//Next function returns the larger of two numbers
function GetMax(Number1, Number2)
{
	if (Number1 > Number2)
		bigger = Number1
	else
		bigger = Number2

	return bigger
}


//Next function returns the smaller of two numbers
function GetMin(Number1, Number2)
{
	if (Number1 < Number2)
		smaller = Number1
	else
		smaller = Number2

	return smaller
}


//Next function returns the time needed to Calculate the Sum-time of this adder block
function CalculateSumTime_Ripple(AToSum, CinToSum, PrevCarryTime)
{
	if (PrevCarryTime == 0)
		finalTime = GetMax(AToSum, CinToSum)
	else
	{
		if (CinToSum > AToSum)
			finalTime = PrevCarryTime + CinToSum
		else
		{
			if (PrevCarryTime < AToSum)
			{
				difference = AToSum - CinToSum
				finalTime = GetMax(difference, CinToSum) + PrevCarryTime
			}
			else
				finalTime = CinToSum + PrevCarryTime
		}
	}

	//Cross-checking for trivial case
	if (finalTime < AToSum)
		finalTime = AToSum
	if (finalTime < CinToSum)
		finalTime = CinToSum

	return finalTime	
}


//Next function returns the time needed to Calculate the Carry-time of this adder block
function CalculateCarryTime_Ripple(AToCout, CinToCout, PrevCarryTime)
{
	if (PrevCarryTime == 0)
		CarryOutTime = GetMax(AToCout, CinToCout)
	else
	{
		if (CinToCout > AToCout)
			CarryOutTime = PrevCarryTime + CinToCout
		else
		{
			if (PrevCarryTime < AToCout)
			{
				difference = AToCout - CinToCout
				CarryOutTime = GetMax(difference, CinToCout) + PrevCarryTime
			}
			else
				CarryOutTime = CinToCout + PrevCarryTime
		}
	}

	//Cross-checking for trivial case
	if (CarryOutTime < AToCout)
		CarryOutTime = AToCout
	if (CarryOutTime < CinToCout)
		CarryOutTime = CinToCout

	return CarryOutTime	
}

//Next function returns the time needed to Calculate the Sum-time of this adder block
function CalculateSumTime_Manchester(AToSum, CinToSum, PrevCarryTime)
{
	finalTime = GetMax(AToSum, CinToSum)
	finalTime = finalTime + PrevCarryTime

	return finalTime	
}


//Next function returns the time needed to Calculate the Carry-time of this adder block
function CalculateCarryTime_Manchester(index, bufferDist, bufferDelay, switchDelay, PrevCarryTime)
{
	CarryOutTime = switchDelay + PrevCarryTime

	if (((index+1) % bufferDist) == 0)
		CarryOutTime = CarryOutTime + bufferDelay
	

	return CarryOutTime	
}





function CondSumAdd(form) 
{
       // TheTop = "<HTML><HEAD><TITLE>Tablet</TITLE></HEAD><BODY bgcolor=lightyellow>";
	TheTop = "<HTML><HEAD><TITLE>Tablet</TITLE></HEAD><BODY bgcolor=white>";
        A = parseFloat(form.A.value)
        B = parseFloat(form.B.value)


        CinToSum = parseFloat(form.CinToSum.value)
        AToSum = parseFloat(form.AToSum.value)
        CinToCout = parseFloat(form.CinToCout.value)
        AToCout = parseFloat(form.AToCout.value)
        muxdel = parseFloat(form.muxdel.value)
	switchdel = parseFloat(form.switchdel.value)
	singleGateDelay = parseFloat(form.singleGateDelay.value)
	exorGateDelay = parseFloat(form.exorGateDelay.value)

	ChoseBin = form.Base[0].checked
        ChoseDec = form.Base[1].checked

	// Adder Type
	ChoseRipple = form.AdderType[0].selected
	ChoseManchester = form.AdderType[1].selected
	if (ChoseManchester)	
		AdderType = "Manchester Carry"
	else
		AdderType = "Ripple Carry"
	
	NumBits = parseInt(form.NumBits.value)

	// Adder Size
	//AdderSize = parseInt(form.AdderSize.value)		// Basic Adder Size

	AdderSizes = form.IndAdderSize.value.split(" ");	// AdderSizes is an array
	NumAdders = AdderSizes.length

	BasicAdderSize = new Array(NumAdders)

	//for(index=0; index < NumAdders; index++)
		//BasicAdderSize[index] =  parseInt(AdderSizes[index])

	for(index=0; index < NumAdders; index++)
		BasicAdderSize[(NumAdders-1)-index] =  parseInt(AdderSizes[index])
	
	checksum = 0
	for(index=0; index < NumAdders; index++)
		checksum += BasicAdderSize[index]

	AdderSizeZero = false
	for(index=0; index < NumAdders; index++)
	{
		if(BasicAdderSize[index]==0)
			AdderSizeZero = true
		else
			AdderSizeZero = AdderSizeZero | false
	}

	EqualAdderSize = true
	for(index=1; index < NumAdders; index++)	// one count less
	{
		if(BasicAdderSize[index]==BasicAdderSize[index-1])
			EqualAdderSize = EqualAdderSize & true
		else
			EqualAdderSize = false
	}

	if(EqualAdderSize)
	{
		AdderSize = BasicAdderSize[0];
		NumGroups = NumBits/AdderSize;
	}
	else
	{	
		AdderSize = 0;
		NumGroups = 0;
	}

	
	IndAdderToBits = false
	if(checksum != NumBits)
		IndAdderToBits = true	// Mismatch b/n total bits and total adder bits

	
	/*
	Group_Zero = false;
	if(AdderSize==0)
		Group_Zero = true;

	Group_Mismatch = false;
	if(NumBits%AdderSize != 0 && AdderSize!=0)
		Group_Mismatch = true;

	if(AdderSize!=0)	
		NumGroups = NumBits/AdderSize;
	*/


	// Adder Structure
	ChoseAssymetric = form.AdderStructure[0].selected
	ChoseSymmetric = form.AdderStructure[1].selected

        NotBinary = false					// Set in ParseBinary() function
        if (ChoseBin) 		
        {	
		// Convert Binary Nos. to Decimal
                A = ParseBinary(A)
                B = ParseBinary(B)
        }

	Mixed = false
	Overflow = false
	FractionalNum = (Math.abs(A) < 2) && (Math.abs(B) < 2)
	// bit to left of dec. pt. is sign bit 
	if (IsInteger(A) & IsInteger(B)) 
	{
		NumDecimals = 0
		NumDigits = NumBits
		if (Math.max(OrderOfMagnitude(A), OrderOfMagnitude(B)) + 1 > NumDigits) 
		{
			NumDigits = 0
			NumDecimals = 0
			Overflow = true
		}
	} 
	else 
	{
		if (FractionalNum) 
		{
			NumDigits = 1
			NumDecimals = NumBits - 1
		} 
		else 
		{
			Mixed = true
			NumDigits = 0
			NumDecimals = 0    // just filler values 
		}
	}

	NumCols = (2 * NumDigits - 1) + NumDecimals

	
	A = RoundOff(A)
	B = RoundOff(B)

	Product = 0


	// now initialize two Input Arrays & two Output arrays
	FirstNumber = new Array(NumDigits)		// Stores binary digits of A
	FeedIntoVariable(A, NumDigits,FirstNumber)	// Decimal to binary conversion for A
	SecondNumber = new Array(NumDigits)		// Stores binary digits of B
	FeedIntoVariable(B, NumDigits,SecondNumber)	// Decimal to binary conversion for B
	FinalCarry = new Array(NumDigits)
	FinalSum = new Array(NumDigits)
	
	// Final Sum & Carry Calculated For Display
	// Sum and Carry Calculated by Ripple Carry Method	
	
	for (i=NumDigits-1;i>=0;i--)
	{
		FinalCarry[i] = 0
		FinalSum[i] = FirstNumber[i];
	}

	for (counter = NumDecimals; counter < NumDigits; counter++) 
	{
		if (counter==0)
			carryin=0;
		else
			carryin = FinalCarry[counter-1]

		carryout1 = FirstNumber[counter] & SecondNumber[counter];
		carryout2 = carryin & FirstNumber[counter];
		carryout3 = carryin & SecondNumber[counter];
		carryout = carryout1 | carryout2 | carryout3;
		FinalCarry[counter] = carryout	
				
		sumi = FirstNumber[counter] ^ SecondNumber[counter] ^ carryin;
		FinalSum[counter] = sumi
	}

	ActualSum = A + B	

	error_condition = false;
	//error_condition = Overflow | Mixed | NotBinary | Group_Mismatch | Group_Zero;
	error_condition = Overflow | Mixed | NotBinary | AdderSizeZero | IndAdderToBits



/* begin intermediate results

// Required only if Intermediate Results are required in assymetric mode with equal adder sizes

if(error_condition==false && ChoseAssymetric==true && EqualAdderSize==true)
{
	// 2D Array (no size reqd. for the second dimension)
	SumGroup_0 = new Array()
	CarryGroup_0 = new Array()
	SumGroup_1 = new Array()
	CarryGroup_1 = new Array()


	for (i=0;i<NumGroups;i++)
	{
		SumGroup_0[i] = new Array(AdderSize);
		CarryGroup_0[i] = new Array(AdderSize);
		SumGroup_1[i] = new Array(AdderSize);
		CarryGroup_1[i] = new Array(AdderSize);
	}


	Num_counter = NumDecimals;
	// Group Sum and Carry assuming group input carry = 0
	// Same values for Ripple and Manchester Carry Schemes
	for (group_count = 0; group_count < NumGroups; group_count++)
	{	
		for (counter = 0; counter < AdderSize; counter++) 
		{
			if (counter==0)
				carryin=0;
			else
				carryin = CarryGroup_0[group_count][counter-1]

			carryout1 = FirstNumber[Num_counter] & SecondNumber[Num_counter];
			carryout2 = carryin & FirstNumber[Num_counter];
			carryout3 = carryin & SecondNumber[Num_counter];
			carryout = carryout1 | carryout2 | carryout3;
			CarryGroup_0[group_count][counter] = carryout	
				
			sumi = FirstNumber[Num_counter] ^ SecondNumber[Num_counter] ^ carryin;
			SumGroup_0[group_count][counter] = sumi
	
			Num_counter++
			if(Num_counter >= NumDigits)
				break;
		}
		if(Num_counter >= NumDigits)
			break;
		
	}


	Num_counter = NumDecimals;
	// Group Sum and Carry assuming group input carry = 1
	// Same values for Ripple and Manchester Carry Schemes
	for (group_count = 0; group_count < NumGroups; group_count++)
	{	
		for (counter = 0; counter < AdderSize; counter++) 
		{
			if (counter==0)
				carryin=1;
			else
				carryin = CarryGroup_1[group_count][counter-1]

			carryout1 = FirstNumber[Num_counter] & SecondNumber[Num_counter];
			carryout2 = carryin & FirstNumber[Num_counter];
			carryout3 = carryin & SecondNumber[Num_counter];
			carryout = carryout1 | carryout2 | carryout3;
			CarryGroup_1[group_count][counter] = carryout	
				
			sumi = FirstNumber[Num_counter] ^ SecondNumber[Num_counter] ^ carryin;
			SumGroup_1[group_count][counter] = sumi
	
			Num_counter++
			if(Num_counter >= NumDigits)
				break;
		}
		if(Num_counter >= NumDigits)
			break;		
	}

	
	// 2D Array (no size reqd. for the second dimension)
	MuxGroup_0 = new Array()
	MuxGroup_1 = new Array()

	FinalMuxSize = NumDigits - AdderSize;
	MuxGroup_0[0] = new Array(FinalMuxSize)	// Final Level Mux

if(NumGroups>=2)
{
	for (i=NumGroups-2;i>0;i--)
	{
		MuxGroup_0[i] = new Array(AdderSize*(NumGroups-1-i))
		MuxGroup_1[i] = new Array(AdderSize*(NumGroups-1-i))
	}


	for (i=NumGroups-2;i>0;i--)
	{
		if (i==NumGroups-2)
			for(j=AdderSize-1;j>=0;j--)
			{
				MuxGroup_0[i][j] = CarryGroup_0[i][AdderSize-1]?SumGroup_1[i+1][j]:SumGroup_0[i+1][j];
				MuxGroup_1[i][j] = CarryGroup_1[i][AdderSize-1]?SumGroup_1[i+1][j]:SumGroup_0[i+1][j];
			}

		else
			for(j=(AdderSize*(NumGroups-1-i))-1;j>=AdderSize;j--)
			{
				MuxGroup_0[i][j] = CarryGroup_0[i][AdderSize-1]?MuxGroup_1[i+1][j-AdderSize]:MuxGroup_0[i+1][j-AdderSize];
				MuxGroup_1[i][j] = CarryGroup_1[i][AdderSize-1]?MuxGroup_1[i+1][j-AdderSize]:MuxGroup_0[i+1][j-AdderSize];
			}
			
			for(j=AdderSize-1;j>=0;j--)
			{
				MuxGroup_0[i][j] = CarryGroup_0[i][AdderSize-1]?SumGroup_1[i+1][j]:SumGroup_0[i+1][j];
				MuxGroup_1[i][j] = CarryGroup_1[i][AdderSize-1]?SumGroup_1[i+1][j]:SumGroup_0[i+1][j];
			}
	}

	// Final Level Mux
	for(j=(AdderSize*(NumGroups-1))-1;j>=AdderSize;j--)
		MuxGroup_0[0][j] = CarryGroup_0[0][AdderSize-1]?MuxGroup_1[1][j-AdderSize]:MuxGroup_0[1][j-AdderSize];
			
	for(j=AdderSize-1;j>=0;j--)
		MuxGroup_0[0][j] = CarryGroup_0[0][AdderSize-1]?SumGroup_1[1][j]:SumGroup_0[1][j];
}

	FinalCondSum = new Array(NumDigits);

	// Final Conditional Sum
	for(j=(AdderSize*NumGroups)-1;j>=AdderSize;j--)
		FinalCondSum[j] = MuxGroup_0[0][j-AdderSize];
			
	for(j=AdderSize-1;j>=0;j--)
		FinalCondSum[j] = SumGroup_0[0][j];

} // end of !error_condition	

end intermediate results */


	// Calculate Sum and Carry Delays

	FinalSumTime = new Array(NumDigits)
	//FinalCarryTime = new Array(NumDigits)
	MuxTime = new Array(NumDigits)

	for (counter = NumDecimals; counter <= NumDigits-1; counter++) 
	{
		FinalSumTime[counter]  = 0
		//FinalCarryTime[counter] = 0
		MuxTime[counter] = 0
	}

	// Same delays for carryin of 0 and 1
	// Same delay value for all the groups
	//GroupSumTime = new Array(AdderSize)
	//GroupCarryTime = new Array(AdderSize)

	// 2D Array (no size (i.e) NumAdders reqd. for the second dimension)
	GroupSumTime = new Array()
	GroupCarryTime = new Array()
		
	for (i=0;i<NumAdders;i++)
	{
		GroupSumTime[i] = new Array(BasicAdderSize[i]);
		GroupCarryTime[i] = new Array(BasicAdderSize[i]);
	}

	for(index = 0;index<NumAdders;index++)
	{
		if(ChoseRipple)
		{
		
			for (counter = 0; counter <= BasicAdderSize[index]; counter++) 
			{
				if (counter == 0)
				{
					GroupCarryTime[index][counter] = CalculateCarryTime_Ripple(AToCout, CinToCout, 0)
					GroupSumTime[index][counter]  = CalculateSumTime_Ripple(AToSum, CinToSum, 0)
				}
				else
				{
					GroupCarryTime[index][counter] = CalculateCarryTime_Ripple(AToCout, CinToCout, GroupCarryTime[index][counter - 1])
					GroupSumTime[index][counter] = CalculateSumTime_Ripple(AToSum, CinToSum, GroupCarryTime[index][counter - 1])
				}
			}
		}

		if(ChoseManchester)	// Buffer Distence = 1, Buffer Delay = 0
		{
			startTime = GetMax(2*singleGateDelay, exorGateDelay)
			for (counter = 0; counter <= BasicAdderSize[index]; counter++) 
			{
				if (counter == 0)
				{
					GroupCarryTime[index][counter] = CalculateCarryTime_Manchester(counter, 1 /*BuffDist*/, 0 /*bufferDelay*/,  switchdel, startTime)
					GroupSumTime[index][counter]  = CalculateSumTime_Manchester(AToSum, CinToSum, startTime)
				}
				else
				{
					GroupCarryTime[index][counter] = CalculateCarryTime_Manchester(counter, 1 /*BuffDist*/, 0 /*bufferDelay*/,  switchdel, GroupCarryTime[index][counter - 1])
					GroupSumTime[index][counter] = CalculateSumTime_Manchester(AToSum, CinToSum, GroupCarryTime[index][counter - 1])
				}
			
			}
		}
	}



	// Calculate MUX Delays
	
	total_muxdelay = 0;
	bit_count = 0;

	for(i=0;i<NumAdders;i++)
	{
		if(ChoseSymmetric)
		{
			total_muxdelay = muxdel*Math.ceil(Math.log(i+1)/Math.log(2));
			for(j=0;j<BasicAdderSize[i];j++)
			{
				MuxTime[bit_count] = total_muxdelay;
				bit_count++;
			}
		}

		else
		{
			if(i==0)
				total_muxdelay = 0;
		
			else
				total_muxdelay = muxdel + muxdel*(i - 1);

			for(j=0;j<BasicAdderSize[i];j++)
			{	
				MuxTime[bit_count] = total_muxdelay;
				bit_count++
			}
		}
	}
	

	// Store Basic Adder Delays in an Array

	ComboSumTime = new Array(NumDigits)
	//ComboCarryTime = new Array(NumDigits)

	bit_count=0
	for(i=0;i<NumAdders;i++)
	for(j=0;j<BasicAdderSize[i];j++)
	{
		ComboSumTime[bit_count] = GroupSumTime[i][j];
		//ComboCarryTime[bit_count] = GroupCarryTime[i][j];
		bit_count++
		
	}

/*
	// Calculate Final Sum Delays
	
	bit_count=0
	for(i=0;i<NumAdders;i++)
	{
		if(ChoseSymmetric)
		{
			muxcount_log = Math.ceil(Math.log(i+1)/Math.log(2));
			for(j=0;j<BasicAdderSize[i];j++)
			{
				if(i==0)
					FinalSumTime[bit_count]=GroupSumTime[i][j];
				else
				FinalSumTime[bit_count] = muxdel + GetMax(GroupCarryTime[i-1][BasicAdderSize[i-1]-1]+((muxcount_log-1)*muxdel),GroupSumTime[i][j] + ((muxcount_log-1)*muxdel));
				
				bit_count++
			}
		}

		else
		{
			for(j=0;j<BasicAdderSize[i];j++)
			{
				if(i==0)
					FinalSumTime[bit_count] = MuxTime[bit_count] + GetMax(ComboSumTime[bit_count],0);
				else
					FinalSumTime[bit_count] = MuxTime[bit_count] + GetMax(GroupSumTime[i][j], 			GroupCarryTime[i-1][BasicAdderSize[i-1]-1])
					
					//FinalSumTime[i*AdderSize+j] = MuxTime[i*AdderSize+j] + GetMax(ComboSumTime[i*AdderSize+j], ComboCarryTime[((i-1)*AdderSize) + (AdderSize-1)])
			
				bit_count++
			}

		}
	}
*/

if(ChoseSymmetric)
{
	// Symmetric Structure Sum Delay Calculation

	no_levels = Math.ceil(Math.log(NumAdders)/Math.log(2))

	// 3D Array (no size (i.e) no_levels reqd. for the third dimension)
	LevelSumTime = new Array(no_levels)
	LevelCarryTime = new Array(no_levels)

	for (i=0;i<no_levels;i++)	// one less than no of levels
	{
		LevelSumTime[i] = new Array(NumAdders)
		LevelCarryTime[i] = new Array(NumAdders)
	}
		
	for (i=0;i<no_levels;i++)
	for (j=0;j<NumAdders;j++)
	{
		LevelSumTime[i][j] = new Array(BasicAdderSize[j]);
		LevelCarryTime[i][j] = new Array(BasicAdderSize[j]);
	}


	for (i=0;i<no_levels;i++)
	{
		skip_value = Math.pow(2,i)
		skip_count = 0;
		carry_chosen = skip_value;

		for (j=0;j<NumAdders;j++)
		{
			if(skip_count>=skip_value && skip_count<2*skip_value)
				mux_pass = 1;
			else
				mux_pass = 0;

			for (k=0;k<BasicAdderSize[j];k++)
			{
				if(mux_pass ==0)
				{
					if(i==0)
					{
						LevelSumTime[i][j][k] = GroupSumTime[j][k];
						LevelCarryTime[i][j][k] = GroupCarryTime[j][k];
					}
					else
					{
						LevelSumTime[i][j][k] = LevelSumTime[i-1][j][k];
						LevelCarryTime[i][j][k] = LevelCarryTime[i-1][j][k];
					}
				}
				else
				{
					if(i==0)
					{
						LevelSumTime[i][j][k] = muxdel + GetMax(GroupSumTime[j][k],GroupCarryTime[carry_chosen-1][BasicAdderSize[carry_chosen-1]-1]);
						LevelCarryTime[i][j][k] = muxdel + GetMax(GroupCarryTime[j][k],GroupCarryTime[carry_chosen-1][BasicAdderSize[carry_chosen-1]-1]);
					}

					else
					{
						LevelSumTime[i][j][k] = muxdel + GetMax(LevelSumTime[i-1][j][k],LevelCarryTime[i-1][carry_chosen-1][BasicAdderSize[carry_chosen-1]-1]);
						LevelCarryTime[i][j][k] = muxdel + GetMax(LevelCarryTime[i-1][j][k],LevelCarryTime[i-1][carry_chosen-1][BasicAdderSize[carry_chosen-1]-1]);
					}
				}

			}
			if(skip_count==2*skip_value-1)
			{
				skip_count = 0;
				carry_chosen = carry_chosen + 2*skip_value;
			}
			else
				skip_count = skip_count + 1;

		}
	}

} // end of ChoseSymmetric
					
	
		
	// Calculate Final Sum Delays
	
	bit_count=0
	for(i=0;i<NumAdders;i++)
	{
		if(ChoseSymmetric)
		{
			for(j=0;j<BasicAdderSize[i];j++)
			{
				FinalSumTime[bit_count] = LevelSumTime[no_levels-1][i][j];
				bit_count++
			}			
		}

		else
		{	
			for(j=0;j<BasicAdderSize[i];j++)
			{
				Max_delay = GroupSumTime[i][j];
				for(inner_count=i;inner_count>0;inner_count--)	// No loop entry for i=0
				{
					Max_delay = muxdel + GetMax(Max_delay,GroupCarryTime[i-1][BasicAdderSize[i-1]-1]);
				}
				FinalSumTime[bit_count] = Max_delay;
				bit_count++
			}
		}
	}

	

	Middle = " "


// Display Block Diagram of the Adder
// Block Diagram display only for Asymmertic structure with equal adder sizes

if(ChoseAssymetric & EqualAdderSize)
{
	
	Middle += "<BR><B> ADDER - BLOCK DIAGRAM </B><BR>"
	Middle += "<PRE>"
	Middle += "<BR>"
	Middle += "<BR>"
	
	//Middle += "<IMG SRC = ./images/blank3x3.gif>"
	//Middle += "<IMG SRC = ./images/rc.gif width=200 height=100>"

	for (group_count = NumGroups-1; group_count >= 0; group_count--)
	{	
		for (counter = AdderSize-1; counter >= 0 ; counter--) 
		{
			if(FirstNumber[group_count*AdderSize + counter]==0 && SecondNumber[group_count*AdderSize + counter]==0)
				Middle += "<IMG SRC = ./images/input00.gif>"
			if(FirstNumber[group_count*AdderSize + counter]==0 && SecondNumber[group_count*AdderSize + counter]==1)
				Middle += "<IMG SRC = ./images/input01.gif>"
			if(FirstNumber[group_count*AdderSize + counter]==1 && SecondNumber[group_count*AdderSize + counter]==0)
				Middle += "<IMG SRC = ./images/input10.gif>"
			if(FirstNumber[group_count*AdderSize + counter]==1 && SecondNumber[group_count*AdderSize + counter]==1)
				Middle += "<IMG SRC = ./images/input11.gif>"
		}
		
		Middle += "<IMG SRC = ./images/blank3x3.gif>"
		Middle += "<IMG SRC = ./images/blank3x3.gif>"
	}

	Middle += "<BR>"

	for (group_count = NumGroups-1; group_count >= 0 ; group_count--)
	{	
		for (counter = AdderSize-1; counter >= 0; counter--) 
		{
			if(ChoseRipple)
				Middle += "<IMG SRC = ./images/rc.gif>"
			else if(ChoseManchester)
				Middle += "<IMG SRC = ./images/mcc.gif>"
			//else 
				// do nothing		
		}
		
		//Middle += "<IMG SRC = ./images/blank3x3.gif>"
		//Middle += "<IMG SRC = ./images/blank3x3.gif>"
		Middle += "<IMG SRC = ./images/cin0.gif>"
		if(group_count==0)
			Middle += "<IMG SRC = ./images/blank3x3.gif>"
		else
			Middle += "<IMG SRC = ./images/cout0.gif>"
		
	}

	Middle += "<BR>"

	for (group_count = NumGroups-1; group_count >= 0 ; group_count--)
	{	
		for (counter = AdderSize-1; counter >= 0; counter--) 
		{
			if(group_count==0)
				Middle += "<IMG SRC = ./images/bline2_center.gif>"
			else
				Middle += "<IMG SRC = ./images/rline2.gif>"		
		}
		
		Middle += "<IMG SRC = ./images/blank3x2.gif>"
		if(group_count==0)
			Middle += "<IMG SRC = ./images/blank3x2.gif>"
		else
		Middle += "<IMG SRC = ./images/bline2_left.gif>"
	
	}

	Middle += "<BR>"

	for (group_count = NumGroups-1; group_count >= 0 ; group_count--)
	{	
		for (counter = AdderSize-1; counter >= 0; counter--) 
		{
			if(group_count==0)
			{
				Middle += "<IMG SRC = ./images/bline3_center.gif>"
			}
			else
			{
				if(ChoseRipple)
					Middle += "<IMG SRC = ./images/rc.gif>"
				else if(ChoseManchester)
					Middle += "<IMG SRC = ./images/mcc.gif>"
				//else 
					// do nothing	
			}	
		}

		if(group_count>0)
			Middle += "<IMG SRC = ./images/cin1.gif>"
		
		if(group_count>1)
			Middle += "<IMG SRC = ./images/cout1.gif>"	
		else if(group_count==1)
			Middle += "<IMG SRC = ./images/bline3_left.gif>"
		//else 
			// do nothing			
	}

	Middle += "<BR>"

	for (group_count = NumGroups-1; group_count >= 0 ; group_count--)
	{
		if(group_count>0)
		{
			for (count1 = NumGroups-1; count1 >= 0 ; count1--)
			{	
				if(count1>group_count)
				{
					for (count2 = AdderSize-1; count2 >= 0; count2--)
						Middle += "<IMG SRC = ./images/gp_arrow4.gif>"
					Middle += "<IMG SRC = ./images/blank3x4.gif>"
					Middle += "<IMG SRC = ./images/blank3x4.gif>"
				}
				else if(count1==group_count)
				{
					for (count2 = AdderSize-1; count2 >= 0; count2--)
						Middle += "<IMG SRC = ./images/rb_arrow4.gif>"
					Middle += "<IMG SRC = ./images/blank3x4.gif>"
					if(count1==1)
						Middle += "<IMG SRC = ./images/bline4_left.gif>"
					else
						Middle += "<IMG SRC = ./images/double_bline4.gif>"
				}
				else if(count1==0)
				{
					for (count2 = AdderSize-1; count2 >= 0; count2--)
						Middle += "<IMG SRC = ./images/bline4_center.gif>"
				}
				else
				{
					for (count2 = AdderSize-1; count2 >= 0; count2--)
						Middle += "<IMG SRC = ./images/rb_line4.gif>"
					Middle += "<IMG SRC = ./images/blank3x4.gif>"
					if(count1==1)
						Middle += "<IMG SRC = ./images/bline4_left.gif>"
					else
						Middle += "<IMG SRC = ./images/double_bline4.gif>"
				}
			}

			Middle += "<BR>"
	
			for (count1 = NumGroups-1; count1 >= 0 ; count1--)
			{	
				if(count1>group_count)
				{
					for (count2 = AdderSize-1; count2 >= 0; count2--)
						Middle += "<IMG SRC = ./images/mux.gif>"
					Middle += "<IMG SRC = ./images/mux.gif>"
					Middle += "<IMG SRC = ./images/mux.gif>"
				}
				else if(count1==group_count)
				{
					for (count2 = AdderSize-1; count2 >= 0; count2--)
						Middle += "<IMG SRC = ./images/mux.gif>"
					
					if(count1==1)
					{
						Middle += "<IMG SRC = ./images/mux_c0.gif>"
						Middle += "<IMG SRC = ./images/blank3x3.gif>"
					}
					else
					{
						Middle += "<IMG SRC = ./images/mux_c0.gif>"
						Middle += "<IMG SRC = ./images/bline3_center.gif>"
					}
				}
				else if(count1==0)
				{
					for (count2 = AdderSize-1; count2 >= 0; count2--)
						Middle += "<IMG SRC = ./images/bline3_center.gif>"
				}
				else
				{
					for (count2 = AdderSize-1; count2 >= 0; count2--)
						Middle += "<IMG SRC = ./images/rb_line3.gif>"
					Middle += "<IMG SRC = ./images/blank3x3.gif>"
					if(count1==1)
						Middle += "<IMG SRC = ./images/bline3_left.gif>"
					else
						Middle += "<IMG SRC = ./images/double_bline3.gif>"
				}
			}

			Middle += "<BR>"
		}

		if(group_count>1)
		{
			for (count1 = NumGroups-1; count1 >= 0 ; count1--)
			{
				if(count1>group_count)
				{
					for (count2 = AdderSize-1; count2 >= 0; count2--)
						Middle += "<IMG SRC = ./images/gline2.gif>"
					Middle += "<IMG SRC = ./images/blank3x2.gif>"
					Middle += "<IMG SRC = ./images/blank3x2.gif>"
				}
				else if(count1==group_count)
				{
					for (count2 = AdderSize-1; count2 >= 0; count2--)
						Middle += "<IMG SRC = ./images/gline2.gif>"

					Middle += "<IMG SRC = ./images/blank3x2.gif>"
					if(count1==1)
						Middle += "<IMG SRC = ./images/bline2_left.gif>"
					else
						Middle += "<IMG SRC = ./images/bline2_center.gif>"
					
				}
				else if(count1==0)
				{
					for (count2 = AdderSize-1; count2 >= 0; count2--)
						Middle += "<IMG SRC = ./images/bline2_center.gif>"
				}
				else
				{
					for (count2 = AdderSize-1; count2 >= 0; count2--)
						Middle += "<IMG SRC = ./images/rb_line2.gif>"
					Middle += "<IMG SRC = ./images/blank3x2.gif>"
					if(count1==1)
						Middle += "<IMG SRC = ./images/bline2_left.gif>"
					else
						Middle += "<IMG SRC = ./images/double_bline2.gif>"
				}
			}

			Middle += "<BR>"

			for (count1 = NumGroups-1; count1 >= 0 ; count1--)
			{
				if(count1>group_count)
				{
					for (count2 = AdderSize-1; count2 >= 0; count2--)
						Middle += "<IMG SRC = ./images/mux.gif>"
					Middle += "<IMG SRC = ./images/mux.gif>"
					Middle += "<IMG SRC = ./images/mux.gif>"
				}	
				else if(count1==group_count)
				{
					for (count2 = AdderSize-1; count2 >= 0; count2--)
						Middle += "<IMG SRC = ./images/mux.gif>"
					
					if(count1==1)  // This condition never occurs
					{
						//Middle += "<IMG SRC = ./images/bline3_left.gif>"
						//Middle += "<IMG SRC = ./images/blank3x3.gif>"
					}
					
					else
					{
						Middle += "<IMG SRC = ./images/mux_c1.gif>"
					}
				}
				else if(count1==0)
				{
					for (count2 = AdderSize-1; count2 >= 0; count2--)
						Middle += "<IMG SRC = ./images/bline3_center.gif>"
				}
				else
				{
					for (count2 = AdderSize-1; count2 >= 0; count2--)
						Middle += "<IMG SRC = ./images/rb_line3.gif>"
					Middle += "<IMG SRC = ./images/blank3x3.gif>"
					if(count1==1)
						Middle += "<IMG SRC = ./images/bline3_left.gif>"
					else
						Middle += "<IMG SRC = ./images/double_bline3.gif>"
				}
			}

			Middle += "<BR>"

		}

		if(group_count==0)
		{
			for (count1 = NumGroups-1; count1 >= 0 ; count1--)
			{	
				for (count2 = AdderSize-1; count2 >= 0; count2--)
				{
					//if(FinalCondSum[count1*AdderSize + count2]==0)
					  if(FinalSum[count1*AdderSize + count2]==0)
						Middle += "<IMG SRC = ./images/sout0.gif>"
					//else if (FinalCondSum[count1*AdderSize + count2]==1)
					  else if (FinalSum[count1*AdderSize + count2]==1)
						Middle += "<IMG SRC = ./images/sout1.gif>"
				}
				Middle += "<IMG SRC = ./images/blank3x3.gif>"
				Middle += "<IMG SRC = ./images/blank3x3.gif>"
			}
			Middle += "<BR>" 
		}

		//else
			// do nothing
								
	}
	
	Middle += "<BR>" 
	Middle += "<BR>"

	Middle +="</PRE>"

}

/*
	if(ChoseSymmetric)		 
		Middle = " "		
	else
		Middle += "<HR>"
*/

		
	// Print the Inputs and the Actual Sum Values
	
	Middle += "<BR><B> ACTUAL SUM </B><BR><BR>"
	Middle += "<TABLE>"
    	Middle += "<TR> <TD>A<TD>"	
    	Middle += PrintTwosComp(A, NumDigits)   
	Middle += "<TD>  <TD>  :  " + A + "<br>"
	Middle += "<TR> <TD>B<TD>+"
	Middle += PrintTwosComp(B, NumDigits)	
	Middle += "<TD>  <TD>  :  " + B + "<br>"
	Middle += MakeLine(NumCols + 3)
	Middle += "<TR> <TD>Sum<TD>"	
    	Middle += PrintTwosComp(ActualSum, NumDigits)   
	Middle += "<TD>  <TD>  :  <B>" + ActualSum + "</B><br>"
	Middle += "</TABLE>"



// Display Sum and Mux Delays

//Print Sum & carry Times		

/*
	SumTime[NumDigits-1] = 1000 * SumTime[NumDigits-1]
	SumTime[NumDigits-1] = Math.round(SumTime[NumDigits-1])/1000;
	Middle += "Time taken to generate all Sum bits - (" + SumTime[NumDigits-1] + ")units<BR>"
	CarryTime[NumDigits-1] = 1000 * CarryTime[NumDigits-1]
	CarryTime[NumDigits-1] = Math.round(CarryTime[NumDigits-1])/1000
	Middle += "Time taken to generate all Carryout - (" + CarryTime[NumDigits-1] + ")units<BR>"
*/

	Middle += "<BR><BR><HR><BR><B> SUM DELAY AT EACH BIT POSITION </B><BR><BR>"
	Middle += "<BR>Basic Adder Type: <B>" + AdderType + "</B><BR><BR>"

	bigwidth = 150 * (NumDigits-NumDecimals)
	bigwidth = bigwidth/2

	Middle += "<TABLE BORDER CELLSPACING=4 BORDERCOLOR=#000000 CELLPADDING=7 WIDTH=" + bigwidth +">"
	bigwidth = 100/(NumDigits-NumDecimals);
	Middle += "<P ALIGN=CENTER>"
	
	Middle += "<TR>"
	Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER> Bit Number </TD>"

	/*
	for (counter = NumDigits-1; counter >= NumDecimals; counter--) 
	{
			Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER>" + counter + "</TD>"
	}
	*/

	color_val = new Array("ffcc00","ff9999","ccff66","00cc99","00ffcc","ffccff","66ffff","cccccc")
	bit_count = 0;
	bit_count = NumDigits - 1;
	for(i=NumAdders-1;i>=0;i--)
	{
		color_select = color_val[i%8];
		for(j=BasicAdderSize[i]-1;j>=0;j--)
		{ 
			Middle += "<TD  VALIGN=TOP BGCOLOR =#" + color_select + " WIDTH=" + bigwidth +"><P ALIGN=CENTER>" + bit_count + "</TD>"
			bit_count--;

		}
	}

	Middle += "</TR>"

	Middle += "<TR>"
	Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER> Basic Adder Delay </TD>"
	for (counter = NumDigits-1; counter >= NumDecimals; counter--) 
	{
			ComboSumTime[counter] = 1000 * ComboSumTime[counter];
            		ComboSumTime[counter] = Math.round(ComboSumTime[counter])/1000;   
			Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER>"  + "(" + ComboSumTime[counter] + ") units" + "</TD>"
	}
	Middle += "</TR>"

	Middle += "<TR>"
	Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER>  Mux Delay </TD>"
	for (counter = NumDigits-1; counter >= NumDecimals; counter--) 
	{
			MuxTime[counter] = 1000 * MuxTime[counter];
            		MuxTime[counter] = Math.round(MuxTime[counter])/1000;   
			Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER>"  + "(" + MuxTime[counter] + ") units" + "</TD>"
	}
	Middle += "</TR>"

	Middle += "<TR>"
	Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER> Final Sum Delay </TD>"
	for (counter = NumDigits-1; counter >= NumDecimals; counter--) 
	{
			FinalSumTime[counter] = 1000 * FinalSumTime[counter];
            		FinalSumTime[counter] = Math.round(FinalSumTime[counter])/1000;   
			Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER>"  + "(" +FinalSumTime[counter] + ") units" + "</TD>"
	}
	Middle += "</TR>"

	
	Middle += "</P>"
	Middle += "</TABLE>"


	Middle += "<BR>"

	
				
	Bottom = "</BODY> </HTML>";

	if (Overflow)  { Middle = PrintError("Overflow") }
	if (Mixed)     { Middle = PrintError("Mixed numbers") }
	if (NotBinary) { Middle = PrintError("At least one number is non-binary") }
	//if (Group_Mismatch) { Middle = PrintError("Basic adder size not a multiple of the number of bits") }
	//if (Group_Zero)	{Middle = PrintError("Enter a non-zero value for group size") }
	if (IndAdderToBits) { Middle = PrintError("Sum of bits in the individual adders is not equal to the total bits specified") }
	if (AdderSizeZero) { Middle = PrintError("At least one adder size is zero") }

	parent.frames[1].document.open()
	parent.frames[1].document.write(TheTop);
	parent.frames[1].document.write(Middle);

/*
	parent.frames[1].document.write("Sum0&nbsp;&nbsp;&nbsp;&nbsp;");	
	for(i=NumGroups-1;i>=0;i--)
	{
		for(j=AdderSize-1;j>=0;j--)
		{
			parent.frames[1].document.write(SumGroup_0[i][j]);
		}
		parent.frames[1].document.write("&nbsp;&nbsp;");
	}
	
	parent.frames[1].document.write("<br>");

	parent.frames[1].document.write("Carry0&nbsp;&nbsp;");	
	for(i=NumGroups-1;i>=0;i--)
	{
		for(j=AdderSize-1;j>=0;j--)
		{
			parent.frames[1].document.write(CarryGroup_0[i][j]);
		}
		parent.frames[1].document.write("&nbsp;&nbsp;");
	}
	
	parent.frames[1].document.write("<br><br>");

	parent.frames[1].document.write("Sum1&nbsp;&nbsp;&nbsp;&nbsp;");
	for(i=NumGroups-1;i>=0;i--)
	{
		for(j=AdderSize-1;j>=0;j--)
		{
			parent.frames[1].document.write(SumGroup_1[i][j]);
		}
		parent.frames[1].document.write("&nbsp;&nbsp;");
	}
	
	parent.frames[1].document.write("<br>");

	parent.frames[1].document.write("Carry1&nbsp;&nbsp;");	
	for(i=NumGroups-1;i>=0;i--)
	{
		for(j=AdderSize-1;j>=0;j--)
		{
			parent.frames[1].document.write(CarryGroup_1[i][j]);
		}
		parent.frames[1].document.write("&nbsp;&nbsp;");
	}

	parent.frames[1].document.write("<br><br>");
*/

/*
	parent.frames[1].document.write("Level1 Mux0 Value &nbsp;&nbsp;");
	for(i=AdderSize-1;i>=0;i--)
		parent.frames[1].document.write(MuxGroup_0[NumGroups-2][i]+"&nbsp;");

	parent.frames[1].document.write("<br><br>");

	parent.frames[1].document.write("Level1 Mux1 Value &nbsp;&nbsp;");
	for(i=AdderSize-1;i>=0;i--)
		parent.frames[1].document.write(MuxGroup_1[NumGroups-2][i]+"&nbsp;");

	parent.frames[1].document.write("<br><br>");

	parent.frames[1].document.write("Level2 Mux0 Value &nbsp;&nbsp;");
	for(i=(2*AdderSize)-1;i>=0;i--)
		parent.frames[1].document.write(MuxGroup_0[NumGroups-2-1][i]+"&nbsp;");

	parent.frames[1].document.write("<br><br>");

	parent.frames[1].document.write("Level2 Mux1 Value &nbsp;&nbsp;");
	for(i=(2*AdderSize)-1;i>=0;i--)
		parent.frames[1].document.write(MuxGroup_1[NumGroups-2-1][i]+"&nbsp;");
		
	parent.frames[1].document.write("<br><br>");
	
	parent.frames[1].document.write("Level3 Mux0 Value &nbsp;&nbsp;");
	for(i=(3*AdderSize)-1;i>=0;i--)
		parent.frames[1].document.write(MuxGroup_0[NumGroups-2-2][i]+"&nbsp;");
		
	parent.frames[1].document.write("<br><br>");
*/

/*
	parent.frames[1].document.write("FinalCondSum &nbsp;&nbsp;");
	for(i=NumBits-1;i>=0;i--)
		parent.frames[1].document.write(FinalCondSum[i]+"&nbsp;");
*/

		
/*
	parent.frames[1].document.write("Decimal Value of A:"+A);
	parent.frames[1].document.write("<br>");
	parent.frames[1].document.write("Decimal Value of B:"+B);
	parent.frames[1].document.write("<br>");
	if(ChoseRipple)
		parent.frames[1].document.write("Basic Adder Type is Ripple Carry");
	if(ChoseManchester)
		parent.frames[1].document.write("Basic Adder Type is Manchester Carry");
*/
	parent.frames[1].document.write(Bottom);
	parent.frames[1].document.close()

}


//************************************
//	END SCRIPT
//************************************

</script>
</head>


<body bgcolor="#9FD854">

<center><h2>Generalized Conditional Sum Adder</h2></center>
<form>A:
<input type="text" name="A">
<br>B:
<input type="text" name="B">
<br><i>bin<input type="radio" name="Base" value="Binary" checked>dec</i><input type="radio" name="Base" value="Decimal">

<hr>


<table BORDER>

<tr>
<td>Total Bits</td>
<td><input type="text" name="NumBits" value=12 size=4></td>
</tr>

<tr>
<td>Individual Adder Size</td>
<td><input type="string" name="IndAdderSize" size=5></td>
</tr>

<tr>
<td>Basic Adder Type</td>
<td><select name="AdderType" size=1><option selected>Ripple Carry</option><option>Manchester Carry</option></select></td>
<td>

<tr>
<td>Adder Structure</td>
<td><select name="AdderStructure" size=1><option selected>Assymetric</option><option>Symmetric</option></select></td>
<td>

</table>

<hr>

<table BORDER >
<caption><b>Signal Delays</b></caption>

<tr>
<td>A<sub>i</sub> to C<sub>i+1</sub></td>
<td><input type="text" name="AToCout" value=2.2 size=4></td>
<td>C<sub>i</sub> to C<sub>i+1</sub></td>
<td><input type="text" name="CinToCout" value=1.9 size=4></td>
</tr>

<tr>
<td>C<sub>i</sub> to S<sub>i  </sub></td>
<td><input type="text" name="CinToSum" value=2.5 size=4></td>
<td>A<sub>i</sub> to S<sub>i  </sub></td>
<td><input type="text" name="AToSum" value=2.6 size=4></td>
</tr>

<tr>
<td>Mux Delay</td>
<td><input type="text" name="muxdel" value=1.4 size=4></td>
<td>Switch Delay</td>
<td><input type="text" name="switchdel" value=0.6 size=4></td>
</tr>

<TR>
<TD>Basic Gate Delay</TD>
<TD><INPUT type="text" name="singleGateDelay" value=1.0 size=4></TD>
<TD>Ex-OR Gate Delay</TD>
<TD><INPUT type="text" name="exorGateDelay" value=1.4 size=4></TD>
</TR>

</table>

<center>
<p><input type="button" name="enter" value="Compute" onClick="CondSumAdd(this.form)">
<p><input TYPE="Reset"  VALUE="   Reset   " onClick=parent.frames[1].location.href="../tablet.html">
<p><input TYPE="button"  VALUE="   Help    " onClick=parent.frames[1].location.href="help.html">
</center>

</form>
</body>
</html>

