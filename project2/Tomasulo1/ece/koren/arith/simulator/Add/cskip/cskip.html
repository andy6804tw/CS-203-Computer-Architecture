<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.72 [en] (X11; U; Linux 2.2.12-20 i686) [Netscape]">
   <title> Carry Skip Adder with Timing</title>
<script language="LiveScript">



function MakeLine(NumColumns) 
{
        return "<TR> <TD colspan=" + NumColumns + "> <HR noshade size=1>\n";
}

function PrintError(Message) 
{
        Error = "<CENTER><H1> ERROR </H1></CENTER> <P>\n"
        Error += "<CENTER> <EM>" + Message + "</EM> </CENTER>\n"
        return Error
}

function IsInteger(Num) 
{
        return (Num == Math.floor(Num))
}

function OrderOfMagnitude (TheNum) 
{
        // returns the highest place which has a "1" in TheNum's
        // binary representation

        // to account for 2's complement representation...
        TheNum < 0 ? TheNum = (TheNum * -2) - 2 : TheNum *= 2

        LogBaseTwo = Math.log(TheNum)/Math.LN2;
        return Math.floor(LogBaseTwo)
}

function ParseBinary (BinNum) 
{
        // Turns a binary number into a decimal, sets a flag to true if
        // BinNum is not actually binary

        IsNeg = false
        if (BinNum < 0) 
        {
                IsNeg = true
                BinNum *= -1
        }
        RealNum = 0
        BinNum += Math.pow(10, -1 - NumBits) // kludge so processor
                                             // won't mess up
        LogBaseTen = Math.log(BinNum)/Math.LN10
        HighestPlace = Math.ceil(LogBaseTen)
        for (CurPlace = HighestPlace; CurPlace >= -NumBits; CurPlace--) 
        {
                CurEntry = Math.floor(BinNum / Math.pow(10, CurPlace))
                if (CurEntry != 0 && CurEntry != 1) 
                {
                        NotBinary = true
                        CurEntry = 1 // feed it something normal, to avoid
                                         // wierd Javascript errors
                }
                if (CurEntry == 1) 
                {
                        RealNum += Math.pow(2, CurPlace)
                        BinNum -= Math.pow(10, CurPlace)
                }
        }
        if (IsNeg) {RealNum *= -1} // reverse it back at the end

        // now check if the number was negative according to two's complement
        // representation - if it was, set the decimal value to this negative
        // number
        if (HighestPlace == NumBits)
                RealNum -= Math.pow(2, NumBits)

        if (HighestPlace == 1 && RealNum!=1 )
                RealNum -= Math.pow(2, 1)

        return RealNum
}

function RoundOff (TheNum) 
{
        // returns the value TheNum would have if it were represented by
        // NumDecimals bits after the decimal point
        Scaling = Math.pow(2, NumDecimals)
        return (Math.floor(TheNum * Scaling) / Scaling)
}



function PrintTwosComp(TheNum, StartPlace) 
{

        // first deal with negative numbers...
        if (TheNum < 0) {TheNum += Math.pow(2, StartPlace)}

        // now initialize the string
        S = "";
        S += "<TD> ";
        for (CurPlace = StartPlace - 1; CurPlace >= -NumDecimals; CurPlace--) 
        {
                if (CurPlace == -1) 
                {
                        S += ".";
                }
                CurPower = Math.pow(2, CurPlace);
                if (TheNum >= CurPower) 
                {
                        S += "1 ";
                        TheNum -= CurPower
                } 
                else 
                {
                        S += "0 "
                } 
        }
        return S;
}


function PrintNum(Num, Bits)
{
        S = "";
//      S += "</TD> ";
        for (CurPlace = Bits - 1 ; CurPlace >= 0; CurPlace--)
        {
                CurPower = Math.pow(2, CurPlace);
                if (Num >= CurPower)
                {
                        S += "1 ";
                        Num -= CurPower
                }
                else
                {
                        S += "0 "
                }
        }
        return S;
}


function PrintNumInGif(Num, Bits, CinFlag)
{
        S = "";
//      S += "</TD> ";
        for (CurPlace = Bits - 1 ; CurPlace >= 0; CurPlace--)
        {
                CurPower = Math.pow(2, CurPlace);
                if (Num >= CurPower)
                {
                        if(CinFlag == 1)
                                if(NumBits > 16 )
                                        S += "<IMG SRC = ./../images2/1cin1_s.gif>"
                                else
                                        S += "<IMG SRC = ./../images2/1cin1.gif>"
                        else
                                if(NumBits > 16 )
                                        S += "<IMG SRC = ./../images2/1cin0_s.gif>"
                                else
                                        S += "<IMG SRC = ./../images2/1cin0.gif>"
                        Num -= CurPower
                }
                else
                {
                        if(CinFlag == 1)
                                if(NumBits > 16 )
                                        S += "<IMG SRC = ./../images2/0cin1_s.gif>"
                                else
                                        S += "<IMG SRC = ./../images2/0cin1.gif>"
                        else
                                if(NumBits > 16 )
                                        S += "<IMG SRC = ./../images2/0cin0_s.gif>"
                                else
                                        S += "<IMG SRC = ./../images2/0cin0.gif>"
                }
        }
        return S;
}


function PrintSumInGif(Num, Bits)
{
        S = "";
//      S += "</TD> ";
        for (CurPlace = Bits - 1 ; CurPlace >= 0; CurPlace--)
        {
                CurPower = Math.pow(2, CurPlace);
                if (Num >= CurPower)
                {
                        if(NumBits > 16 )
                                S += "<IMG SRC = ./../images/1_s.gif>"
                        else
                                S += "<IMG SRC = ./../images/1.gif>";
                        Num -= CurPower
                }
                else
                {       if(NumBits > 16 )
                                S += "<IMG SRC = ./../images/0_s.gif>"
                        else
                                S += "<IMG SRC = ./../images/0.gif>"
                }
        }
        return S;
}


function FeedIntoVariable(TheNum, StartPlace, ReturnArray) 
{
        if (TheNum < 0) {TheNum += Math.pow(2, StartPlace)}

        // now initialize the string
        index = StartPlace - 1
        for (CurPlace = StartPlace - 1; CurPlace >= -NumDecimals; CurPlace--) 
        {
                if (CurPlace == -1) 
                {
                        ReturnArray[index] = 2;
                        index --
                }
                CurPower = Math.pow(2, CurPlace);
                if (TheNum >= CurPower) 
                {
                        ReturnArray[index] = 1;
                        index --
                        TheNum -= CurPower
                } 
                else 
                {
                        ReturnArray[index] = 0;
                        index --;
                } 
        }
        return ReturnArray
}


function PrintSumCarry(Middle)
{
    Middle += MakeLine(NumCols + 3)
    Middle += "<TR><TD><TD>"
    Middle += "<TR><TD>Carry     :    <TD><TD>" 
        for (loop=NumDigits;loop>=1;loop--)
                Middle += " " + FinalCarry[loop];
        Middle += "<TR><TD>Generate     :    <TD><TD>" 
        for (loop=NumDigits-1;loop>=0;loop--)
                Middle += " " + Generate[loop];
        Middle += "<TR><TD>Propagate     :    <TD><TD>" 
        for (loop=NumDigits-1;loop>=0;loop--)
                Middle += " " + Propagate[loop];
    Middle += "<TR><TD>Sum       :    <TD><TD>"
        for (loop=NumDigits-1;loop>=0;loop--)
                Middle += " " + FinalSum[loop]
        

        return Middle
}


//Next function returns the larger of two numbers
function GetMax(Number1, Number2)
{
        if (Number1 > Number2)
                bigger = Number1
        else
                bigger = Number2

        return bigger
}


//Next function returns the smaller of two numbers
function GetMin(Number1, Number2)
{
        if (Number1 < Number2)
                smaller = Number1
        else
                smaller = Number2

        return smaller
}


//This function parses the number into groups
function MakeGroup(Number, NoOfGroups, BlockSizeArray, Grouped)
{
        temp=0
        for(index=0; index<NoOfGroups; index++)
        {
                for(secindex=0; secindex < BlockSizeArray[index]; secindex++)
                       Grouped[index][secindex] = Number[temp+secindex]
                temp += secindex
        }
        return Grouped
}

//Next function returns the time needed to Calculate the Sum-time of this adder block
function CalculateSumTime(AToSum, CinToSum, PrevCarryTime)
{
        if (PrevCarryTime == 0)
                finalTime = GetMax(AToSum, CinToSum)
        else
        {
                if (CinToSum > AToSum)
                        finalTime = PrevCarryTime + CinToSum
                else
                {
                        if (PrevCarryTime < AToSum)
                        {
                                difference = AToSum - CinToSum
                                finalTime = GetMax(difference, CinToSum) + PrevCarryTime
                        }
                        else
                                finalTime = CinToSum + PrevCarryTime
                }
        }

        //Cross-checking for trivial case
        if (finalTime < AToSum)
                finalTime = AToSum
        if (finalTime < CinToSum)
                finalTime = CinToSum

        return finalTime
}


//Next function returns the time needed to Calculate the Carry-time of this adder block
function CalculateCarryTime(AToCout, CinToCout, PrevCarryTime)
{
        if (PrevCarryTime == 0)
                CarryOutTime = GetMax(AToCout, CinToCout)
        else
        {
                if (CinToCout > AToCout)
                        CarryOutTime = PrevCarryTime + CinToCout
                else
                {
                        if (PrevCarryTime < AToCout)
                        {
                                difference = AToCout - CinToCout
                                CarryOutTime = GetMax(difference, CinToCout) + PrevCarryTime
                        }
                        else
                                CarryOutTime = CinToCout + PrevCarryTime
                }
        }

        //Cross-checking for trivial case
        if (CarryOutTime < AToCout)
                CarryOutTime = AToCout
        if (CarryOutTime < CinToCout)
                CarryOutTime = CinToCout

        return CarryOutTime
}



function CarrySkipAdd(form) 
{
        TheTop = "<HTML><HEAD><TITLE>Tablet</TITLE></HEAD><BODY bgcolor=white>";

        A = parseFloat(form.A.value)
        B = parseFloat(form.B.value)


        CinToSum = parseFloat(form.CinToSum.value)
        AToSum = parseFloat(form.AToSum.value)
        CinToCout = parseFloat(form.CinToCout.value)
        AToCout = parseFloat(form.AToCout.value)
        t_buff = parseFloat(form.t_buff.value)
        t_skip = parseFloat(form.t_skip.value)

        BlkSizes = form.IndBlkSize.value.split(" ");
        Numblocks = BlkSizes.length

        Cskablocksize = new Array(Numblocks)

        for(index=0; index < Numblocks; index++)
                Cskablocksize[index] =  parseInt(BlkSizes[index])
        
        IndblkTotBits = false

        checksum = 0

        for(index=0; index < Numblocks; index++)
                checksum += Cskablocksize[index]


        ChoseBin = form.Base[0].checked
        ChoseDec = form.Base[1].checked
        NumBits = parseInt(form.NumBits.value)
        NotBinary = false
        if (ChoseBin) 
        {
                A = ParseBinary(A)
                B = ParseBinary(B)
        }

        if(checksum != NumBits)
                IndblkTotBits = true

        Mixed = false
        Overflow = false
        FractionalNum = (Math.abs(A) < 2) && (Math.abs(B) < 2)
        // bit to left of dec. pt. is sign bit 
        if (IsInteger(A) & IsInteger(B)) 
        {
                NumDecimals = 0
                NumDigits = NumBits
                if (Math.max(OrderOfMagnitude(A), OrderOfMagnitude(B)) + 1 > NumDigits) 
                {
                        NumDigits = 0
                        NumDecimals = 0
                        Overflow = true
                }
        } 
        else 
        {
                if (FractionalNum) 
                {
                        NumDigits = 1
                        NumDecimals = NumBits - 1
                } 
                else 
                {
                        Mixed = true
                        NumDigits = 0
                        NumDecimals = 0    // just filler values 
                }
        }

        NumCols = (2 * NumDigits - 1) + NumDecimals


        A = RoundOff(A)
        B = RoundOff(B)

        Middle = "<TABLE>"

        // now initialize two Input Arrays & two 
        // output arrays & two intermediate arrays
        FirstNumber = new Array(NumDigits)
        FeedIntoVariable(A, NumDigits,FirstNumber)
        SecondNumber = new Array(NumDigits)
        FeedIntoVariable(B, NumDigits,SecondNumber)

        //For numbers divided into groups for the carry look ahead adder.
        GroupedA = new Array(Numblocks) 
        GroupedB = new Array(Numblocks)

        // Decimal equvivalent of all the groups! Easy for Addition
        numadec = new Array(Numblocks)
        numbdec = new Array(Numblocks)

        for(index=0; index<Numblocks; index++)
        {
                GroupedA[index] = new Array(Cskablocksize[index])
                GroupedB[index] = new Array(Cskablocksize[index])
        }

        // A & B are divided into groups
        MakeGroup(FirstNumber, Numblocks, Cskablocksize, GroupedA)
        MakeGroup(SecondNumber, Numblocks, Cskablocksize, GroupedB)     

        //initialized to zero
        for(index=0; index < Numblocks; index++)
        {
                        numadec[index] = 0
                        numbdec[index] = 0
        }

   	
	//***************************************************************************
	// Now we come to the actual Carry Skip calculation part !!!!
	//***************************************************************************
	IndivCarry = new Array(NumDigits);
	IndivSum = new Array(NumDigits);
	IndivP = new Array(NumDigits);
	IndivG = new Array(NumDigits);
	GroupP = new Array(Numblocks);
	GroupCin = new Array(Numblocks);
	GroupCout = new Array(Numblocks)
	
	
	// Calculate Generate, Propagate, Sum and Carry for all bits
	for(index=0; index<NumDigits; index++)
	{
		IndivG[index] = FirstNumber[index] & SecondNumber[index]
		IndivP[index] = FirstNumber[index] | SecondNumber[index]
		if(index == 0) {
         	   //IndivCarry[0] = 0;
		   carryin = 0
		}
		else {
		  carryin = IndivCarry[index-1] 
		}
		carryout1 = FirstNumber[index] & SecondNumber[index]
		carryout2 = carryin & FirstNumber[index]
		carryout3 = carryin & SecondNumber[index]
		carryout = carryout1 | carryout2 | carryout3
		IndivCarry[index] = carryout
		IndivSum[index] = FirstNumber[index] ^ SecondNumber[index] ^ carryin
	}	

	// calculate the block carry in and carry out.	

	BitCtr = 0
	for(BlkCtr=0; BlkCtr<Numblocks; BlkCtr++) {
	    if(BlkCtr == 0) {
	       GroupCin[BlkCtr] = 0;
	    }
 	    else {
	       GroupCin[BlkCtr] = GroupCout[BlkCtr-1]
	    }

	    for(secindex=0; secindex<Cskablocksize[BlkCtr]; secindex++) {
	        GroupP[BlkCtr] = GroupCin[BlkCtr]
		   	if(IndivP[BitCtr] == 0){
		      GroupP[BlkCtr] = 0;
		    }	    
		    BitCtr++   
        }
	    
	    
	    if(BlkCtr == 0) {
	       GroupCout[BlkCtr] = IndivCarry[Cskablocksize[BlkCtr]-1]
	    }
 	    else {
	       GroupCout[BlkCtr] = (GroupCout[BlkCtr-1] & GroupP[BlkCtr]) | (IndivCarry[Cskablocksize[BlkCtr]-1])
	    }
	    
	}	

	// Lets get down to printing the images from gif files now....
  
        // Print corresponding bit values of A & B above Adder Block
        Middle += "<PRE>"
        Middle += "<BR>"
        Middle += "<IMG SRC = ./images2/blank.gif>"
	Middle += "<IMG SRC = ./images2/blank_line1.gif>"		
        //print the input bits of A and B

	BitCtr = NumDigits 
	for(BlkCtr = Numblocks-1; BlkCtr>=0; BlkCtr--)
	{
	   for(secindex = Cskablocksize[BlkCtr]-1; secindex>=0; secindex--)
	   { 
	      BitCtr--
	      if ((FirstNumber[BitCtr] == 0) && (SecondNumber[BitCtr] == 0))
		      Middle += "<IMG SRC = ./images2/00.gif>"	 
              
	      if ((FirstNumber[BitCtr] == 0) && (SecondNumber[BitCtr] == 1))
                  Middle += "<IMG SRC = ./images2/01.gif>"
	      
          if ((FirstNumber[BitCtr] == 1) && (SecondNumber[BitCtr] == 0))
                 Middle += "<IMG SRC = ./images2/10.gif>"
     
          if ((FirstNumber[BitCtr] == 1) && (SecondNumber[BitCtr] == 1))
        	 Middle += "<IMG SRC = ./images2/11.gif>"	

	   }
	   Middle += "<IMG SRC = ./images2/blank_line1.gif>"		
	}
	Middle += "<BR>"
	   Middle += "<IMG SRC = ./images2/blank.gif>"		


	// Now lets print the line of FAs and buffers 
	
	BitCtr = NumDigits
	for(BlkCtr = Numblocks-1; BlkCtr>=0; BlkCtr--)
        {
           for(secindex = Cskablocksize[BlkCtr]-1; secindex>=0; secindex--)
           {  
	           BitCtr--
		       if(BitCtr == NumDigits-1){
			
           	     if(IndivCarry[BitCtr] == 0) {
                        Middle += "<IMG SRC = ./images2/msb_buff_c0.gif>"
                        Middle += "<IMG SRC = ./images2/gp_carry0.gif>"
		         }
		         else {      
					   Middle += "<IMG SRC = ./images2/msb_buff_c1.gif>"
                       Middle += "<IMG SRC = ./images2/gp_carry1.gif>"
		     	 }
		       }
	          
	           Middle += "<IMG SRC = ./images2/fabox.gif>"  	
		       if(BitCtr == 0) {
		          Middle += "<IMG SRC = ./images2/lsb_c0.gif>"  
		       }
	   	   }
                   //Middle += "<IMG SRC = ./images2/blank.gif>"
		   if(BlkCtr != 0) {	
		      if(IndivCarry[BitCtr-1] == 0) {
                        Middle += "<IMG SRC = ./images2/buff_c0.gif>"
                        Middle += "<IMG SRC = ./images2/gp_carry0.gif>"
 		      }

		      if(IndivCarry[BitCtr-1] == 1) {
                        Middle += "<IMG SRC = ./images2/buff_c1.gif>"
                        Middle += "<IMG SRC = ./images2/gp_carry1.gif>"
		      }


		   }
	}

	Middle += "<BR>"
        Middle += "<IMG SRC = ./images2/blank_line1.gif>"
	 	
	// Print the sum bits now	

	BitCtr = NumDigits
	for(BlkCtr = Numblocks-1; BlkCtr>=0; BlkCtr--)
        {
           for(secindex = Cskablocksize[BlkCtr]-1; secindex>=0; secindex--)
           {
	            BitCtr--
	            if((BlkCtr == Numblocks-1) && (BitCtr == NumDigits-1)) {
		   	        if(GroupP[BlkCtr] == 0){			
                        Middle += "<IMG SRC = ./images2/buff_in_vert0.gif>"
	        		}
	        	    if(GroupP[BlkCtr] == 1){			
           	  			Middle += "<IMG SRC = ./images2/buff_in_vert1.gif>"
	        		} 
	      		}	   	   
		
		if(secindex == Cskablocksize[BlkCtr]-1){
		    if(GroupP[BlkCtr] == 1){
			if(IndivSum[BitCtr] == 1) {
                           Middle += "<IMG SRC = ./images2/sum1_skip.gif>"
			}
			else {
                           Middle += "<IMG SRC = ./images2/sum0_skip.gif>"
			}
		    } 
		    else{ // GroupP[BlkCtr] is 0
			if(IndivSum[BitCtr] == 1) {
                           Middle += "<IMG SRC = ./images2/sum1_ripple.gif>"
			}
			else {
                           Middle += "<IMG SRC = ./images2/sum0_ripple.gif>"
			}



		    }
		}
		else{
	      	   if(IndivSum[BitCtr] == 0)
                      Middle += "<IMG SRC = ./images2/sum0.gif>"
                   else if(IndivSum[BitCtr] == 1)
                     Middle += "<IMG SRC = ./images2/sum1.gif>"
	           }
	       }	
	     
	        Middle += "<IMG SRC = ./images2/buff_out_vert.gif>"
    	    if(BlkCtr != 0) {	
	     	    if(BlkCtr == 1) {
	        	   Middle += "<IMG SRC = ./images2/buff_in_vert0.gif>"
	     		}    	  
	       		else {
	       	   		if(GroupP[BlkCtr-1] == 0){			
                        Middle += "<IMG SRC = ./images2/buff_in_vert0.gif>"
	       	   		}
	       	        if(GroupP[BlkCtr-1] == 1){			
           	    	    Middle += "<IMG SRC = ./images2/buff_in_vert1.gif>"
	       	   		}
	     		}
   		    }
	  
	}


	ActualSum = A + B
    
	
	Middle += "<BR>"
	Middle += "<BR>"
        Middle += "<BR>"
	Middle += "<BR>"
	Middle += "<BR>"

	Middle += "<TR> <TD>A<TD>"
	Middle += PrintTwosComp(A, NumDigits)
	Middle += "<TD>  <TD>  :  " + A + "<br>"
	Middle += "<TR> <TD>B<TD>+"
	Middle += PrintTwosComp(B, NumDigits)
	Middle += "<TD>  <TD>  :  " + B + "<br>"
   	Middle += MakeLine(NumCols + 3)
	Middle += "<TR> <TD>Sum<TD>"
	Middle += PrintTwosComp(ActualSum, NumDigits)
	Middle += "<TD>  <TD>  :  <B>" + ActualSum + "</B><br>"
	Middle += "</TABLE><BR>"



	// Okay.. so far so good! Now let us get the delay information.
	// Timing Calculations.
        

    	CarryDelay = new Array(Numblocks+1)
    	BlockSumTime = new Array(Numblocks)
    	BlockCarryTime = new Array(Numblocks)
    	FinalSumTime =  new Array(Numblocks)
    	FinalCarryInTime = new Array(Numblocks+1)
    	SumDelayFinal = new Array(Numblocks)
    	SumTimeBlock = new Array(Numblocks)
    	CinTimeBits = new Array(NumDigits)
    	FinalSumAvail =  new Array(Numblocks)
	
	
	BitCtr = 0 
	for(BlkCtr=0; BlkCtr<Numblocks; BlkCtr++){
		OldCarryTime = 0 
		OldSumTime = 0 
		for(ctr=0; ctr<Cskablocksize[BlkCtr]; ctr++){
		   //CinTimeBits[BitCtr] = OldCarryTime
     	   TempCarryTime = CalculateCarryTime(AToCout, CinToCout, OldCarryTime)
	       TempSumTime = CalculateSumTime(AToSum, CinToSum, OldCarryTime)
		   OldCarryTime = TempCarryTime
		   OldSumTime = TempSumTime
	  	} 
    	BlockSumTime[BlkCtr] = OldSumTime
		BlockCarryTime[BlkCtr] = OldCarryTime
		if(GroupP[BlkCtr] == 1){
		  BlockCarryTime[BlkCtr] = t_skip
		}
		BitCtr++
	}


    	FinalCarryInTime[0] = 0
	for(BlkCtr=0; BlkCtr<Numblocks; BlkCtr++){
          BlockSumTime[BlkCtr] *= 1000
          BlockCarryTime[BlkCtr] *= 1000
          BlockSumTime[BlkCtr] = Math.round(BlockSumTime[BlkCtr])/1000
          BlockCarryTime[BlkCtr] = Math.round(BlockCarryTime[BlkCtr])/1000
	   if(BlockSumTime[BlkCtr] > BlockCarryTime[BlkCtr]) {
		  FinalSumTime[BlkCtr] = BlockSumTime[BlkCtr] 
		  //FinalSumAvail[BlkCtr] = FinalCarryInTime[BlkCtr] + FinalSumTime[BlkCtr]
	   }
	   else {
		  FinalSumTime[BlkCtr] = BlockCarryTime[BlkCtr] 
	   }
	   FinalSumAvail[BlkCtr] = FinalCarryInTime[BlkCtr] + FinalSumTime[BlkCtr]

	  if(GroupP[BlkCtr] == 1){
	     FinalCarryInTime[BlkCtr+1] = FinalCarryInTime[BlkCtr] + t_skip + t_buff
	  }
	  else {
		 FinalCarryInTime[BlkCtr+1] = FinalSumAvail[BlkCtr] + t_buff

	  }

	  
      	  FinalCarryInTime[BlkCtr] *= 1000
          FinalCarryInTime[BlkCtr] = Math.round(FinalCarryInTime[BlkCtr])/1000
          FinalSumAvail[BlkCtr] *= 1000
          FinalSumAvail[BlkCtr] = Math.round(FinalSumAvail[BlkCtr])/1000

	}


//Printing the Timing results in a table

        bigwidth = 30
        Middle += "<BR><BR><HR><BR><B>Signal Delay Table</B><BR><BR>"
		
		Middle += "<TABLE BORDER CELLSPACING=4 BORDERCOLOR=#800080 CELLPADDING=7 WIDTH=" + bigwidth +">"
        Middle += "<P ALIGN=CENTER>"
        Middle += "<TR>"
        Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER> BlockNumber</TD>"

       for (counter = Numblocks; counter > 0; counter--){
        	Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER>" + counter + "</TD>"
		}

        Middle += "</TR>"
        Middle += "<TR>"
        Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER>  SumDelay for the block</TD>"

       for (counter = Numblocks-1; counter >= 0; counter--)
              Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER>" + "(" + FinalSumTime[counter]  + ")units" + "</TD>"

 		Middle += "</TR>"
        Middle += "<TR>"
        Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER>  Carry in available at</TD>"
        for (counter = Numblocks-1; counter >= 0; counter--)
                Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER>" + "(" + FinalCarryInTime[counter] + ")units" + "</TD>"


 		Middle += "</TR>"
        Middle += "<TR>"
        Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER>  Sum available at</TD>"
        for (counter = Numblocks-1; counter >= 0; counter--)
                Middle += "<TD  VALIGN=TOP WIDTH=" + bigwidth +"><P ALIGN=CENTER>" + "(" + FinalSumAvail[counter] + ")units" + "</TD>"

        Middle += "</TR>"
        Middle += "</P>"
        Middle += "</TABLE>"

        Middle += "<BR>"




        Bottom = "</BODY> </HTML>";

        if (Overflow)  { Middle = PrintError("Overflow") }
        if (Mixed)     { Middle = PrintError("Mixed numbers") }
        if (NotBinary) { Middle = PrintError("At least one number is non-binary ") }
        if (IndblkTotBits) { Middle = PrintError("Sum of Bits in the individual blocks is not equal to the Total Bits specified") }


        parent.frames[1].document.open()
        parent.frames[1].document.write(TheTop);
        parent.frames[1].document.write(Middle);
        parent.frames[1].document.write(Bottom);
        parent.frames[1].document.close()


//***************************************************************************
        
}

</SCRIPT>
</HEAD>

<BODY bgcolor="#9FD854">

<CENTER> <H2> Carry Skip Adder </H2> </CENTER>

<FORM>

A: <input type="text" name="A" size = 18>
<br>B: <input type="text" name="B" size = 18>

<br>
<EM>bin</EM><INPUT type="radio" name="Base" value="Binary" checked>
<EM>dec</EM> <INPUT type="radio" name="Base" value="Decimal"><P>

<table>
<tr>
<td>Total Bits</td>

<td><input type="text" name="NumBits" value=12 size=4></td>
</tr>

<tr>
<td>Individual Block Sizes</td>

<td><input type="string" name="IndBlkSize" size=5></td>
</tr>
</table>

<hr>



<TABLE BORDER>
<CAPTION><B>Signal Delays</B></CAPTION>
<TR>
<TD>A<SUB>i</SUB> to C<SUB>i+1</SUB></TD>
<TD><INPUT type="text" name="AToCout" value=2.2 size=4></TD>
<TD>C<SUB>i</SUB> to C<SUB>i+1</SUB></TD>
<TD><INPUT type="text" name="CinToCout" value=1.9 size=4></TD>
</TR>

<TR>
<TD>C<SUB>i</SUB> to S<SUB>i  </SUB></TD>
<TD><INPUT type="text" name="CinToSum" value=2.5 size=4></TD>
<TD>A<SUB>i</SUB> to S<SUB>i  </SUB></TD>
<TD><INPUT type="text" name="AToSum" value=2.6 size=4></TD>
</TR>
<TR>
<TD>Buffer Delay</td>
<TD><input type="text" name="t_buff" value=1.4 size=4></td>
<TD>Skip Delay</td>
<TD><INPUT type="text" name="t_skip" value=2.0 size=4></TD>
</TR>
</TABLE>

<p>
<CENTER>
<INPUT type="button" name="enter" value="Compute" onClick="CarrySkipAdd(this.form
)">
</CENTER>
</p>

<p>
<CENTER>
<INPUT TYPE="Reset"  VALUE="   Reset   " onClick=parent.frames[1].location.href="../tablet.html"
>
</CENTER>
</P>

<p>
<CENTER>
<INPUT TYPE="button"  VALUE="    Help    " onClick=parent.frames[1].location.href="help.html">
</CENTER>
</P>

</FORM>

</BODY>
</HTML>
