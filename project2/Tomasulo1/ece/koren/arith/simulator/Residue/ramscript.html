<HTML>
<HEAD>
<TITLE> Residue Arithmetic </TITLE>
<SCRIPT language="JavaScript">

function MakeLine(NumColumns) 
{
    return "<TR> <TD colspan=" + NumColumns + "> <HR color=#000000 noshade size=1>\n";
}

//*************************************************************************
//
//	PROCEDURE : validModuli
//
//	INPUTS : mList: the list that holds the moduli as strings
//
//	DESCRIPTION : Validates each modulus
//
//	OUTPUTS : Returns true if all of the user entered moduli are valid
//			numbers
//		Note: Pairwise relative primeness is not checked!
//
//*************************************************************************
function validModuli(mList)
{
	var modulus
	//  check each modulus separately
	for (i=0; i < mList.length; i++)
	{
		modulus = Number(mList[i]);
		if (isNaN(modulus))
		{
			return false;
		}
		else if (modulus<2)
		{
			return false;
		}
	}
	return true;
}

//*************************************************************************
//
//	PROCEDURE : operandsAreValid
//
//	INPUTS : form: the form that holds the controls for this script
//
//	DESCRIPTION : Validates each operand
//
//	OUTPUTS : Returns true if all of the user entered operands are in
//			the correct range and legal, false otherwise.
//
//*************************************************************************
function operandsAreValid(form)
{	
	//  Validate moduli first
	if (validModuli(form.moduliTextbox.value.split(";"))==false)
	{
		alert("Invalid moduli.  Moduli must be decimal numbers larger than one and split by semicolons.");
		form.radixTextbox.focus();
		return false;
	}
	
	//  Validate input A
	else if (isNaN(Number(form.inputATextbox.value)))
	{
		alert("Invalid input in A.  Must be a decimal number");
		form.inputATextbox.focus();
		return false;
	}	
	//  Validate input B
	else if (isNaN(Number(form.inputBTextbox.value)))
	{
		alert("Invalid input in B.  Must be a decimal number");
		form.inputBTextbox.focus();
		return false;
	}
	return true;
}

//*************************************************************************
//
//	PROCEDURE : gcd
//
//	INPUTS : a,b: the list that holds the moduli as numbers
//
//	DESCRIPTION : Finds the greatest common divisor
//
//	OUTPUTS : Returns the greatest common divisor of a and b
//
//*************************************************************************
function gcd(a,b)
{
	var gFcd = 1; // greatest found common divisor

	var aByi;
	var bByi;
	var mab=Math.min(a,b);

	//  The easy way, maybe unnecessary slow in execution, but well..
	for (i=2; i < mab; i++)
	{
		aByi=a/i;
		bByi=b/i;
		if ((Math.round(aByi)==aByi) && (Math.round(bByi)==bByi)) gFcd=i;
	}
	return gFcd;
}

//*************************************************************************
//
//	PROCEDURE : prpModuli
//
//	INPUTS : mnList: the list that holds the moduli as numbers
//
//	DESCRIPTION : Checks if user entered moduli are pairwise
//			relatively prime
//
//	OUTPUTS : Returns true if all of the user entered moduli are pairwise
//			relatively prime
//
//*************************************************************************
function prpModuli(mnList)
{
	var range = 1;
	var modulus;
	var g;
	//  check one modulus after the other for g.c.d. with total range
	//  if > 1, common divider with at least one other modulus exists
	for (k=0; k < mnList.length; k++)
	{
		modulus = mnList[k];
		g=gcd(range, modulus);
		if (g>1)
		{
			return false;
		}
		range = range * modulus;
	}
	return true;
}

//*************************************************************************
//
//	PROCEDURE : printFormattedResNumber
//
//	INPUTS : resNumberArray : The array that holds the the residue 
//			number to be printed. 
//		outputDocument : The document where the signed decimal
//			number should be written.
//		prefix : a string that holds any text to be appeneded
//			to the beginning of the line
//		suffix : a string that holds any text to be appeneded
//			to the end of the line
//
//	DESCRIPTION : Prints a residue number to outputDocument.  
//
//	OUTPUTS : none
//
//*************************************************************************
function printFormattedResNumber(resNumberArray, 
								outputDocument, 
								prefix, 
								suffix)
{
	var currentString;
	var currentLength;
	outputLine = new String;
	
	//  Start a row
	outputDocument.writeln("<TR>");
	
	//  write the prefix
	if (prefix != "undefined")
		outputDocument.writeln("<TD ALIGN='right'>" + prefix + "</TD>");
	else
		outputDocument.writeln("<TD ALIGN='right'></TD>");
				
	//  format the residue number starting from first residue
	outputLine = "<TD ALIGN='right'>(</TD>";
	for (i = 0; i <= resNumberArray.length-1; i++)
	{
		currentString = String(resNumberArray[i]);
		outputLine = outputLine + "<TD ALIGN='right'>";

		//  Format the width of the character to 5 spaces
		currentLength = currentString.length;
		for (k = 5-currentLength; k > 0; k--)
		{
			outputLine = outputLine + "&nbsp;";
		}
		outputLine = outputLine + currentString;
		if (i<resNumberArray.length-1)
			outputLine = outputLine + ",";

		outputLine = outputLine + "</TD>";
	}
	outputLine = outputLine + "<TD ALIGN='right'>)</TD>";

	//  Append the comment
	if (suffix != "undefined")
		outputLine = outputLine + "<TD ALIGN='right'>&nbsp;&nbsp;&nbsp;" + suffix + "</TD>";
	else
		outputDocument.writeln("<TD></TD>");

	//  print the output line
	outputDocument.writeln(outputLine);

	//  Close the row 
	outputDocument.writeln("</TR>");
}


//*************************************************************************
//
//	PROCEDURE : convertResToDec
//
//	INPUTS : moduli:  The moduli of the residue number
//		resValueArray:  The array that holds the signed decimal number
//				to be converted
//
//	DESCRIPTION : converts a residue number to decimal using the
//			Chinese Remainder System
//
//	OUTPUTS : array of decimal values:
//			[0] unmodulated value of the residue number
//			[1] modulated value of the residue number
//			[2] modulo value of the residue number
//			or all [0]=-1 if moduli are not pairwise relatively prime
//
//*************************************************************************
function convertResToDec(moduli, resValueArray)
{
	weightArray = new Array;
	retArray = new Array;
	retArray.length=3;

	var rawVal=-1;
	var decVal=-1;
	var allM=1;
	var modulus;
	var g;
	var mHeadj;
	var mHeadjMI; //  Multiplicative inverse
	if (prpModuli(moduli))
	{
		//  Find total number of Representations
		for (k=0; k < moduli.length; k++)
		{
			modulus = moduli[k];
			g=gcd(allM, modulus);
			allM = allM * modulus / g;
		}

		//  Find "weights"
		weightArray.length=moduli.length;
		for (j=0; j < moduli.length; j++)
		{
			mHeadj = Math.round(allM / moduli[j]); // round only to ensure integer
			mHeadjMI = 1;
			for (xmj=1; xmj < moduli[j]; xmj++)
			{
				if (((xmj*mHeadj) % moduli[j])==1)
				{
					mHeadjMI = xmj;
				}
			}
			weightArray[j] = mHeadj * mHeadjMI;
		}

		//  sum up
		rawVal=0;
		for (j=0; j < moduli.length; j++)
		{
			rawVal = rawVal + weightArray[j] * resValueArray[j];
		}
		decVal=rawVal % allM;	
	}
	retArray[0] = decVal;
	retArray[1] = rawVal;
	retArray[2] = allM;
	return retArray;
} 

//*************************************************************************
//
//	PROCEDURE : convertResToDecString
//
//	INPUTS : moduli:  The moduli of the residue number
//		resValueArray:  The array that holds the signed decimal number
//				to be converted 
//
//	DESCRIPTION : converts a residue number to decimal using the
//			Chinese Remainder System and forms a comment out of it
//			Note: uses function convertResToDec(...)
//
//	OUTPUTS : decimal value of the residue number as string or "unclear"
//			if moduli are not pairwise relatively prime
//
//*************************************************************************
function convertResToDecString(moduli, resValueArray)
{
	var decArray=convertResToDec(moduli, resValueArray);
	var decVal=decArray[0];
	var rawVal=decArray[1];
	var modulus=decArray[2];
	var decimalString="Not convertible to decimal";
	if (decVal!=-1) {
		decimalString = rawVal + " mod " + modulus + " = " + decVal + " in decimal";
	}
	return decimalString;
} 

//*************************************************************************
//
//	PROCEDURE : performResAddition
//
//	INPUTS : operandBArray, operandAArray : The arrays that hold the 
//			numbers to be added.  The arrays must
//			contain the NUMERIC value for each residue of the 
//			operands.
//		moduli: Array of moduli.
//		outputDocument : The document where the text for the 
//			intermediate and final results of the operation 
//			should be written.
//		resultArray: The array that will hold the result of 
//			operandAArray - operandBArray.
//
//	DESCRIPTION : Adds operandAArray to operandBArray using the residue
//			arithmetic.
//
//	OUTPUTS : returns the final result of the addition in resultArray.
//
//*************************************************************************
function performResAddition(operandAArray, 
				operandBArray, 
				moduli, 
				outputDocument,
				resultArray)
{
	unMArray = new Array  //  unMArray holds the unmodulated results of the addition
	
	unMArray.length = operandAArray.length;
	resultArray.length = operandAArray.length;
	
	//  Show the operation to be performed in the results document
	printFormattedResNumber(operandAArray, outputDocument, "   ", "   = " + convertResToDecString(moduli, operandAArray));
	printFormattedResNumber(operandBArray, outputDocument, " + ", "   = " + convertResToDecString(moduli, operandBArray));
	outputDocument.writeln(MakeLine(15));

	//  The really simple addition
	for (i=0; i < operandAArray.length; i++)
	{
		unMArray[i] = operandAArray[i] + operandBArray[i];
	}
		
	//  Show unmodulated array in the results document
	printFormattedResNumber(unMArray, outputDocument, "   ", "       ", true);
	printFormattedResNumber(moduli, outputDocument, "mod", "       ", true);
	outputDocument.writeln(MakeLine(15));

	//  Calculate final result and place the digits in resultArray
	for (i=0; i < unMArray.length; i++)
		resultArray[i] = unMArray[i] % moduli[i];
	
	//  Show final result in the results document
	printFormattedResNumber(resultArray, outputDocument, "", "   = " + convertResToDecString(moduli, resultArray));
}

//*************************************************************************
//
//	PROCEDURE : performResSubtraction
//
//	INPUTS : operandBArray, operandAArray : The arrays that hold the 
//			numbers to be subtracted.  The arrays must
//			contain the NUMERIC value for each residue of the 
//			operands.
//		moduli: Array of moduli.
//		outputDocument : The document where the text for the 
//			intermediate and final results of the operation 
//			should be written.
//		resultArray: The array that will hold the result of 
//			operandAArray - operandBArray.
//
//	DESCRIPTION : Subtracts operandBArray from operandAArray using residue
//			number arithmetic.
//
//			Note that this routine inverts operandBArray, and
//			calls performResAddition to perform the operation.
//
//	OUTPUTS : returns the final result of the addition in resultArray.
//
//*************************************************************************
function performResSubtraction(operandAArray, 
				operandBArray, 
				moduli, 
				outputDocument,
				resultArray)
{
	invertedBArray = new Array
	invertedBArray.length = operandBArray.length;
	
	//  Show the operation to be performed in the results document
	printFormattedResNumber(operandAArray, outputDocument, "   ", "   = " + convertResToDecString(moduli, operandAArray));
	printFormattedResNumber(operandBArray, outputDocument, " - ", "   = " + convertResToDecString(moduli, operandBArray));
	outputDocument.writeln(MakeLine(15));

	outputDocument.writeln("<TR><TD>The operation </TD></TR><TR><TD> will be performed as:</TD></TR>");

	//  Calculate additive inverse B value
	for (i=0; i < operandBArray.length; i++)
	{
		invertedBArray[i] = (moduli[i] - operandBArray[i]) % moduli[i];
	}

	//  Perform subtraction by adding the inverted B value to A
	performResAddition(operandAArray, 
				invertedBArray, 
				moduli, 
				outputDocument,
				resultArray);
}

//*************************************************************************
//
//	PROCEDURE : performResMultiplication
//
//	INPUTS : operandBArray, operandAArray : The arrays that hold the 
//			numbers to be added.  The arrays must
//			contain the NUMERIC value for each residue of the 
//			operands.
//		moduli: Array of moduli.
//		outputDocument : The document where the text for the 
//			intermediate and final results of the operation 
//			should be written.
//		resultArray: The array that will hold the result of 
//			operandAArray - operandBArray.
//
//	DESCRIPTION : Adds operandAArray to operandBArray using the residue
//			arithmetic.
//
//	OUTPUTS : returns the final result of the addition in resultArray.
//
//*************************************************************************
function performResMultiplication(operandAArray, 
				operandBArray, 
				moduli, 
				outputDocument,
				resultArray)
{
	unMArray = new Array  //  unMArray holds the unmodulated results of the multiplication
	
	unMArray.length = operandAArray.length;
	resultArray.length = operandAArray.length;
	
	//  Show the operation to be performed in the results document
	printFormattedResNumber(operandAArray, outputDocument, "   ", "   = " + convertResToDecString(moduli, operandAArray));
	printFormattedResNumber(operandBArray, outputDocument, " * ", "   = " + convertResToDecString(moduli, operandBArray));
	outputDocument.writeln(MakeLine(15));

	//  The really simple multiplication
	for (i=0; i < operandAArray.length; i++)
	{
		unMArray[i] = operandAArray[i] * operandBArray[i];
	}
		
	//  Show unmodulated array in the results document
	printFormattedResNumber(unMArray, outputDocument, "   ", "       ", true);
	printFormattedResNumber(moduli, outputDocument, "mod", "       ", true);
	outputDocument.writeln(MakeLine(15));

	//  Calculate final result and place the digits in resultArray
	for (i=0; i < unMArray.length; i++)
		resultArray[i] = unMArray[i] % moduli[i];
	
	//  Show final result in the results document
	printFormattedResNumber(resultArray, outputDocument, "", "   = " + convertResToDecString(moduli, resultArray));
}

//*************************************************************************
//
//	PROCEDURE : OnCalculate
//
//	INPUTS : form: the form that holds the controls for this script
//
//	DESCRIPTION : Event handler for the "Calculate" button.  
//
//	OUTPUTS : none
//
//*************************************************************************
function OnCalculate(form) 
{
	inputAArray = new Array;
	inputBArray = new Array;
	operationResult = new Array;
	moduli = new Array;
	decArray = new Array;

	//  should get an array of Substrings containing moduli
	var tempStringM = form.moduliTextbox.value.split(";");
	var inputA = Number(form.inputATextbox.value);
	var inputB = Number(form.inputBTextbox.value);
	var prpAlert = false;
	var correctResult = 0;
	var achievedResult = 0;
	var overflowWarning =""
	
	//  open results document
	parent.resultsFrame.document.open();

	//  Open a table for the results
	parent.resultsFrame.document.writeln("<TABLE>");

	//  Validate inputs
	if (operandsAreValid(form))
	{
		//  should get an array of number values for moduli
		moduli.length=tempStringM.length;
		for (i=0; i < tempStringM.length; i++)
		{
			moduli[i] = Number(tempStringM[i]);
		}
		
		//  check moduli for relative primeness
		prpAlert=!prpModuli(moduli);
		if (prpAlert) alert("Warning: Moduli not pairwise relatively prime.\nTransformation to Decimal will not work.");
		
		//  transform decimal inputs to residue number arrays
		inputAArray.length=moduli.length;
		inputBArray.length=moduli.length;
		for (i=0; i < moduli.length; i++)
		{
			inputAArray[i] = ((inputA % moduli[i]) + moduli[i]) % moduli[i];
			inputBArray[i] = ((inputB % moduli[i]) + moduli[i]) % moduli[i];
		}
	
		//  Perform the requested operation
		if (form.operation[0].checked  == "1")
		{
			performResAddition(inputAArray,
							inputBArray,
							moduli,
							parent.resultsFrame.document,
							operationResult);
			decArray=convertResToDec(moduli, operationResult);
			if (decArray[0]!=-1)
			{
				achievedResult=decArray[0];
				correctResult=inputA+inputB;
			}
		}
		else if (form.operation[1].checked  == "1")
		{
			performResSubtraction(inputAArray,
							inputBArray, 
							moduli, 
							parent.resultsFrame.document,
							operationResult);
			decArray=convertResToDec(moduli, operationResult);
			if (decArray[0]!=-1)
			{
				achievedResult=decArray[0];
				correctResult=inputA-inputB;
			}
		}
		else if (form.operation[2].checked  == "1")
		{
			performResMultiplication(inputAArray,
							inputBArray,
							moduli,
							parent.resultsFrame.document,
							operationResult);
			decArray=convertResToDec(moduli, operationResult);
			if (decArray[0]!=-1)
			{
				achievedResult=decArray[0];
				correctResult=inputA*inputB;
			}
		}
	}

	//  Close the table
	parent.resultsFrame.document.writeln("</TABLE>");

	//  Overflow warning?
	if (correctResult!=achievedResult)
	{
		overflowWarning = "Overflow: Achieved result " + achievedResult + " is not equal to ";
		overflowWarning = overflowWarning + "correct result " + correctResult + "!";
		parent.resultsFrame.document.writeln(overflowWarning);
	}

	//  close results document
	parent.resultsFrame.document.close();
}

//*************************************************************************
//
//	PROCEDURE : OnHelp
//
//	INPUTS : none
//
//	DESCRIPTION : little help file  
//
//	OUTPUTS : none
//
//*************************************************************************
function OnHelp() 
{
	var screen=parent.resultsFrame.document;

	//  open results document
	screen.open();

	//  The help
	screen.writeln("This simulator shows the operations of addition,");
	screen.writeln("subtraction and multiplication in residue arithmetic.");
	screen.writeln("The inputs A and B are first transformed into the");
	screen.writeln("residue number system corresponding to the entered");
	screen.writeln("moduli. Then the chosen operation is performed in");
	screen.writeln("residue arithmetic.<BR>");
	screen.writeln("If the entered moduli are pairwise relatively prime");
	screen.writeln("the Chinese Remainder Theorem is used to transform");
	screen.writeln("all residue numbers back to decimal.<BR>");
	screen.writeln(MakeLine(15));
	screen.writeln("<BR>Inputs:<BR>");
	screen.writeln("  Moduli: The moduli used for the residue number");
	screen.writeln("system. Each modulus must be an integer larger");
	screen.writeln("than one in decimal format. Moduli must be separated");
	screen.writeln("by one semicolon only.<BR>");
	screen.writeln("  Operation: Choose between Add, Subtract and Multiply.<BR>");
	screen.writeln("  Input A, Input B: The numbers on which the chosen");
	screen.writeln("operation will be performed. It is always performed");
	screen.writeln("A operator B. Numbers must be decimal integers.");
	screen.writeln("Negative numbers are allowed, but result in a");
	screen.writeln("wrong result.<BR>");

	//  close results document
	screen.close();
}


</SCRIPT>
</HEAD>
<BODY BGCOLOR="#945D28">
<FORM NAME="theScript">
<CENTER>
<H2>
Residue Number Arithmetic</H2></CENTER>

<FORM>
<P><STRONG>Please separate moduli with semicolon(s)</P></STRONG>
<P><STRONG>
Moduli: <INPUT name=moduliTextbox style="HEIGHT: 22px; WIDTH: 156px">
</STRONG></P>

<P>
<i>add <INPUT CHECKED name=operation type=radio> 
subtract <INPUT name=operation type=radio>
multiply <INPUT name=operation type=radio>
</i>
</P>

<P>
<B>
Input A : <INPUT  name="inputATextbox" style="HEIGHT: 22px; TEXT-TRANSFORM: none; WIDTH: 156px">
</B>
</P>

<P>
<B>
Input B : <INPUT  name="inputBTextbox" style="HEIGHT: 22px; TEXT-TRANSFORM: none; WIDTH: 156px">
</B> 
</P>

<CENTER>&nbsp;</CENTER>

<CENTER>
<INPUT type="button" name="compute" value="Compute" onClick="OnCalculate(this.form)">
<P>
<INPUT type="button" name="help" value="Help" onClick="OnHelp()"></CENTER>
</FORM></STRONG></FONT>
</BODY>
</HTML>
