<HTML>
<HEAD>
<TITLE> Division by Convergence </TITLE>
<SCRIPT language="JavaScript">

function PrintError(Message) {
	Error = "<CENTER><H1> ERROR </H1></CENTER> <P>\n"
	Error += "<CENTER> <EM>" + Message + "</EM> </CENTER>\n"
	return Error
}


function cls(what) {
    what.document.open();
    what.document.write('<BODY COLOR="WHITE">');
    what.document.close();
}


function ParseBinary (BinNum) {
	// Turns a binary number into a decimal, sets a flag to true if
	// BinNum is not actually binary

	IsNeg = false
	if (BinNum < 0) {
		IsNeg = true
		BinNum *= -1
	}
	RealNum = 0
	LogBaseTen = Math.log(BinNum)/Math.LN10
	HighestPlace = Math.ceil(LogBaseTen)
	for (CurPlace = HighestPlace; CurPlace >= -NumBits; CurPlace--) {
		CurEntry = Math.round(BinNum / Math.pow(10, CurPlace))
		if (CurEntry != 0 && CurEntry != 1) {
			NotBinary = true
			CurEntry = 1 // feed it something normal, to avoid
					 // wierd Javascript errors
		}
		if (CurEntry == 1) {
			RealNum += Math.pow(2, CurPlace)
			BinNum -= Math.pow(10, CurPlace)
		}
	}
	if (IsNeg) {RealNum *= -1} // reverse it back at the end

	// now check if the number was negative according to two's complement
	// representation - if it was, set the decimal value to this negative
	// number
	if (HighestPlace == NumBits) {
		RealNum -= Math.pow(2, NumBits)
	}

	return RealNum
}


function RoundOff (TheNum) {
	// returns the value TheNum would have if it were represented by
	// NumDecimals bits after the decimal point
	Scaling = Math.pow(2, NumDecimals)
	return (Math.round(TheNum * Scaling) / Scaling)
}

function TableRoundOff (TheNum) {
	// returns the value TheNum would have if it were represented by
	// NumDecimals bits after the decimal point
	Scaling = Math.pow(2, NumOutBitsROM)
	return (Math.round(TheNum * Scaling) / Scaling)
}

function InTableRoundOff (TheNum) {
	// returns the value TheNum would have if it were represented by
	// NumDecimals bits after the decimal point
	Scaling = Math.pow(2, NumInBitsROM)
	return (Math.round(TheNum * Scaling) / Scaling)
}

function OrderOfMagnitude (TheNum) {
	// returns the highest place which has a "1" in TheNum's
	// binary representation - special non-2's complement version

	LogBaseTwo = Math.log(TheNum)/Math.LN2;
	return Math.floor(LogBaseTwo)
}

function PrintBinary(TheNum, NumDecs) {

	// initialize the string
	S = "";
	// deal with negative numbers
	if (TheNum < 0) {
		S += "-"
		TheNum *= -1
	}
	StartPlace = OrderOfMagnitude(TheNum)
	if (StartPlace < 0) {StartPlace = 0}
	NumDecs = NumDecs - StartPlace
 	for (CurPlace = StartPlace; CurPlace >= -NumDecs; CurPlace--) {
		if (CurPlace == -1) {S += "."}
		CurPower = Math.pow(2, CurPlace)
		if (TheNum >= CurPower) {
			S += "1"
			TheNum -= CurPower
		} else  {
			S += "0"
		}
	}
	return S
}

function NewParseBinary(inputStr) {
	RealNum = 0
	count = 0
	FoundDecimal = false
	for (var i = 0; i < inputStr.length; i++) {
		var oneChar = inputStr.substring(i, i + 1)
		if (FoundDecimal) {count++}
		if (oneChar == ".")  {FoundDecimal = true}
		if (oneChar == "1") {RealNum += Math.pow(2, -count)}
		}
	return RealNum
	}

function CreateTableEntry(inputStr) {
	RealNum = 0
	count = 0
	FoundDecimal = false
	length_adjustment = inputStr.length
	if (length_adjustment > NumInBitsROM) {length_adjustment = NumInBitsROM}
	for (var i = 0; i < length_adjustment; i++) {
		var oneChar = inputStr.substring(i, i + 1)
		if (FoundDecimal) {count++}
		if (oneChar == ".")  {FoundDecimal = true}
		if (oneChar == "1") {RealNum += Math.pow(2, (NumInBitsROM - count))}
		}
	return RealNum
	}


function DivConv(form) {
	cls(parent.frames[1])
	N = parseFloat(form.N.value)
	D = parseFloat(form.D.value)
	ChoseBin = form.Base[0].checked
	NumDecimals = parseFloat(form.NumDecimals.value)
	NumBits = parseFloat(form.NumDecimals.value)
	NumInBitsROM = parseFloat(form.NumInBitsROM.value)
	TableEntries = Math.pow(2, NumInBitsROM)
	NumOutBitsROM = parseFloat(form.NumOutBitsROM.value)
	OutputPrecision = Math.max(NumOutBitsROM, NumDecimals)
	NotBinary = false
	if (ChoseBin) {
		N = NewParseBinary(form.N.value)
		D = NewParseBinary(form.D.value)
		}

	RealQuotient = N/D
	Fractions_N = (Math.abs(N) < 1)
	Fractions_D = ((Math.abs(D) < 1) & (Math.abs(D) >= 0.5))
	NegD = (D < 0)
	DivByZero = (D == 0)

    estimate_new_2 = TableRoundOff(1/InTableRoundOff(D))
    new_count = CreateTableEntry(form.D.value)
    noTable = false
	if (NumInBitsROM == 0) {noTable = true}


	TheTop = "<HTML><HEAD><TITLE>Tablet</TITLE></HEAD><BODY bgcolor=white>"
	N = RoundOff(N)
	D = RoundOff(D)
	if (noTable == false) {
		Middle  = "Size of the ROM is 2" + "<sup>"+ NumInBitsROM + " </sup>" + "x " +
			       NumOutBitsROM + "<BR>\n"
		Middle += "Table has " + TableEntries + " entries <BR>\n"
		Middle += "Desired ROM Table entry for D = " + PrintBinary(D, NumInBitsROM) +
				   " is " + new_count + ", so R<sub>intial</sub> = " +
				   PrintBinary(estimate_new_2, NumOutBitsROM) + "<BR>\n"
		}
	else {
		Middle  = "No ROM used! <BR>\n"
		}
	Middle += "N = " + N + ", D = " + D + "<P>\n"
	Middle += "<TABLE border>"
	Middle += "<TR> <TD> <var>i</var> <TD> <var>D<sub>i</sub></var> "
	Middle += "<TD> <var>N<sub>i</sub></var> "
	Middle += "<TD> <var>R<sub>i</sub></var>" + "\n"
	iCol = ""	// initialize the four columns of the table
	DCol = ""
	NCol = ""
	RCol = ""

	Converged = false
	ulp = Math.pow(2, -NumDecimals)
	i = 1
	while (! Converged) {
		if (Math.abs(D - 1) <= ulp | i >= NumDecimals) {Converged = true}
		if ((i == 1) && (noTable == false)) {
			R = RoundOff(estimate_new_2)
			}
		else {
			R = RoundOff(2 - D)
			}
		iCol += i + " <BR>\n"
		DCol += PrintBinary(D, NumDecimals) + " <BR>\n"
		D = RoundOff(D * R)
		NCol += PrintBinary(N, NumDecimals) + " <BR>\n"
		if (! Converged) {
			N = RoundOff(N * R)
			RCol += PrintBinary(R, NumDecimals) + " <BR>\n"
			i++
			}
		else {
			RCol += "CONVERGED! <BR>\n"
		}
	}

	Middle += "<TR> <TD> " + iCol + "<TD align=right> " + DCol
	Middle += "<TD align=right> " + NCol
	Middle += "<TD valign=top align=right> " + RCol

	Middle += "</TABLE> <P>\n"
	Middle += "Q = N<sub>" + i + "</sub> = " + PrintBinary(N, NumDecimals)
		+ " = " + N + "<BR>\n"
	Middle += "Actual Value = " + RealQuotient + ", Error = " +
		Math.abs(RealQuotient - N)
	Bottom = "</BODY> </HTML>"

	if (! Fractions_N) {Middle = PrintError("Only fractions allowed, and N is to big!")}
	if (! Fractions_D) {Middle = PrintError("For D, only fractions between 0.5 and 1 are allowed... and fix it!")}
	if (NegD) {Middle = PrintError ("D can't be negative")}
	if (DivByZero) {Middle = PrintError ("Divide by zero")}
	if (NotBinary) {Middle = PrintError("At least one non-binary number")}

	parent.frames[1].document.open()
	parent.frames[1].document.write(TheTop);
	parent.frames[1].document.write(Middle);
	parent.frames[1].document.write(Bottom);
	parent.frames[1].document.close()

}

</SCRIPT>
</HEAD>

<BODY bgcolor="#FFFF7C">

<CENTER> <H2> Division by Convergence </H2> </CENTER>
<FORM>
<EM>bin</EM> <INPUT type="radio" name="Base" value="Binary" checked>
<EM>dec</EM> <INPUT type="radio" name="Base" value="Decimal">
<P>
N (Enter a fraction): <INPUT type="text" name="N" >
<P>
D (Enter a fraction between 0.5<sub>(10)</sub> and 1.0<sub>(10)</sub>): <INPUT type="text" name="D" >
<P>
No. of bits (0-32) :
<INPUT type="text" name="NumDecimals" >
<P>
No. of input bits to ROM (0-32) <BR>
'0' for no table :
<INPUT type="text" name="NumInBitsROM" >
<P>
No. of output bits from ROM (0-32) :
<INPUT type="text" name="NumOutBitsROM" >
<P>
<CENTER>
<INPUT type="button" name="enter" value="Compute"
onClick="DivConv(this.form)">
<P>
<INPUT type="button" value="Help"
onClick=parent.frames[1].location.href="Convergence_Help.html">
<P>
<CENTER>
<INPUT TYPE="Reset"  VALUE="   Reset   " onClick=parent.frames[1].location.href="../tablet.html">
</CENTER>
</P>

</CENTER>
</FORM>

</BODY>
</HTML>
