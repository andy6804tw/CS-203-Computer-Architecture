<HTML><HEAD>
<TITLE>Floating Point Division by Convergence</TITLE>
</HEAD>
<BODY BGCOLOR="#9C7BBD">


<SCRIPT LANGUAGE="JavaScript">


// ***************************************************************
// ***************************************************************

function PrintHR(NumColumns) {
        parent.frames[1].document.writeln("<HR noshade size=1>");
}


// ***************************************************************
// ***************************************************************

function BinToDec (BinStr) {

        Num=0;
        for (var i=0; i<=BinStr.length-1 ; i++) {
                Num += eval(BinStr[BinStr.length-1-i])*Math.pow(2,i);
        }
        return Num;
}

// ***************************************************************
// ***************************************************************

function OrderOfMagnitude (TheNum) {
        // returns the highest place which has a "1" in TheNum's
        // binary representation - special non-2's complement version

        LogBaseTwo = Math.log(TheNum)/Math.LN2;
        return Math.floor(LogBaseTwo)
        //return Math.round(LogBaseTwo)
}

// ***************************************************************
// ***************************************************************

function PrintError(Message) {
        Error = "<CENTER><H1> ERROR </H1></CENTER> <P>\n"
        Error += "<CENTER> <EM>" + Message + "</EM> </CENTER>\n <HR noshade=1>"
        return Error
}

// ***************************************************************
// ***************************************************************

function ParseBinary (BinNum, NumBits) {
        // Turns a binary number into a decimal, sets a flag to true if
        // BinNum is not actually binary

        IsNeg = false
        if (BinNum < 0) {
                IsNeg = true
                BinNum *= -1
        }
        RealNum = 0
        LogBaseTen = Math.log(BinNum)/Math.LN10
        HighestPlace = Math.ceil(LogBaseTen)
        for (CurPlace = HighestPlace; CurPlace >= -NumBits; CurPlace--) {
                CurEntry = Math.round(BinNum / Math.pow(10, CurPlace))
                if (CurEntry != 0 && CurEntry != 1) {
                        NotBinary = true
                        CurEntry = 1            // feed it something normal, to avoid
                                                                // wierd Javascript errors
                }
                if (CurEntry == 1) {
                        RealNum += Math.pow(2, CurPlace)
                        BinNum -= Math.pow(10, CurPlace)
                }
        }

        if (IsNeg) {RealNum *= -1} // reverse it back at the end
        // now check if the number was negative according to two's complement
        // representation - if it was, set the decimal value to this negative
        // number
        if (HighestPlace == NumBits) {
                RealNum -= Math.pow(2, NumBits)
        }

        return RealNum
}
// ***************************************************************
// ***************************************************************

function PrintBinary(TheNum, NumDecs) {

        // initialize the string
        S = "";
        // deal with negative numbers
        if (TheNum < 0) {
                S += "-"
                TheNum *= -1
        }
        StartPlace = OrderOfMagnitude(TheNum)
        if (StartPlace < 0) {StartPlace = 0}

        for (CurPlace = StartPlace; CurPlace >= -NumDecs; CurPlace--) {
                if (CurPlace == -1) {S += "."}
                CurPower = Math.pow(2, CurPlace)
                if (TheNum >= CurPower) {
                        S += "1"
                        TheNum = TheNum - CurPower
                } else  {
                        S += "0"
                }
        }
        return S
}



// ***************************************************************
// ***************************************************************

function PrintToBin(Name, TheNum, NumDecs) {

        S = PrintBinary(TheNum, NumDecs)
        parent.frames[1].document.writeln(Name+" = "+TheNum+"<BR>"+"Bin ="+S+"<BR>")
}

// ***************************************************************
// ***************************************************************

function TruncateToBits(Number, bits){
        if (Number >= 0) {
                return (Math.floor(Number * Math.pow(2,bits)) / Math.pow(2,bits))
        } else {
                return (-Math.floor(-Number * Math.pow(2,bits)) / Math.pow(2,bits))
        }
}

// ******************************************************************
// ******************************************************************

function RoundOff (TheNum) {
        // returns the value TheNum would have if it were represented by
        // NumDecimals bits after the decimal point
        Scaling = Math.pow(2, bits)
        return (Math.round(TheNum * Scaling) / Scaling)
}

// ***************************************************************
// ***************************************************************

function Structure(IEEE, error, maxerror, Sign, f, e, ZeroF, InfF, DenF, NanF, OveF,
                         UndF, G, R, S) {
        this.IEEE=IEEE
        this.error=error
        this.maxerror=maxerror
        this.Sign=Sign
        this.f=f
        this.e=e
        this.ZeroF=ZeroF
        this.InfF=InfF
        this.DenF=DenF
        this.NanF=NanF
        this.OveF=OveF
        this.UndF=UndF
        this.G = G;
        this.R = R;
        this.S = S;

}

// ***************************************************************
// ***************************************************************

function PrintIEEENum(Name, Number, sign, f, eWithBias, bits){

        Text = Name + (sign ? "- " : "+ ")
        Text += PrintBinary(f,bits) + " *2<sup>" + (eWithBias - bias) + "</sup> = " + Number
        parent.frames[1].document.writeln(Text)

}

// ***************************************************************
// ***************************************************************

function PrintGRS(Name, G, R, S, sign, f, eWithBias, bits){

        Text = Name + (sign ? "- " : "+ ")
        Text += PrintBinary(f,bits) + "|" + G + R + S + " *2<sup>" + (eWithBias - bias) + "</sup>"
        parent.frames[1].document.writeln(Text)

}

// ***************************************************************
// ***************************************************************

function PrintStructure(Structure) {
        parent.frames[1].document.writeln("<PRE>")
        parent.frames[1].document.writeln("IEEE     = " + Structure.IEEE)
        parent.frames[1].document.writeln("error    = " + Structure.error)
        parent.frames[1].document.writeln("maxerror = " + Structure.maxerror)
        parent.frames[1].document.writeln("Sign     = " + Structure.Sign)
        parent.frames[1].document.writeln("f        = " + Structure.f)
        parent.frames[1].document.writeln("e        = " + Structure.e)
        parent.frames[1].document.writeln("ZeroF    = " + Structure.ZeroF)
        parent.frames[1].document.writeln("InfF     = " + Structure.InfF)
        parent.frames[1].document.writeln("DenF     = " + Structure.DenF)
        parent.frames[1].document.writeln("NanF     = " + Structure.NanF)
        parent.frames[1].document.writeln("OveF     = " + Structure.OveF)
        parent.frames[1].document.writeln("UndF     = " + Structure.UndF)
        parent.frames[1].document.writeln("G        = " + Structure.G)
        parent.frames[1].document.writeln("R        = " + Structure.R)
        parent.frames[1].document.writeln("S        = " + Structure.S)
        parent.frames[1].document.writeln("</PRE>")
}

// ***************************************************************
// ***************************************************************

function IEEERepresentation(Structure, TheNum, bits, bias) {

        if (TheNum==0) {
                Structure.IEEE=0;
                Structure.error=0;
                Structure.maxerror=0;
                Structure.Sign=0;
                Structure.realSign=0;
                Structure.f=0;
                Structure.e=0;
                Structure.ZeroF=1;
                Structure.InfF=0;
                Structure.DenF=0;
                Structure.NanF= 0;
                Structure.OveF= 0;
                Structure.UndF=0;
                Structure.G=0;
                Structure.R=0;
                Structure.S=0;
        } else {
                Structure.Sign = (TheNum < 0)
                Structure.realSign = (TheNum < 0) ? -1 : 1
                TheNum=Math.abs(TheNum)

                Y=Math.log(TheNum)/Math.log(2);
                N=Math.floor(Y);
                Z=Y-N;

                ffull=(TheNum*Math.pow(2,-N));

        if (ffull >= 2){
                        ffull = ffull/2;
                        N = N + 1;
                }
                ffull = ffull - 1;
                fdecimal=Math.floor(ffull*Math.pow(2,bits));

                Structure.f=fdecimal*Math.pow(2,-bits);
                Structure.e=bias+N
                Structure.IEEE= Structure.realSign*
                                                (1+Structure.f)*Math.pow(2,Structure.e-bias);
                Structure.UndF = 0;
                Structure.DenF = 0;

                
                if (TheNum < Math.pow(2,-bias+1)){
                        N = -bias+1;
                        ffull=TheNum/Math.pow(2,N)
                        fdecimal=Math.floor(ffull*Math.pow(2,bits));
                        Structure.f=fdecimal/Math.pow(2,bits);
                        Structure.e= 1;
                        Structure.DenF = 1;
                        Structure.IEEE= Structure.realSign*Structure.f*Math.pow(2,N);
                }

                
                if (TheNum < Math.pow(2,-bias+1-bits)){
                        Structure.DenF = 0;
                        Structure.UndF = 1;
                }

                Structure.error=TheNum-Math.abs(Structure.IEEE);
                Structure.maxerror=Math.pow(2,Structure.e-bias-bits);


                Structure.ZeroF=0;
                Structure.InfF = 0;
                Structure.NanF = 0;
                if (Structure.e==2*bias+1){
                        if (Structure.f==0){
                                Structure.InfF = 1;
                        } else {
                                Structure.NanF = 1;
                        }
                }
                Structure.OveF = (Structure.e > 2*bias+1)
        }
        return Structure;
}

// ***************************************************************
// ***************************************************************

function PrintResult( Structure , Name){

        if (Structure.ZeroF || Structure.DenF){
                fprint = Structure.f;
        }else{
                fprint = Structure.f + 1;
        }

        SignPrint = " + ";
        if (Structure.Sign){ SignPrint = " - ";}

    flag = 1;
        if (Structure.NanF){
                flag = 0;

                // Set result to infinity
                PrintIEEENum(Name , SignPrint +"Inf", Structure.Sign, 1, Structure.e, bits)
                //document.writeln("<HR>") 
        } 

        if (Structure.InfF){
                flag = 0;
                PrintIEEENum(Name ,SignPrint +"Inf" , Structure.Sign, fprint, Structure.e, bits)
                //document.writeln("<HR>")
        }

        if (Structure.UndF){
                flag = 0;
                PrintIEEENum(Name , "NaN (Underflow)", Structure.Sign, fprint, Structure.e, bits)
                //document.writeln("<HR>")
        }

        if (flag) {
                if (Structure.DenF){
                        PrintIEEENum(Name , Structure.IEEE + " (Denorm.)", Structure.Sign,fprint,
                                         Structure.e, bits)
                } else {
                        PrintIEEENum(Name , Structure.IEEE, Structure.Sign, fprint, Structure.e, bits)
                }
        }       
}

// ***************************************************************
// ***************************************************************

function IsValidHex (theString) {
        // check to make sure every character is valid
        legalChars = "0123456789abcdefABCDEF"
        for (var i=0; i < theString.length; i++) {
                illegalChar = 1;
                for (var j=0; j < 22; j++){
                        if (theString[i] == legalChars[j])
                                illegalChar = 0;
                }       
                if (illegalChar)
                        return 0;
        }
        return 1; // if we got to here, everything's valid
}

// ***************************************************************
// ***************************************************************

function Mul(Struct1, Struct2, Struct3) {

//PrintStructure(Struct1)
//PrintStructure(Struct2)
        // Is A = 0 ?
        if (Struct1.ZeroF || Struct1.DenF){
                f1 = Struct1.f;
        }else{
                f1 = Struct1.f + 1;
        }
        N = f1;

        // Is B = 0 ?
        if (Struct2.ZeroF || Struct2.DenF){
                f2 = Struct2.f;
        }else{
                f2 = Struct2.f + 1;
        }
        D = f2;
        e1 = Struct1.e;
        e2 = Struct2.e;


        parent.frames[1].document.writeln("<PRE>")

    if (Struct1.DenF){
                PrintIEEENum("A    ",Struct1.IEEE + " (Denorm.)", Struct1.Sign, f1, e1, bits)
        } else {
                PrintIEEENum("A    ",Struct1.IEEE, Struct1.Sign, f1, e1, bits)
        }


        if (Struct2.DenF){
                PrintIEEENum("B    ",Struct2.IEEE + " (Denorm.)", Struct2.Sign, f2, e2, bits)

        } else {
                PrintIEEENum("B    ",Struct2.IEEE, Struct2.Sign, f2, e2, bits)
        }

        PrintHR();
        

        //*************************************************
        //*************************************************

        f3 = (Struct1.realSign*N)/(Struct2.realSign*D);
        ee3 = (e1-e2+bias);
        f5 = f1*Math.pow(2,e1-bias);
        TheNum=f3*Math.pow(2,ee3-bias)
        Struct3 = IEEERepresentation(Struct3, TheNum, bits, bias);
        if (Struct3.OveF){ 
                Message = " An Overflow Occured in result."
                Continue = 0;
                parent.frames[1].document.writeln(PrintError(Message))
                parent.frames[1].document.writeln("</PRE>");
                return Struct3;
        }
        if (Struct3.UndF) {
                Message =  " An Underflow Occured in result."
                Continue = 0;
                parent.frames[1].document.writeln(PrintError(Message))
                parent.frames[1].document.writeln("</PRE>");
                return Struct3;
        }
        
           OpS="A/B   ";



    // ***************** DIVISION BY CONVERGENCE *************
    // *******************************************************
      
        TheTop = "<HTML><HEAD><TITLE>Tablet</TITLE></HEAD><BODY bgcolor=white text=blue>"

        Middle = "Convergence Table <P>"
        Middle += "<TABLE border>"
        Middle += "<TR> <TD> <var>i</var> <TD> <var>f<sub>Bi</sub></var> "
        Middle += "<TD> <var>f<sub>Ai</sub></var> "
        Middle += "<TD> <var>R<sub>i</sub></var>" + "\n"
        iCol = ""       // initialize the four columns of the table
        DCol = ""
        NCol = ""
        RCol = ""

       Converged = false
        ulp = Math.pow(2, -bits)
        i = 1
        while (! Converged) {
                if (Math.abs(f2 - 1) <= ulp | i >= bits) {Converged = true}
                iCol += i + " <BR>\n"
                R = (2 - f2)
                DCol += PrintBinary(f2, bits) + " <BR>\n"
                f2 = (f2 * R)
                NCol += PrintBinary(f1, bits) + " <BR>\n"
                if (! Converged) {
                        f1 = (f1 * R)
                        RCol += PrintBinary(R, bits) + " <BR>\n"
                        i++;
                PrintBinary(R,bits);
                }
        }

        Middle += "<TR> <TD> " + iCol + "<TD align=right> " + DCol
        Middle += "<TD align=right> " + NCol
        Middle += "<TD valign=top align=right> " + RCol

        Middle += "</TABLE> <P>\n"

       parent.frames[1].document.writeln(TheTop);
       parent.frames[1].document.write(Middle);
       // PrintHR();
      // PrintHR();


        f3orig =(Struct1.realSign*f1)/(Struct2.realSign); 
 
        f3sign = (f3orig < 0)
        f3realSign = (f3orig < 0) ? -1 : 1;
        f3 = Math.abs(f3orig);
        f8 = f3;
        // Find G, R ans S for f3
        Fullf3 = f3;
        f3 = TruncateToBits(f3,bits);
        Extra3 = (Fullf3 - f3)*Math.pow(2,bits);

        Gf3 = 0;
        if (Extra3 >=0.5 ){
                Gf3 = 1;
                Extra3 = Extra3 - 0.5;
        }

        Rf3 = 0;
        if (Extra3 >= 0.25 ){
                Rf3 = 1;
                Extra3 = Extra3 - 0.25;
        }

        Sf3 = 0;
        if (Extra3 > 0 ){
                Sf3 = 1;
        }

        PrintGRS(OpS,Gf3, Rf3, Sf3, f3sign, f3,ee3, bits)
        PrintHR();
        f3 = f3 + Gf3*Math.pow(2,-bits-1) +  Rf3*Math.pow(2,-bits-2) 
                        + Sf3*Math.pow(2,-bits-3);
        result = f3realSign*f3*Math.pow(2,(ee3 - bias));
  
        // ********** A FROM THE RESULT **********
      
       differ = (result)*(B);
       Struct3 = IEEERepresentation(Struct3, differ, bits, bias);
       if (Struct3.ZeroF || Struct3.DenF){
                f9 = Struct3.f;
        }else{
                f9 = Struct3.f + 1;
        }
        e9 = Struct3.e;
        f6 = f9*Math.pow(2,e9-bias);

        Struct3 = IEEERepresentation(Struct3, differ, bits+3, bias);
        diffsign = Struct1.realsign;
        if (Struct3.ZeroF || Struct3.DenF){
                fdiff = Struct3.f;
        }else{
                fdiff = Struct3.f + 1;
        }
        //fdiff = Struct3.f;
        ediff = Struct3.e;

        // Find G, R ans S for f3
        Fulldiff = fdiff;
        fdiff = TruncateToBits(fdiff,bits);
        Extradiff = (Fulldiff - fdiff)*Math.pow(2,bits);

        Gdiff = 0;
        if (Extradiff >=0.5 ){
                Gdiff = 1;
                Extradiff = Extradiff - 0.5;
        }

        Rdiff = 0;
        if (Extradiff >= 0.25 ){
                Rdiff = 1;
                Extradiff = Extradiff - 0.25;
        }

        Sdiff = 0;
        if (Extra3 > 0 ){
                Sdiff = 1;
        }
        parent.frames[1].document.writeln("<CENTER><H4> A Computed from the result (A= (A/B)*B) </H4></CENTER>");
        OpS1="A  ";
        PrintGRS(OpS1, Gdiff, Rdiff, Sdiff, diffsign, fdiff, ediff, bits)
        PrintHR(); 
// ****************************************************8
        OpS5 = "A";
        if (f5 > f6){
        parent.frames[1].document.writeln("<CENTER><H4>Correction Step</H4></CENTER>")
        parent.frames[1].document.writeln("Add ulp/2 ");
        if (Gf3 == 0){
            Gf3 = 1;
        }
        else{
             f8 = f8 + Math.pow(2,-bits);
             Gf3 = 0;
        }
        f8 = f8 + Gf3*Math.pow(2,-bits-1) +  Rf3*Math.pow(2,-bits-2) + Sf3*Math.pow(2,-bits-3);
           result = f3realSign*f8*Math.pow(2,(ee3 - bias));
           f3 = f8;
        PrintGRS(OpS,Gf3, Rf3, Sf3, f3sign, f3,ee3, bits)
        PrintHR();
        }
        else if (f5 < f6){
             parent.frames[1].document.writeln("<CENTER><H4>Correction Step</H4></CENTER>")
             parent.frames[1].document.writeln("Substract ulp ");
          if (Gf3 == 0){
              f8 = f8 - Math.pow(2,-bits);
              Gf3 = 1;
              }
           else {
                Gf3 = 0;
           }
           f8 = f8 + Gf3*Math.pow(2,-bits-1) +  Rf3*Math.pow(2,-bits-2) + Sf3*Math.pow(2,-bits-3);
           result = f3realSign*f8*Math.pow(2,(ee3 - bias));
           f3 = f8;
           PrintGRS(OpS,Gf3, Rf3, Sf3, f3sign, f3,ee3, bits)
           PrintHR();

           } 
         //  PrintGRS(OpS,Gf3, Rf3, Sf3, f3sign, f3,ee3, bits)
         // PrintHR();
           


/*           f8 = f8 + Gf3*Math.pow(2,-bits-1) +  Rf3*Math.pow(2,-bits-2) + Sf3*Math.pow(2,-bits-3);
           result = f3realSign*f8*Math.pow(2,(ee3 - bias));
           f3 = f8;   
         
*/

        Struct3 = IEEERepresentation(Struct3, result, bits+3, bias)

        Fullf3 = Struct3.f
        e3 = Struct3.e
 
        Struct3 = IEEERepresentation(Struct3, result, bits, bias)
        f3 = Struct3.f;
        R1 = 0;
        R2 = 0;
        Extra3 = (Fullf3 - f3)*Math.pow(2,bits);
        if (Extra3 >=0.5 ){
                R1 = 1;
                        Extra3 = Extra3 - 0.5;
                }
                if (Extra3 > 0 ){
                        R2 = 1;
                }

        if (Struct3.DenF || Struct3.ZeroF){
                f3 = f3;
        } else {
                f3 = f3 + 1;
        }
 
        parent.frames[1].document.writeln("<CENTER><H4>Postnormalization Step</H4></CENTER>")
        PrintGRS(OpS,R1, R2, "", f3sign, f3, e3, bits)
        PrintHR();


        // Find Final result using rounding techniques and f3, R1, R2
        // Trancation
        f = f3;
        e = e3;

        result = f3realSign*f*Math.pow(2,e-bias);
        parent.frames[1].document.writeln("<CENTER><H4>Round to Zero</H4></CENTER> ")
        Struct3 = IEEERepresentation(Struct3, result, bits, bias)
        PrintResult(Struct3 , OpS)
        PrintHR();

        // Round to nearest Even
        f = f3 + (R1 && R2)*Math.pow(2,-bits);
        temp = ((f3*Math.pow(2,bits-1)) - Math.floor(f3*Math.pow(2,bits-1)));
        lastBit = 0;
        if (temp >= 0.5  ) { lastBit = 1;} 

        feven = f;
        if ((R1 == 1) && (R2 == 0)) { feven = feven + lastBit*Math.pow(2,-bits)}
//      if ((R1 == 1) && (R2 == 0)) { fodd = fodd + (lastBit^1)*pow(2,-bits)}
        e = e3;
        result = f3realSign*feven*Math.pow(2,e-bias);
        parent.frames[1].document.writeln("<CENTER><H4>Round to Nearest Even</H4></CENTER>")
    Struct3 = IEEERepresentation(Struct3, result, bits, bias)
    PrintResult( Struct3 , OpS)
        //PrintIEEENum(OpS,result, f3sign, feven,e, bits)
        PrintHR();

        // Round to Plus Infinity
        f = f3;
        e = e3;
    if (f3sign == 0){
                f = f3 + (R1 || R2)*Math.pow(2,-bits);
        }
        result = f3realSign*f*Math.pow(2,e-bias);
        Struct3 = IEEERepresentation(Struct3, result, bits, bias)
        parent.frames[1].document.writeln("<CENTER><H4>Round to Plus Infinity</H4></CENTER>")
        PrintResult( Struct3 , OpS)
        PrintHR();


        // Round to Minus Infinity
        f = f3;
        e = e3;
    if (f3sign == 1){
                f = f3 + (R1 || R2)*Math.pow(2,-bits);
        }
        result = f3realSign*f*Math.pow(2,e-bias);
        Struct3 = IEEERepresentation(Struct3, result, bits, bias)
        parent.frames[1].document.writeln("<CENTER><H4>Round to Minus Infinity</H4></CENTER>")
        PrintResult( Struct3 , OpS)
        PrintHR();

        parent.frames[1].document.writeln("</PRE>")
        return Struct3;

}

// *********************************************************
// *********************************************************
// *********************************************************
//
//       Main program
//
// *********************************************************
// *********************************************************

function FPMul(form){

        parent.frames[1].document.open()


// *********************************************************
//  Begin form parsing
// *********************************************************



        //ChoseSing = form.IEEEForm[0].checked;
        //ChoseDoub = form.IEEEForm[1].checked;
        ChoseSing = 1;
        
        ChoseHex = form.TypeNumber[0].checked;
        ChoseDec = form.TypeNumber[1].checked;

        Continue = 1;

        if (ChoseDec) {


        if (navigator.appVersion[0] > 3 ){
                with (Math) {
                                A = parseFloat(eval(form.A.value));
                                B = parseFloat(eval(form.B.value));
                }
        } else {
                                A = parseFloat(eval(form.A.value));
                                B = parseFloat(eval(form.B.value));
                }

                        if (isNaN(A)) {
                                Continue = 0;
                                Message = " A is an invalid Number " 
                                parent.frames[1].document.writeln(PrintError(Message))
                        }

                        if (isNaN(B)) {
                                Continue = 0;
                                Message = " B is an invalid Number " 
                                parent.frames[1].document.writeln(PrintError(Message))
                        }
        }



       Divide = 1;

        if (ChoseSing) {
                        bits  = 23;
                        bias  = 127;
                        Total = 32;
        } else {
                        bits  = 52;
                        bias  = 1023;
                        Total = 64;
        }                       

        if (ChoseHex) {

                A = form.A.value;
                B = form.B.value;
                l = A.length;
                if (l != (Total/4)) {
                        Continue = 0;
                        Message = " Total number of Characters in A Should be Equal to " 
                                                +Total/4
                        parent.frames[1].document.writeln(PrintError(Message))
                }

                l = B.length;
                if (l != (Total/4)) {
                        Continue = 0;
                        Message = " Total number of Characters in B Should be Equal to " 
                                                +Total/4
                        parent.frames[1].document.writeln(PrintError(Message))
                }

                // check for valid hexadecimal numbers
                if (! IsValidHex(A)) {
                        Continue = 0
                        Message = "A contains non-hexadecimal characters "
                        parent.frames[1].document.writeln(PrintError(Message))
                }
                if (! IsValidHex(B)) {
                        Continue = 0
                        Message = "B contains non-hexadecimal characters "
                        parent.frames[1].document.writeln(PrintError(Message))
                }

                if (Continue) {
                        StrA = "";
                        for (var i=0; i <(Total/4); i++) {
                                temp = PrintBinary(eval("0x" +A[i])/Math.pow(2,4), 4);
                                StrA = StrA + temp.slice(2,7);
                        }
        
                        StrB = "";
                        for (var i=0; i <(Total/4); i++) {
                                temp = PrintBinary(eval("0x" +B[i])/Math.pow(2,4), 4);
                                StrB = StrB + temp.slice(2,7);
                        }
        
                        sa =    StrA[0];
                        sb =    StrB[0];
                        ea =    BinToDec (StrA.slice(1,Total-bits))
                        eb =    BinToDec (StrB.slice(1,Total-bits))
                        siga =  BinToDec (StrA.slice(Total-bits, Total))
                        sigb =  BinToDec (StrB.slice(Total-bits, Total))
                        if (ea == 0){
                        A = Math.pow(-1,sa) * siga/Math.pow(2,bits) 
                                * Math.pow(2,1-bias) //*RAG s/ea/1/ *//
                        } else{
                        A = Math.pow(-1,sa) * (1+siga/Math.pow(2,bits)) 
                                * Math.pow(2,ea-bias)
                        }
                        if (eb == 0){
                        B = Math.pow(-1,sb) * sigb/Math.pow(2,bits) 
                                * Math.pow(2,1-bias) //*RAG s/eb/1/ *//
                        } else{
                        B = Math.pow(-1,sb) * (1+sigb/Math.pow(2,bits)) 
                                * Math.pow(2,eb-bias)
                        }
                }
        }

/////////////////////////////////////////////////////////////////////////

        Alpha = new Structure();
        Beta  = new Structure();
        Gamma = new Structure();

        Alpha = IEEERepresentation(Alpha, A, bits, bias)
        Beta  = IEEERepresentation(Beta, B, bits, bias)

        //PrintStructure(Alpha)
        //PrintStructure(Beta)
        // Before Add/Sub Check for overflow, underflow, zero, Inf, NaN
                if (Alpha.OveF){ 
                        Message = " An Overflow Occured in A"
                        Continue = 0;
                        parent.frames[1].document.writeln(PrintError(Message))
                }
                if (Alpha.UndF) {
                        Message =  " An Underflow Occured in A"
                        Continue = 0;
                        parent.frames[1].document.writeln(PrintError(Message))
                }
                if (Beta.OveF){ 
                        Message =  " An Overflow Occured in B"
                        Continue = 0;
                        parent.frames[1].document.writeln(PrintError(Message))
                }
                if (Beta.UndF) {
                        Message = " An Underflow Occured in B"
                        Continue = 0;
                        parent.frames[1].document.writeln(PrintError(Message))
                }

                OpS = "A/B  ";

                if (Alpha.NanF && Beta.NanF){
                        Continue = 0;
                        parent.frames[1].document.writeln("<PRE>")
                        PrintIEEENum("A    ","NaN" , Alpha.Sign, Alpha.f+1, Alpha.e, bits)
                        PrintIEEENum("B    ","NaN", Beta.Sign, Beta.f+1, Beta.e, bits)
                        PrintHR();
                        parent.frames[1].document.writeln(OpS + " Result = NaN ")
                }

                if (Alpha.NanF && Continue){
                        Continue = 0;
                        parent.frames[1].document.writeln("<PRE>")
                        PrintIEEENum("A    "," NaN" , Alpha.Sign, Alpha.f+1, Alpha.e, bits)
                        PrintResult(Beta, "B    ");
                        PrintHR();
                        parent.frames[1].document.writeln(OpS + " Result = NaN ")
                }

                if (Beta.NanF && Continue){
                        Continue = 0;
                        parent.frames[1].document.writeln("<PRE>")
                        PrintResult(Alpha, "A    ");
                        PrintIEEENum("B    "," NaN", Beta.Sign, Beta.f, Beta.e, bits)
                        PrintHR();
                        parent.frames[1].document.writeln(OpS + " Result = NaN ")
                }

                if (Alpha.ZeroF && Beta.ZeroF && Divide){
                        Gamma  = IEEERepresentation(Gamma, 0, bits, bias)
                        Continue = 0;
                        parent.frames[1].document.writeln("<PRE>")
                        PrintIEEENum("A    ",Alpha.IEEE, Alpha.Sign, Alpha.f, Alpha.e, bits)
                        PrintIEEENum("B    ",Beta.IEEE, Beta.Sign, Beta.f, Beta.e, bits)
                        PrintHR();
                        parent.frames[1].document.writeln(OpS + " Result = NaN ")
                        //PrintIEEENum(OpS    ,Gamma.IEEE, Gamma.Sign, Gamma.f, Gamma.e, bits)
                        
                }

                if (Alpha.ZeroF && Divide && Continue){
                        Gamma  = IEEERepresentation(Gamma, 0, bits, bias)
                        Continue = 0;
                        parent.frames[1].document.writeln("<PRE>")
                        PrintResult(Alpha,"A   ");
                        PrintResult(Beta,"B   ");
                        PrintHR();
                        PrintResult(Gamma,OpS);
                        
                }

                if (Beta.ZeroF && Divide && Continue){
                        Continue = 0;
                        parent.frames[1].document.writeln("<PRE>")
                        Sig = "+";
                        if (Alpha.Sign) { Sig = "-";}
                        PrintResult(Alpha,"A   ");
                        PrintIEEENum("B    ",Beta.IEEE, Beta.Sign, Beta.f, Beta.e, bits)
                        PrintHR();
                        PrintIEEENum(OpS,Sig +"Inf" , Alpha.Sign, 1, 2*bias+1, bits)
                }



                if (Alpha.InfF && Beta.InfF && Divide){
                        Continue = 0;
                        parent.frames[1].document.writeln("<PRE>")
                        Sig = "+";
                        if (Alpha.Sign) { Sig = "-";}
                        PrintIEEENum("A    ",Sig +"Inf" , Alpha.Sign, Alpha.f +1, Alpha.e, bits)        
                        Sig = "+";
                        if (Beta.Sign) { Sig = "-";}    
                        PrintIEEENum("B    ",Sig +"Inf", Beta.Sign, Beta.f + 1, Beta.e, bits)
                        PrintHR();
                        parent.frames[1].document.writeln(OpS + " Result = NaN ")
                }

                if(Alpha.ZeroF && !Divide && Continue){
                        Continue = 0;
                        parent.frames[1].document.writeln("<PRE>")
                        PrintResult(Alpha, "A    ");
                        PrintResult(Beta, "B    ")
                        PrintHR();
                        if(Beta.InfF)
                                parent.frames[1].document.writeln(OpS + " Result = NaN ")
                        else{
                                Gamma  = IEEERepresentation(Gamma, 0, bits, bias)
                                PrintResult(Gamma,OpS);
                        }
                }

                if(Beta.ZeroF && !Divide && Continue){
                        Continue = 0;
                        parent.frames[1].document.writeln("<PRE>")
                        PrintResult(Alpha, "A    ");
                        PrintResult(Beta, "B    ")
                        PrintHR();
                        if(Alpha.InfF)
                                parent.frames[1].document.writeln(OpS + " Result = NaN ")
                        else{
                                Gamma  = IEEERepresentation(Gamma, 0, bits, bias)
                                PrintResult(Gamma,OpS);
                        }
                }

                if((Alpha.InfF || Beta.InfF) && (!Divide) && Continue){
                        Continue = 0;
                        parent.frames[1].document.writeln("<PRE>")
                        PrintResult(Alpha, "A    ");
                        PrintResult(Beta, "B    ")
                        PrintHR();
                        temp = Alpha.Sign^Beta.Sign;
                        if(temp) Sig = "-";
                                else Sig = "+";
                        PrintIEEENum(OpS,Sig +"Inf", temp, 1, 2*bias+1, bits)
                }


                
/////////////////////////////////////////////////////////////////////////


if (Continue){

        Gamma = Mul(Alpha, Beta, Gamma)
}
 parent.frames[1].document.close()
}





</SCRIPT>

<CENTER><H3>Floating Point Division by Convergence</H3></CENTER>

<NOSCRIPT>
It seems that you have disabled Javascript on your browser. In order
for this form to work, you must have Javascript enabled. If your
browser does not support Javascript, please dowload a browser
that does, such as
<A HREF="../../../../../../home.netscape.com/comprod/mirror/index.html">
Netscape Navigator</A>.
</NOSCRIPT>


<FORM>

<I>A:</I> <INPUT TYPE="Text" SIZE="16" NAME="A">
<P>
<I>B:</I> <INPUT TYPE="Text" SIZE="16" NAME="B">
<P>
<I>hex</I> <INPUT NAME="TypeNumber" TYPE=Radio VALUE="Hex">
<I>dec</I> <INPUT NAME="TypeNumber" TYPE=Radio VALUE="Dec" CHECKED>
<P>

<CENTER>
<INPUT TYPE="Button" VALUE="  Compute  " onClick="FPMul(this.form)">
<P>
<INPUT TYPE="Reset"  VALUE="     Reset    ">
<P>
</CENTER>

</FORM>


</BODY>
</HTML>

