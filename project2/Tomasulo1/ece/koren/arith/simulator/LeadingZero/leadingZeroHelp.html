
<HTML><HEAD>
    <TITLE>Leading Zero Detector Simulation</TITLE>
</HEAD>
<BODY>
<H2>Leading Zero Detector Help</H2>
This simulator demonstrates leading zero anticipation as a result of subtraction of two IEEE
floating-point numbers(one +ve,other -ve).
<H3>Algorithm 1</H3>
The following steps are taken:
<OL>
    <LI>Represent the two numbers in standard IEEE floating point format:<P>
        <CENTER><B>Number = (-1)<SUP>SIGN</SUP> * h.f * 2<SUP>(Exponent-Bias)
        </SUP> </B></CENTER><P>
            where h=1 except when (Exponent-Bias)=0.
    <LI>Make sure the exponents are same and both have different signs
    <LI>Take one's complement of smaller number (to be subtracted), say b<sub>i</sub>
    <LI>For each pair a<sub>i</sub>,b<sub>i</sub> from right to left, compute e<sub>i</sub> such that
    e<sub>i</sub> is 0 if a<sub>i</sub> and b<sub>i</sub> are same and atleast either a<sub>i+1</sub> or b<sub>i+1</sub>
    is 1.
    <LI>Count the number of zeros from right to left in e<sub>i</sub>.
</OL>
<H4>Ref:</H4>
H. Suzuki,H. Morinaka,H. Makino, Y. Nakase, K. Mashiko, T. Sumi,"Leading-zero anticipatory logic for high-speed floating point addition",
    IEEE Journal of Solid-State Circuits, Volume: 31 , Issue: 8 , Aug. 1996

<H3>Algorithm 2</H3>
The following steps are taken:
<OL>
    <LI>Represent the two numbers in standard IEEE floating point format:<P>
        <CENTER><B>Number = (-1)<SUP>SIGN</SUP> * h.f * 2<SUP>(Exponent-Bias)
        </SUP> </B></CENTER><P>
            where h=1 except when (Exponent-Bias)=0.
    <LI>Make sure the exponents are same and both have different signs
    <LI>Perform bitwise subtraction without carry propagation
    <LI>For each pair a<sub>i</sub>,b<sub>i</sub>, compute w<sub>i</sub> such that
        e<sub>i</sub> is 0 if a<sub>i</sub> and b<sub>i</sub> are same, is p=1 if a<sub>i</sub> = 1 and b<sub>i</sub> = 0 or n=-1 if a<sub>i</sub> =0 and b<sub>i</sub>=1.
    <LI>Perform correction if one of these patterns exists in W: W=0<sup>k</sup>p0<sup>j</sup>n(x) and W=0<sup>k</sup>pn<sup>j</sup>0<sup>t</sup>n(x).
    <LI>W=0<sup>k</sup>p0<sup>j</sup>n(x): Add one zero to the number of leading zeros in W.
    <LI>W=0<sup>k</sup>pn<sup>j</sup>0<sup>t</sup>n(x): Add 1+j zeros to the number of leading zeros in W.
</OL>
<H4>Ref:</H4>
J. Bruguera and T. Lang. "Leading-one prediction with concurrent position correction", International Conference on Computers, pages 298-305, ct. 1999

<HR> <H3>Accepted formats for A and B</H3>
    <UL>
        <LI><B>Decimal</B><BR>
            Accepts any decimal number, with the exception of numbers that start
            with &quot;<B>0</B>&quot;.
        <LI><B>Hexadecimal</B><BR>
            All hexadecimal characters are valid.  Since all numbers are represented
            in <B>single precision</B>,  you have to input exactly <B>8</B>
            characters.  This hexadecimal number represents the floating point
            representation of a
            number as stored in the register. The value of the number is determined
            based on the IEEE single floating point representation.
        <LI><B>Function</B><BR>
            Input your number in a function format. The accuracy of the calculation
            of the function is always double, independent of the selected precision
            for the addition or the subtraction. The numbers follow the above rules.
            <P>
                <B>Examples:</B><BR>
            <blockquote><B>A</B> = .9*pow(2,123)<BR>
                <B>B</B> = -.34*pow(10,3)<P>
                    <B>A</B> = .9*sin(23)<BR>
                    <B>B</B> = 5-pow(2,-123)<P>
                    <B>A</B> = pow(2,128)-pow(2,104) largest positive number<BR>
                    <B>B</B> = pow(2,-149) smallest denormalized positive number<BR>
            </blockquote>
            <P>
    </UL>
    <HR>
    <H3>Precision</H3>
    Precision is set to the <B>single IEEE format</B>
    (<I>word length = 32 bits, sign = 1 bit, fraction + hidden bit = 23+1
        bits, exponent = 8 bits, bias = 127</I>).  <P>
    <HR>

    <H3>Abbreviations</H3>
    <I>Inf</I> -- Infinity <BR>
    <I>NaN</I> -- Not a Number <BR>
    <I>Denom</I> -- Denormalized Number <BR>

</BODY>
</HTML>
