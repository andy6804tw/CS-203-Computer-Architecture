<HTML>
<HEAD>
<TITLE> Saturating Counter </TITLE>
<SCRIPT language="JavaScript">

// Author Yaron Koren

function PrintEmptyCell() {
	return "<TD>&nbsp;"
}

function PrintError(Message) {
	Error = "<CENTER><H1> ERROR </H1></CENTER> <P>\n"
	Error += "<CENTER> <EM>" + Message + "</EM> </CENTER>\n"
	return Error
}

function PrintAdderType(NumInputs) {
	if (NumInputs != 4) {
		return "(" + NumInputs + ",2)"
	} else {
		return "(4;2)"
	}
}

function PrintMIJ3Unit(m, i, j) {
	return "({" + m + "," + i + "," + j + "},3)"
}

function AdderRunningTime(AdderSize) {
	if (AdderSize == 2) {
		return 1
	} else if (AdderSize == 3) {
		return 2
	} else if (AdderSize == 4) {
		return 3
	} else { // it's 0; i.e., only OR gates are used -
		// return the equivalent time in XOR gates
		return (1/XORtoOR)
	}
}

//function LargestNumInputsInRow() {
//	var largestNum = 0
//	for (var i = 0; i < NumColumns - 1; i++) {
//		largestNum = Math.max(largestNum, NumBits[i])
//	}
//	return largestNum
//}

function allBitsInRowAre12Or4() {
	for (var i = 0; i < NumColumns - 1; i++) {
		if (NumBits[i] != 1 && NumBits[i] != 2 &&
		    NumBits[i] != 4 && NumBits[i] != 0) {
			return false
		}
	}
	return true
}

function isImprovable(NumInputs) {
	// return whether NumInputs is a number that's 1 less than 3
	// raised to some power - if it is, it means that some gate
	// substitution can be
	// done to decrease the calculation time

	//if (NumInputs < 1) {return false}
	
	//var PossiblePower = NumInputs + 1
	//while (PossiblePower > 1) {
		//if (PossiblePower % 3 == 0) {
		//	PossiblePower /= 3
		//} else {
		//	break
		//}
	//}
	//return (PossiblePower == 1)
	return (NumInputs == 2 || NumInputs == 8 || NumInputs ==  26)
}

// returns an HTML font tag that sets the text in front of it
// to the next color in the series
function GetNextHighlightColorFontTag() {
   ColorIndex = (ColorIndex + 1) % HighlightColors.length
   return "<font color=\"" + HighlightColors[ColorIndex] + "\">"
}

function GetMIJ3NumSignals(m,i,j) {
   // # of signals = (m div fan-in) + (m mod fan-in)
   //                + ((i + 1) choose 2)     (if j = 2)
   //                + (i choose 2) + (j choose 2) * i (if j >= 3)
   //		  + (j choose 4)           (if j >= 4 & fan-in >= 4)
   //		  + (j choose 4) * fan-in  (if j >= 4 & fan-in <= 3)

   var NumSignals = Math.floor(m / FanIn) + (m % FanIn)
   if (j == 2) {
	NumSignals += ((i + 1) * i / 2)
   } else {
	NumSignals += (i * (i - 1) / 2) + ((j + 1) * j / 2) * i
   }
   if (j >= 4) {
	var JChoose4 = (j * (j-1) * (j-2) * (j-3)) / 24
	if (FanIn >= 4) {
	   NumSignals += JChoose4
	} else {
	   NumSignals += JChoose4 * FanIn
	}
   }
   return NumSignals
}

function GetMIJ3Area(m, i, j) {
   // # of gates = # of signals - 1 (if m mod fan-in = 1)

   var NumSignals = GetMIJ3NumSignals(m,i,j)
   if (m % FanIn == 1) {
	NumGates = (NumSignals - 1)
   } else {
	NumGates = NumSignals
   }
   while (NumSignals > 1) {
	if (NumSignals <= FanIn) {
	   NumSignals = 1
	   NumGates++
	} else {
	   NumGates += Math.floor(NumSignals / FanIn)
	   NumSignals = Math.floor(NumSignals / FanIn) +
		(NumSignals % FanIn)
	}
	//alert ("NumGates is now " + NumGates)
   }

//alert ("returning " + (NumGates * AORtoXOR) + "; NumGates = " +
//		NumGates + ", AORtoXOR = " + AORtoXOR)
   return (NumGates * AORtoXOR)
}

function GetMIJ3RunningTime(m, i, j) {
   //(time must then be divided by XOR-to-OR delay ratio)

   var NumSignals = GetMIJ3NumSignals(m,i,j)
   var TotalTime = 0
   while (NumSignals > 1) {
	TotalTime++
	if (NumSignals <= FanIn) {
	   NumSignals = 1
	} else {
	   NumSignals = Math.floor(NumSignals / FanIn) +
		Math.floor(NumSignals % FanIn)
	}
   }

   return (TotalTime / XORtoOR)
}

function CreateTable(theForm) {

   // We store the contents of the first two rows in each stage before
   // printing them out, because the first row is calculated in reverse
   // order of printing, and the second row has some complicated
   // coloring stuff that can't be done on the fly
   var FirstRowHTML = new Array(NumColumns)
   var SecondRowHTML = new Array(NumColumns)

   // also, we create variables for alternating highlight colors
   HighlightColors = new Array("#000099", "#ff0000", "#3366ff",
	"#663300", "#993399", "#009900")
   ColorIndex = 0

   var RemainingInputs = 0

   // create and initialize the arrays representing total bits and
   // leftover bits currently in each column
   NumBits = new Array(NumColumns)
   LeftoverBits = new Array(NumColumns)
   for (i = 0; i < NumColumns; i++) {
	NumBits[i] = 0
	LeftoverBits[i] = 0
   }
   // also, we have to keep track of the number of bits carried across
   // (currently, this is only done by (4;2) compressors)
   var StraightLeftCarries = new Array(NumColumns)
   // when straight-left carries occur, we represent them using colors
   // in the HTML
   var StraightLeftCarryColor = new Array(NumColumns)

   // also, we keep track of total running time
   var RunningTime = 0

   UseMIJ3Unit = false
   g_MIJ3Area = 0
   MIJ3UnitAlreadyUsed = false

   // get first row for which user allows use of ({m,i,j},3) unit
   for (i = 0; i < theForm.mij3start.length; i++) {
	if (theForm.mij3start[i].checked) {
	   MIJ3StartStage = i
	}
   }

   // print top of table
   var TableStr = "<TABLE border=1>\n<TR>"
   for (i = NumColumns - 1; i >= 0; i--) {
	TableStr += "<TD><b>2<sup>" + i + "</sup></b>"
   }
   TableStr += "<TD><b>Stage</b><TD><b>Time</b></TR>\n<TR>\n<TR>"

   // print first line of data - stage 0
   for (i = NumColumns; i > 1; i--) {TableStr += PrintEmptyCell()}
   TableStr += "<TD>" + TotalBits
   // stage and time columns
   TableStr += "<TD>0<TD>0</TR>\n"

   NumBits[0] = TotalBits
   LeftoverBits[0] = 0
   StageCount = 0

   do {
	StageCount++

	// compute new values for NumBits, LeftoverBits arrays -
	// most-significant digit column gets handled differently,
	// because it uses OR gates, not adders

	// before we do that, though, save the original value in
	// the first column, if we need it for later
	if (UseMIJ3Unit) {OrigM = NumBits[NumColumns - 1]}
	NumGates = NumBits[NumColumns - 1]
	if (NumGates == 0) {
	   FirstRowHTML[NumColumns - 1] = "&nbsp;"
	} else if (NumGates < FanIn && NumBits[NumColumns - 2] == 1) {
	   FirstRowHTML[NumColumns - 1] = NumGates + ORGateType
	   NumBits[NumColumns - 1] = 1
	   GatesUsed[0] += NumGates
	} else {
	   // this computation is done twice because the OR gate
	   // performs two operations in the time it takes an adder
	   // to perform one
	   FirstRowHTML[NumColumns - 1] =
		Math.floor(NumGates / FanIn) +
		ORGateType + "+" + (NumGates % FanIn) + "<BR>"
	   NumGates = Math.floor(NumGates / FanIn) +
		(NumGates % FanIn)
	   FirstRowHTML[NumColumns - 1] +=
		Math.floor(NumGates / FanIn) +
		ORGateType + "+" + (NumGates % FanIn)
	   NumBits[NumColumns - 1] = Math.floor(NumGates / FanIn) +
		(NumGates % FanIn)
	   GatesUsed[0] += NumGates
	}

	// now, take care of the other columns in the first row,
	// and all of the second row
	SecondRowHTML[0] = ""
	StraightLeftCarries[0] = 0
	LargestAdderThisStage = 0

	if (UseMIJ3Unit) {

	   // bypass everything else and print the first and second
	   // rows ourselves

	   MIJ3RunningTime =
		GetMIJ3RunningTime(OrigM,
		NumBits[NumColumns-2], NumBits[NumColumns-3])
	   g_MIJ3Area = GetMIJ3Area(OrigM,
		NumBits[NumColumns-2], NumBits[NumColumns-3])
	   // in the second row, the 2nd and 3rd cells are covered
	   // by the {(i,j),2} unit, and all the rest are empty
	   MIJ3UnitUsed = PrintMIJ3Unit(OrigM,
		NumBits[NumColumns-2], NumBits[NumColumns-3])
	   // first row
	   TableStr += "<TR>"
	   TableStr += "<TD>" + FirstRowHTML[NumColumns-1]
	   TableStr += "<TD colspan=2 align=center>" +
		"1" + MIJ3UnitUsed
	   for (i = NumColumns - 4; i >= 0; i--) {
		TableStr += PrintEmptyCell()
	   }
	   // stage and time columns
	   TableStr += PrintEmptyCell() + PrintEmptyCell() + 
		"</TR>\n"
	   // second row
	   TableStr += "<TR>"
	   for (i = 0; i < NumColumns; i++) {
		NumBits[i] = 1
		LeftoverBits[i] = 0
		StraightLeftCarries[i] = 0
		TableStr += "<TD>1"
	   }
	   // stage and time columns
	   TableStr += "<TD>" + StageCount + PrintEmptyCell() + 
		"</TR>\n"

	} else {

	   for (i = 0; i < NumColumns - 1; i++) {
		FirstRowHTML[i] = ""
		SecondRowHTML[i+1] = ""
		StraightLeftCarries[i+1] = 0
		StraightLeftCarryColor[i+1] = ""

		if (isImprovable(NumBits[i])) {
		   // speed up the computation by getting the
		   // last 2 inputs their own adder
		   NumRegularAdders = (NumBits[i] - 2) / 3
		   if (NumRegularAdders > 0) {
			FirstRowHTML[i] = NumRegularAdders +
			   PrintAdderType(3) + "+"
			GatesUsed[3] += NumRegularAdders
			if (LargestAdderThisStage < 3) {
			   LargestAdderThisStage = 3
			}
		   }
		   // there is 1 output from the modified adder,
		   // plus NumRegularAdders outputs from the
		   // regular adders
		   NumBits[i] = 1 + NumRegularAdders
		   GatesUsed[2] += 1
		   if (LargestAdderThisStage < 2) {
			LargestAdderThisStage = 2
		   }
		   LeftoverBits[i] = 0
		   FirstRowHTML[i] += "1" + PrintAdderType(2)
		   SecondRowHTML[i+1] += NumBits[i]
		}


		// use (4;2) counters if the number of inputs
		// is > 3, and the user allows it
		else if (theForm.elements[StageCount + 7].checked &&
		   NumBits[i] > 3) {
		   RemainingInputs = NumBits[i]
		   if (i == 0) {
			Num42Adders = Math.floor(NumBits[i] / 5)
			RemainingInputs = RemainingInputs % 5
		   } else {
			// for each carry that this cell received
			// from the right, add it to 4 inputs from
			// above to insert into a (4;2) adder;
			// if there are 5 or more inputs from
			// above left over after that's done, we
			// can put each group of 5 into its own
			// (4;2) adder
			Num42Adders = 0
			while (StraightLeftCarries[i] > 0 &&
			   RemainingInputs > 4) {
			   Num42Adders++
			   RemainingInputs -= 4
			   StraightLeftCarries[i]--
			}
			if (RemainingInputs >= 5) {
			   Num42Adders +=
				Math.floor(RemainingInputs / 5)
			   RemainingInputs = RemainingInputs % 5
			}
		   }
		   NumBits[i] = Num42Adders
		   StraightLeftCarries[i+1] = Num42Adders
		   if (Num42Adders > 0) { // do we need this?
			GatesUsed[4] += Num42Adders
		   if (LargestAdderThisStage < 4) {
			LargestAdderThisStage = 4
		   }
		   // take care of HTML stuff
		   AddersColorTag = GetNextHighlightColorFontTag()
		   FirstRowHTML[i] += AddersColorTag + 
			Num42Adders +"(4;2)</font>"
		   SecondRowHTML[i+1] += AddersColorTag +
			Num42Adders + "</font>"
		   StraightLeftCarryColor[i+1] = AddersColorTag
		}


		// there will now be between 0 and 4 remaining
		// inputs:
		// if this number is 2 or 3, stick another
		// adder in there;
		// if it's 4, stick 2 (2,2) adders in;
		// if it's just 1, save it as a leftover bit
		if (RemainingInputs <= 1) {
		   LeftoverBits[i] = RemainingInputs
		} else {
		   if (RemainingInputs < 4) {
			AddersUsed = 1
			AdderSize = RemainingInputs
			LeftoverBits[i] = 0
		   } else if (theForm.elements[StageCount+7].checked) {
			Num42Adders += 1
			AddersUsed = 1
			AdderSize = 4
			StraightLeftCarries[i+1] += 1
			LeftoverBits[i] = 0
		   } else {
			AddersUsed = 1 //2
			AdderSize = 3 //2
			LeftoverBits[i] = 1
		   }
		   NumBits[i] += AddersUsed
		   GatesUsed[AdderSize] += AddersUsed
		   if (LargestAdderThisStage < AdderSize) {
			LargestAdderThisStage = AdderSize
		   }
		   // LeftoverBits[i] = 0
		   //if (Num42Adders > 0 && AdderSize != 4) {
		   //	FirstRowHTML[i] += "<br>"
		   //	SecondRowHTML[i+1] += " + "
		   //}
		   AdderColorTag = GetNextHighlightColorFontTag()
		   FirstRowHTML[i] += "<br>" + AdderColorTag +
			AddersUsed +
			PrintAdderType(AdderSize) + "</font>"
		   if (AddersUsed > 0) {
			SecondRowHTML[i+1] += " + " + AdderColorTag +
			   AddersUsed + "</font>"
		   }
		}
	   // if # of inputs is exactly 4, and column is
	   // 2nd-to-last, use 2 (2,2) adders
	   } else if (NumBits[i] == 4 &&
		//LargestNumInputsInRow() == 4 &&
		allBitsInRowAre12Or4()) {
		//i == NumColumns - 2) {
		NumBits[i] = 2
		LeftoverBits[i] = 0
		FirstRowHTML[i] = "2(2,2)"
		SecondRowHTML[i+1] += "2"
		GatesUsed[2] += 2
		if (LargestAdderThisStage < 2) {
		   LargestAdderThisStage = 2
		}
	   // otherwise, just use (3,2) adders
	   } else {
		LeftoverBits[i] = NumBits[i] % 3
		NumBits[i] = Math.floor(NumBits[i] / 3)
		if (NumBits[i] == 0) {
		   FirstRowHTML[i] = "&nbsp;"
		} else {
		   FirstRowHTML[i] = NumBits[i] + PrintAdderType(3)
		   SecondRowHTML[i+1] += NumBits[i]
		   GatesUsed[3] += NumBits[i]
		   if (LargestAdderThisStage < 3) {
			LargestAdderThisStage = 3
		   }
		}
	   }

	   // take care of any straight-left carries
	   if (StraightLeftCarries[i] > 0) {
		SecondRowHTML[i] += " + " + StraightLeftCarryColor[i] +
		StraightLeftCarries[i] + "</font>"
	   }
	}

	// take care of straight-left carries for the first
	// (leftmost) row as well
	if (StraightLeftCarries[NumColumns - 1] > 0) {
	   SecondRowHTML[NumColumns - 1] += " + " +
		StraightLeftCarryColor[NumColumns - 1] +
		StraightLeftCarries[NumColumns - 1] + "</font>"
	}

	// print the first row
	TableStr += "<TR>"
	for (i = NumColumns - 1; i >= 0; i--) {
	   TableStr += "<TD>" + FirstRowHTML[i]
	}

	// stage and time columns
	TableStr += PrintEmptyCell() + PrintEmptyCell() + "</TR>\n"

	// print the second row
	TableStr += "<TR>"

	for (i = NumColumns - 1; i >= 0; i--) {
	   if (NumBits[i] + LeftoverBits[i] > 0) {
		TableStr += "<TD>" + (NumBits[i] + LeftoverBits[i])
		   + " + "
		if (SecondRowHTML[i] == "") {
		   TableStr += "0"
		} else {
		   TableStr += SecondRowHTML[i]
		}
	   } else {
		if (SecondRowHTML[i] == "") {
		   TableStr += PrintEmptyCell()
		} else {
		   TableStr += "<TD>" + SecondRowHTML[i]
		}
	   }
	}
	// stage and time columns
	TableStr += "<TD>" + StageCount + PrintEmptyCell() + "</TR>\n"

	// now compute the new values - handle last data column
	// separately, because it doesn't get a carryover
	for (i = NumColumns - 1; i > 0; i--) {
	   NumBits[i] += LeftoverBits[i] +
		StraightLeftCarries[i] + NumBits[i-1]
	}
	NumBits[0] = NumBits[0] + LeftoverBits[0]
   }
   // end of if statement - all the rest applies whether or not
   // ({i,j},2) unit is used

   // print the third row - we don't need an array for this one
   TableStr += "<TR>"
   for (i = NumColumns - 1; i >= 0; i--) {
	if (NumBits[i] > 0) {
	   TableStr += "<TD>" + NumBits[i]
	} else {
	   TableStr += PrintEmptyCell()
	}
   }
   // stage and time columns
   if (UseMIJ3Unit) {
	RunningTime += MIJ3RunningTime
   } else {
	RunningTime += AdderRunningTime(LargestAdderThisStage)
   }
   TableStr += PrintEmptyCell() + "<TD>" + RunningTime +
	"</TR>\n<TR></TR>\n"

   // should we use the ({m,i,j},3) unit here?
   if (!MIJ3UnitAlreadyUsed &&
	NumBits[NumColumns - 3] >= 2 &&
	NumBits[NumColumns - 3] <= 7) {
	allOnes = true
	for (i = 0; i < NumColumns - 3; i++) {
	   if (NumBits[i] != 1) {allOnes = false}
	}
	if (allOnes) {
	   // use an ({m,i,j},3) unit, if user okayed it
	   if (theForm.UseMIJ3.checked &&
		StageCount >= MIJ3StartStage) {
		UseMIJ3Unit = true
		MIJ3UnitAlreadyUsed = true
	   }
	}
   }

   EndLoop = true
   for (i = NumColumns - 1; i >= 0; i--) {
	if (NumBits[i] != 1) {
	   EndLoop = false
	}
   }
   if (StageCount > 25) {EndLoop = true}

   } while (!EndLoop)

   // end of table
   TableStr += "</TABLE> <P>\n"

   // add on some text *above* the table listing total stages
   // and total execution time
   var TotalArea1 = (GatesUsed[0] * AORtoXOR) +
	(GatesUsed[2] * A22toXOR) +
	(GatesUsed[3] * A32toXOR) +
	(GatesUsed[4] * A42toXOR) + g_MIJ3Area
   TableStr = "Total stages: " + StageCount +
	"<BR>\nTotal Area = " + TotalArea1 +
	" A_XOR<BR>\nTotal execution time: " + RunningTime +
	" T_XOR"
	+ TableStr

   return TableStr
}


function SatCount(form) {

   var TheTop = "<HTML><HEAD><TITLE>Tablet</TITLE></HEAD>\n"
   TheTop += "<BODY bgcolor=white>\n"

   TotalBits = parseInt(form.TotalBits.value)
   Threshold = parseInt(form.Threshold.value)
   FanIn = parseInt(form.FanIn.value)
   XORtoOR = parseFloat(form.XORtoOR.value)
   AORtoXOR = parseFloat(form.AORtoXOR.value)
   A22toXOR = parseFloat(form.A22toXOR.value)
   A32toXOR = parseFloat(form.A32toXOR.value)
   A42toXOR = parseFloat(form.A42toXOR.value)

   ORGateType = "(OR<sub>" + FanIn + "</sub>)"
   NumColumns = Math.ceil(Math.log(Threshold) / Math.LN2) + 1

   var Middle

   if (isNaN(TotalBits) || TotalBits <= 0) {
	Middle = PrintError("Total bits must be a positive number")
   } else if (isNaN(FanIn) || FanIn < 3 || FanIn > 5) {
	Middle = PrintError("OR-gate fan-in must be between 3 and 5")
   } else if (isNaN(XORtoOR) || XORtoOR <= 0) {
	Middle = PrintError("XOR-gate to OR-gate delay ratio must be a positive number")
   } else {

	// all the inputs are okay

	GatesUsed = new Array(5)
	   for (i = 0; i < GatesUsed.length; i++) {
		GatesUsed[i] = 0
	   }

	// now create the table; we don't need to pass in all the
	// variables because they're all global (this is somewhat
	// unsafe, but it's easier to program)

	Middle = CreateTable(form)

	// below table, add in the gates used
	Middle += "This saturating counter uses "
	if (GatesUsed[4] > 0) {
	   Middle += GatesUsed[4] + " (4;2) compressors, "
	}
	for (i = 3; i > 0; i--) {
	   if (GatesUsed[i] > 0) {
		Middle += GatesUsed[i] + " (" + i + ",2) adders, "
	   }
	}
	if (UseMIJ3Unit) {
	   Middle += GatesUsed[0] + " " + FanIn + "-input OR gates, and 1 "
		+ MIJ3UnitUsed + " unit."
	} else {
	   Middle += "and " + GatesUsed[0] + " " + FanIn +
	   "-input OR gates."
	}
	var TotalArea = (GatesUsed[0] * AORtoXOR) +
	   (GatesUsed[2] * A22toXOR) + (GatesUsed[3] * A32toXOR) +
	   (GatesUsed[4] * A42toXOR) + g_MIJ3Area
	Middle += "<BR>\nTotal area used = " + TotalArea +
	   ", MIJ3 area = " + g_MIJ3Area
   }

   Bottom = "</BODY> </HTML>"

   parent.frames[1].document.open()
   parent.frames[1].document.write(TheTop);
   parent.frames[1].document.write(Middle);
   parent.frames[1].document.write(Bottom);
   parent.frames[1].document.close()
}

</SCRIPT>
</HEAD>

<BODY bgcolor="#EAEAAE" text="black">

<CENTER> <H2> Saturating Counter </H2> </CENTER>
<FORM>
Total bits: <INPUT type="text" name="TotalBits" value="1024" size=5>
<P>
Threshold (T): <INPUT type="text" name="Threshold" value="8" size=5>
<P>
OR gate fan-in: <INPUT type="text" name="FanIn" value="4" size=5>
<P>
Ratio of XOR delay to OR delay:
<INPUT type="text" name="XORtoOR" value="2" size=5>
<P>
Ratio of OR area to XOR area:
<INPUT type="text" name="AORtoXOR" value="0.5" size=5>
<P>
Ratio of (2,2) area to XOR area:
<INPUT type="text" name="A22toXOR" value="1.5" size=5>
<P>
Ratio of (3,2) area to XOR area:
<INPUT type="text" name="A32toXOR" value="3.5" size=5>
<P>
Ratio of (4;2) area to XOR area:
<INPUT type="text" name="A42toXOR" value="4.5" size=5>
<P>
Allow (4;2) compressors in the following rows:
<table border=0 cellpadding=0 cellspacing=0>
<tr>
<td>1: <INPUT type="checkbox">
<td>2: <INPUT type="checkbox">
<td>3: <INPUT type="checkbox">
<td>4: <INPUT type="checkbox">
<tr>
<td>5: <INPUT type="checkbox">
<td>6: <INPUT type="checkbox">
<td>7: <INPUT type="checkbox">
<td>8: <INPUT type="checkbox">
<tr>
<td>9: <INPUT type="checkbox">
<td>10: <INPUT type="checkbox">
<td>11: <INPUT type="checkbox">
<td>12: <INPUT type="checkbox">
</table>
<P>
Allow ({m,i,j},3) unit starting in the following row:
<table border=0 cellpadding=0 cellspacing=0>
<tr>
<td>1: <INPUT type="radio" name="mij3start" checked>
<td>2: <INPUT type="radio" name="mij3start">
<td>3: <INPUT type="radio" name="mij3start">
<td>4: <INPUT type="radio" name="mij3start">
<tr>
<td>5: <INPUT type="radio" name="mij3start">
<td>6: <INPUT type="radio" name="mij3start">
<td>7: <INPUT type="radio" name="mij3start">
<td>8: <INPUT type="radio" name="mij3start">
<tr>
<td>9: <INPUT type="radio" name="mij3start">
<td>10: <INPUT type="radio" name="mij3start">
<td>11: <INPUT type="radio" name="mij3start">
<td>12: <INPUT type="radio" name="mij3start">
</table>
<P>
<INPUT type="checkbox" name="UseMIJ3"> Use ({m,i,j},3) unit 
<p>
<CENTER>
<INPUT type="button" name="enter" value="Compute"
onClick="SatCount(this.form)">
</CENTER>
</FORM>

</BODY>
</HTML>
