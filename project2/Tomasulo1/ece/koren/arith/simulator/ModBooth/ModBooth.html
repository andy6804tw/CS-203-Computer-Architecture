<HTML>
<HEAD>
<TITLE> Modified Booth's Algorithm </TITLE>
<SCRIPT language="JavaScript">

function MakeLine(NumColumns) {
	return "<TR> <TD colspan=" + NumColumns + "> <HR noshade size=1>\n";
}

function PrintError(Message) {
	Error = "<CENTER><H1> ERROR </H1></CENTER> <P>\n"
	Error += "<CENTER> <EM>" + Message + "</EM> </CENTER>\n"
	return Error
}

function IsInteger(Num) {
	return (Num == Math.floor(Num))
}

function ParseBinary (BinNum) {
	// Turns a binary number into a decimal, sets a flag to true if
	// BinNum is not actually binary

	IsNeg = false
	if (BinNum < 0) {
		IsNeg = true
		BinNum *= -1
	}
	BinNum += Math.pow(10, -1 - NumBits) // kludge so processor
						 // won't mess up

	RealNum = 0
	LogBaseTen = Math.log(BinNum)/Math.LN10
	HighestPlace = Math.ceil(LogBaseTen)
	for (CurPlace = HighestPlace; CurPlace >= -NumBits; CurPlace--) {
		CurEntry = Math.round(BinNum / Math.pow(10, CurPlace))
		if (CurEntry != 0 && CurEntry != 1) {
			NotBinary = true
			CurEntry = 1 // feed it something normal, to avoid
					 // wierd Javascript errors
		}
		if (CurEntry == 1) {
			RealNum += Math.pow(2, CurPlace)
			BinNum -= Math.pow(10, CurPlace)
		}
	}
	if (IsNeg) {RealNum *= -1} // reverse it back at the end

	// now check if the number was negative according to two's complement
	// representation - if it was, set the decimal value to this negative
	// number
	if (HighestPlace == NumBits) {
		RealNum -= Math.pow(2, NumBits)
	}

	return RealNum
}

function OrderOfMagnitude (TheNum) {
	// returns the highest place which has a "1" in TheNum's
	// binary representation

	// to account for 2's complement representation...
	TheNum < 0 ? TheNum = (TheNum * -2) - 2 : TheNum *= 2

	LogBaseTwo = Math.log(TheNum)/Math.LN2;
	return Math.floor(LogBaseTwo);
}

function RoundOff (TheNum) {
	// returns the value TheNum would have if it were represented by
	// NumDecimals bits after the decimal point
	Scaling = Math.pow(2, NumDecimals)
	return (Math.round(TheNum * Scaling) / Scaling)
}

function PrintPairs(TheNum, StartPlace) {

	// first deal with negative numbers...
	if (TheNum < 0) {TheNum += Math.pow(2, StartPlace)}

	// now initialize the string
	S = "";
	for (CurPlace = StartPlace - 1; CurPlace >= -NumDecimals; CurPlace--) {
		if ((CurPlace - NumDecimals + 1) % 2 == 0) {S += "<TD> "}
		if (CurPlace == -1) {S += "."}
		CurPower = Math.pow(2, CurPlace);
		if (TheNum >= CurPower) {
			S += "1 ";
			TheNum -= CurPower
		} else {S += "0 "}
	}
	return S;
}

function ModBoothenizeInteger(TheNum) {
	// alert ("BoothenizeInteger called - NumDigits is "+ NumDigits+ ", NumDecimals is "+ NumDecimals);
	// First, create array representing Two's Complement of
	// original number

	if (TheNum < 0) {TheNum += Math.pow(2, NumDigits)}

	XArr = new Array()
	for (CurPlace = NumDigits - 1; CurPlace >= 0; CurPlace--) {
		CurPower = Math.pow(2, CurPlace);
		if (TheNum >= CurPower) {
			XArr[CurPlace] = 1;
			TheNum -= CurPower
		} else {XArr[CurPlace] = 0} }

	// Then, make array representing recoded multiplier
	YArr = new Array()

	PreviousTwoMatched = (XArr[0] == 0)
	for (i = 1; i <= NumDigits; i += 2) {
		YArr[i] = 0
		YArr[i-1] = 0
		if ((XArr[i] != XArr[i-1]) & PreviousTwoMatched) {
			{XArr[i] == 0 ? YArr[i] = 1 : YArr[i] = -1}
		}
		if (!PreviousTwoMatched) {
			{XArr[i] == 0 ? YArr[i-1] = 1 : YArr[i-1] = -1}
		}
		// set variable for next iteration...
		PreviousTwoMatched = (XArr[i] == XArr[i+1])
	}		
}

function ModBoothenizeFraction(TheNum) {
	// alert ("BoothenizeFraction called - NumDigits is "+ NumDigits+ ", NumDecimals is "+ NumDecimals);
	// First, create array representing Two's Complement of
	// original number

	if (TheNum < 0) {TheNum += Math.pow(2, NumDigits)}

	XArr = new Array()
	for (CurPlace = 0; CurPlace >= -NumDecimals; CurPlace--) {
		CurPower = Math.pow(2, CurPlace);
		if (TheNum >= CurPower) {
			XArr[CurPlace] = 1;
			TheNum -= CurPower
		} else {XArr[CurPlace] = 0} }

	// Then, make array representing recoded multiplier
	YArr = new Array()
	XArr[-NumDecimals - 1] = 0
	// Need this value to compute first two digits of Y

	for (i = -NumDecimals + 1; i <= 1; i += 2) {
		YArr[i] = 0
		YArr[i-1] = 0
		if ((XArr[i] != XArr[i-1]) & (XArr[i-1] == XArr[i-2])) {
			{XArr[i] == 0 ? YArr[i] = 1 : YArr[i] = -1}
		}
		if (XArr[i-1] != XArr[i-2]) {
			{XArr[i] == 0 ? YArr[i-1] = 1 : YArr[i-1] = -1}
		}
	}		
}

function ModBooth(form) {
	A = parseFloat(form.A.value)
	X = parseFloat(form.X.value)
	NumBits = parseInt(form.NumBits.value)
	ChoseBin = form.Base[0].checked
	NotBinary = false
	if (ChoseBin) {
		A = ParseBinary(A)
		X = ParseBinary(X)
	}

	BothIntegers = false
	BothFractions = false
	Mixed = false
	Overflow = false
	if (IsInteger(A) & IsInteger(X)) {
		NumDecimals = 0
		NumDigits = NumBits
		BothIntegers = true
		if (Math.max(OrderOfMagnitude(A), OrderOfMagnitude(X)) + 1 >
		    NumDigits) {
			NumDigits = 0
			NumDecimals = 0
			Overflow = true
		}
	} else {
		if (Math.abs(A) < 1 & Math.abs(X) < 1) {
			NumDigits = Math.max(OrderOfMagnitude(A), OrderOfMagnitude(X))
			BothFractions = true
			if (NumDigits < 1) {NumDigits = 1}
			NumDecimals = NumBits - NumDigits
		} else {
			Mixed = true
			NumDigits = 0
			NumDecimals = 0 // just filler values
		}
	}

	NumCols = NumDigits + NumDecimals // the arithmetic that led to this
					    // is not as simple as it looks
	A = RoundOff(A)
	X = RoundOff(X)

	TheTop = "<HTML><HEAD><TITLE>Tablet</TITLE></HEAD><BODY bgcolor=white>"
	Middle = "<TABLE>"

	Middle += "<TR> <TD>A<TD><TD>"
	Middle += PrintPairs(A, NumDigits)
	for (i = (NumBits / 2); i < NumCols; i++) {Middle += "<TD> "}
	Middle += "<TD>" + A + "\n"
	Middle += "<TR> <TD>X<TD>x<TD>"
	Middle += PrintPairs(X, NumDigits)
	for (i = (NumBits / 2); i < NumCols; i++) {Middle += "<TD> "}
	Middle += "<TD>" + X + "\n"
	Middle += "<TR> <TD>Y<TD><TD>"
	if (BothIntegers) {ModBoothenizeInteger(X)}
	if (BothFractions) {ModBoothenizeFraction(X)}
	for (CurPlace = NumDigits - 1; CurPlace >= -NumDecimals; CurPlace -= 2) {
		Middle += "<TD>"
		if (CurPlace == -1) {Middle += "."}
		Middle += YArr[CurPlace] + " "
		if (CurPlace - 1 == -1) {Middle += "."}
		Middle += YArr[CurPlace - 1]
	}
	for (i = (NumBits / 2); i < NumCols; i++) {Middle += "<TD> "}
	Middle += "<TD> recoded multiplier\n"
	Middle += MakeLine(NumCols + 4)

	Product = 0
	for (i = - NumDecimals + 1; i <= NumDigits; i += 2) {
		NotJustShift = (YArr[i - 1] != 0 | YArr[i] != 0)
		// 1st line - sometimes doesn't occur
		if (NotJustShift) {
			Middle += "<TR> <TD>Add "
			Term = 1 // default
			if (YArr[i - 1] == -1) {Middle += "-"; Term = -1}
			if (YArr[i] == 1) {Middle += "2"; Term = 2}
			if (YArr[i] == -1) {Middle += "-2"; Term = -2}
			Middle += "A <TD>+<TD>"
			Middle += PrintPairs(A * Term, NumDigits + 1) + "\n"
			Product = RoundOff (Product + A * Term * Math.pow(2, i - 1))
		}
		// 2nd line - printed for all but the first digit, assuming
		// an add happened
		if ((i > 1 - NumDecimals) && NotJustShift) {
			Middle += MakeLine(NumCols + 4)
			Middle += "<TR> <TD> <TD> <TD>"
			Middle += PrintPairs(Product, NumBits + i) + "\n"
		}
		// 3rd line
		Middle += "<TR> <TD> 2-Bit Shift "
		if (!NotJustShift) {Middle += "Only "} // i.e., just a shift :)
		Middle += "<TD> <TD>" + PrintPairs(Product, NumBits + i + 2) + "\n"
	}

	Middle += "<TD> " + Product
	Middle += "</TABLE> <P>\n";
	Bottom = "</BODY> </HTML>";

	if (Overflow) {Middle = PrintError("Overflow")}
	if (Mixed) {Middle = PrintError("Mixed numbers")}
	if (NumBits % 2 != 0) {Middle = PrintError("Number of bits must be even")}
	if (NotBinary) {Middle = PrintError("At least one non-binary number")}

	parent.frames[1].document.open()
	parent.frames[1].document.write(TheTop);
	parent.frames[1].document.write(Middle);
	parent.frames[1].document.write(Bottom);
	parent.frames[1].document.close()

}

</SCRIPT>
</HEAD>

<BODY bgcolor="#FFAF1C">

<CENTER> <H2> Modified Booth's Algorithm </H2> </CENTER>
<FORM>
A: <INPUT type="text" name="A">
<P>
X: <INPUT type="text" name="X">
<P>
<EM>bin</EM> <INPUT type="radio" name="Base" value="Binary" checked>
<EM>dec</EM> <INPUT type="radio" name="Base" value="Decimal">
<P>
Number of bits (must be even): <INPUT type="text" name="NumBits"
size=4>
<P>
<CENTER>
<INPUT type="button" name="enter" value="Compute"
onClick="ModBooth(this.form)">
</CENTER>
</FORM>

</BODY>
</HTML>
