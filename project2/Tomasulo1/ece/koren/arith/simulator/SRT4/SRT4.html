<HTML>
<HEAD>
<TITLE> Radix-4 SRT Division </TITLE>
<SCRIPT language="JavaScript">


function MakeLine(NumColumns) {
        return "<TR> <TD colspan=" + NumColumns + "> <HR noshade size=1>\n";
}

function PrintError(Message) {
        Error = "<CENTER><H1> ERROR </H1></CENTER> <P>\n"
        Error += "<CENTER> <EM>" + Message + "</EM> </CENTER>\n"
        return Error
}

function ParseBinary (BinNum) {
        // Turns a binary number into a decimal, sets a flag to true if
        // BinNum is not actually binary

        IsNeg = false
        if (BinNum < 0) {
                IsNeg = true
                BinNum *= -1
        }
        RealNum = 0
        LogBaseTen = Math.log(BinNum)/Math.LN10
        HighestPlace = Math.ceil(LogBaseTen)
        for (CurPlace = HighestPlace; CurPlace >= -NumBits; CurPlace--) {
                CurEntry = Math.round(BinNum / Math.pow(10, CurPlace))
                if (CurEntry != 0 && CurEntry != 1) {
                        NotBinary = true
                        CurEntry = 1 // feed it something normal, to avoid
                                         // wierd Javascript errors
                }
                if (CurEntry == 1) {
                        RealNum += Math.pow(2, CurPlace)
                        BinNum -= Math.pow(10, CurPlace)
                }
        }
        if (IsNeg) {RealNum *= -1} // reverse it back at the end

        // now check if the number was negative according to two's complement
        // representation - if it was, set the decimal value to this negative
        // number
        if (HighestPlace == NumBits) {
                RealNum -= Math.pow(2, NumBits)
        }

        return RealNum
}

function OrderOfMagnitude (TheNum) {
        // returns the highest place which has a "1" in TheNum's
        // binary representation

        TheNum += Math.pow(10, -1 - NumBits) // kludge so processor
                                            // won't mess up

        // to account for 2's complement representation...
        TheNum < 0 ? TheNum *= -2 : TheNum *= 2


        LogBaseTwo = Math.log(TheNum)/Math.LN2;
        return Math.floor(LogBaseTwo)
}

function TwosComp(TheNum, StartPlace) {
        NumStarted = false;
        NumDigits = StartPlace + NumDecimals + 1;

        // first deal with negative numbers...
        if (StartPlace < 0) {StartPlace == 0}
        if (TheNum < 0) {TheNum += Math.pow(2, StartPlace + 1)}

        // now initialize the string
        S = "";
        for (TheDigit = 1; TheDigit <= NumDigits; TheDigit++) {
                CurPlace = NumDigits - NumDecimals - TheDigit;
                if (CurPlace == 0) {NumStarted = true}
                if (CurPlace == -1) {S += "."}
                CurPower = Math.pow(2, CurPlace);
                if (TheNum >= CurPower) {
                        NumStarted = true;
                        S += "1";
                        TheNum -= CurPower
                } else if (NumStarted) {
                        S += "0";
                } // otherwise, print nothing
        }
        return S;
}

function RoundOff (TheNum) {
        // returns the value TheNum would have if it were represented by
        // NumDecimals bits after the decimal point
        Scaling = Math.pow(2, NumDecimals)
        return (Math.round(TheNum * Scaling) / Scaling)
}

function PrintTwosComp(TheNum, StartPlace) {

        if (StartPlace < 0) {StartPlace = 0}
        // first deal with negative numbers...
        if (TheNum < 0) {TheNum += Math.pow(2, StartPlace + 1)}

        // now initialize the string
        S = "";
        for (CurPlace = NumCols - NumDecimals; CurPlace > StartPlace; CurPlace--) {
                S += "<TD> "
        }
        for (CurPlace = StartPlace; CurPlace >= -NumDecimals; CurPlace--) {
                S += "<TD> ";
                if (CurPlace == -1) {
                        S += ".";
                }
                CurPower = Math.pow(2, CurPlace);
                if (TheNum >= CurPower) {
                        S += "1 ";
                        TheNum -= CurPower
                } else {S += "0 "} 
        }
        return S;
}

function SRT(form) {
        X = parseFloat(form.X.value)
        D = parseFloat(form.D.value)
        // Global variables... assigned from within a procedure...

	xlargerd2 = 0;
	xlargerd3 = 0;

        NumBits = parseInt(form.NumBits.value) + 1;
        ChoseBin = form.Base[0].checked;
        NotBinary = false;
        if (ChoseBin) {
                X = ParseBinary(X);
                D = ParseBinary(D);
        }
	if(form.alpha[0].checked) {
          if(Math.abs(X) > 2.0/3.0 * D) xlargerd2 = 1;
	}
	else{
          if (Math.abs(X) > D)  xlargerd3 = 1;
	}
        NumDigits = Math.max(OrderOfMagnitude(X), OrderOfMagnitude(D)) + 2
        if (NumDigits < 1) {NumDigits = 1}
        NumDecimals = NumBits - NumDigits
        NumCols = NumDecimals + NumDigits

        TheTop = "<HTML><HEAD><TITLE>Tablet</TITLE></HEAD><BODY bgcolor=white>"
        X = RoundOff(X)
        D = RoundOff(D)
        Middle = "X = " + X + ", D = " + D + "<P>\n"
        Middle = "<TABLE>"

        Q = 0;
        r = X;
        ZeroRem = false

        Middle += "<TR> <TD> r<SUB>0</SUB> = X <TD>";
        Middle += PrintTwosComp(r, OrderOfMagnitude(r) + 1);
        Middle += "<TD>\n"
        NumDec_4 = Math.floor(NumDecimals/2);

          if(D < 0.625) {k1 = 0.25; sk1="0.010"}
	  else {k1 = 0.375;sk1="0.011"}

	  if(D < 0.5625) { k2 = 0.75;sk2="0.110"}
	  else if(D < 0.625) { k2 = 0.875;sk2="0.111"}
	  else if(D < 0.6875) {k2 = 1;sk2="1.000"}
	  else if(D < 0.75) { k2 = 1.125;sk2="1.001"}
	  else if(D < 0.875) { k2 = 1.25;sk2="1.010"}
	  else if(D < 0.9375) {k2 = 1.375;sk2="1.011"}
	  else {k2 = 1.5;sk2="1.100"}


	  h1 = 0.5; sh1="0.1"
	  h2 = 1.0; sh2="1.0"
	  if(D < 0.75) { h3 = 1.5; sh3="1.1"}
	  else {h3 = 2;sh3="10.0"}

        for (i = 0; i < NumDec_4; i++) {
                // "qi" is a horrible misnomer because it's actually
                // q(i + 1).
                LessThanK1 = Math.abs(4 * r) < k1
                LessThanK2 = Math.abs(4 * r) < k2
		LessThanH3 = Math.abs(4 * r) < h3;
		LessThanH2 = Math.abs(4 * r) < h2;
		LessThanH1 = Math.abs(4 * r) < h1;

		if(form.alpha[0].checked) {
                  if(LessThanK2) {
                    LessThanK1 ? qi = 0 : r / D >= 0 ? qi = 1 : qi = -1;}
                  else {r / D >= 0 ? qi = 2 : qi = -2;}
		}
		else {
		  if(LessThanH1) { qi = 0;}
		  else if(LessThanH2) {
		      r/D >= 0 ? qi = 1: qi = -1;
		  }
		  else if (LessThanH3) {
		      r/D >= 0 ? qi = 2: qi = -2;
		  }
		  else {
		      r/D >= 0 ? qi = 3: qi = -3;
		  }
		}

                SumSize = Math.max (OrderOfMagnitude(4 * r),
                                          Math.max(OrderOfMagnitude(D * qi * -1),
                                                     OrderOfMagnitude(4 * r - qi * D)))
                // 1st line
                Middle += "<TR> <TD> 4r<SUB>" + i + "</SUB>"
                if (qi == 0) {
                        Middle += " =&gt; r<sub>" + (i+1) + "</sub>"
                }
                Middle += "<TD>"
                Middle += PrintTwosComp(4 * r, SumSize);
                Middle += "<TD> "
	       if(form.alpha[0].checked) {
                if (LessThanK1) {
                  Middle += (r >= 0 ? "r < " + sk1 : "r > " + (-sk1))
                } 
		else {
                  if (LessThanK2) {
                     Middle += (r >= 0 ? sk1+" <= r < "+sk2:-sk2+" < r <= "+(-sk1))
                  } 
		  else {
                     Middle += (r > 0 ? "r >= "+sk2 : "r < "+ (-sk2))
                  }
                }
	       }
	       else {
		if(LessThanH1) {
                   Middle += (r >= 0 ? "r < " + sh1 : "r > " + "-" + sh1);
		}
		else if(LessThanH2) {
                   Middle += (r >= 0 ? sh1 +" <= r < "+sh2 : "-"+sh2 +" < r <= " + "-" + sh1);
		}
		else if(LessThanH3) {
                   Middle += (r >= 0 ? sh2 +" <= r < "+sh3 : "-"+sh3 +" < r <= -"+sh2);
		}
		else {
                   Middle += (r > 0 ? "r >= "+sh3 : "r < "+ "-"+sh3);
		}
	       }

                // Middle += " (r = " + r + ") "
                // if (LessThanHalf) Middle += " (LessThanHalf) "
                // if (EqualsHalf) Middle += " (EqualsHalf) "
                Middle += "    set q<SUB>" + (i + 1) + "</SUB> = ";
                Q += Math.pow(4, -i - 1) * qi;
                ddle += Middle += qi + "\n";

                // 2nd line - printed only if qi is 1 or -1
                if (qi != 0) {
                        Middle += "<TR> <TD> Add "
                        if (qi >= 1) {Middle += "-";}
                        Middle += Math.abs(qi) +"D <TD> + ";
                        Middle += PrintTwosComp(D * qi * -1, SumSize);
                        Middle += "<TD>\n"
                        Middle += MakeLine(NumCols + 3);
                }
                r = RoundOff(4 * r - qi * D)

                // 3rd line - printed only if qi is 1 or -1
                if (qi != 0) {
                        Middle += "<TR> <TD> r<SUB>" + (i + 1) + "</SUB> "
                // if (qi == 0) {Middle += "= 2r<sub>" + i + "</sub> "}
                        Middle += "<TD> " + PrintTwosComp(r, SumSize) + "<TD>"
                }
        }

        Middle += "</TABLE> <P>\n";
        Middle += "Q = " + TwosComp(Q, 0) + " = " + Q + "<BR>\n"
        if (r/D < 0) { // if sign is different
                ulp = Math.pow(4, -NumDec_4)
                Middle += "R<i><sub>corrected</sub></i> = r<sub>" + i + "</sub>"
                if (Q/D > 0 || ZeroRem) {
                        Middle += " + D = " + TwosComp(r, 0) + " + " +
                        TwosComp(D, 0) + " = " + TwosComp(r + D, 0) + " = " +
                        (r + D) + "<BR>\n"
                        Middle += "Q<i><sub>corrected</sub></i> = Q - <i>ulp</i> = " +
                        TwosComp(Q, 0) + " - " + TwosComp(ulp, 0) + " = " +
                        TwosComp(Q - ulp, 0) + " = " + (Q - ulp)
                } else {
                        Middle += " - D = " + TwosComp(r, 3) + " - " +
                        TwosComp(D, 0) + " = " + TwosComp(r - D, 0) + " = " +
                        (r - D) + "<BR>\n"
                        Middle += "Q<i><sub>corrected</sub></i> = Q + <i>ulp</i> = " +
                        TwosComp(Q, 0) + " + " + TwosComp(ulp, 3) + " = " +
                        TwosComp(Q + ulp, 0) + " = " + (Q + ulp)
                }

        }
        Bottom = "</BODY> </HTML>";

     if (NotBinary == true) {Middle = PrintError("At least one non-binary number")}
     else {
        if (NumDecimals < 0) {Middle = PrintError("Overflow")}
        if (xlargerd3) {Middle = PrintError("The absolute value of X cannot be larger than D")}
        if (xlargerd2) {Middle = PrintError("The absolute value of X cannot be larger than 2/3 D while choosing alpha=2")}
        if (D == 0) {Middle = PrintError("Divide by zero")}
	if( D < 0.5 || D >=1.0)
	     {Middle = PrintError("Divisor should be in the range [0.5, 1).")}; 
     }

    if( (NumBits % 2) == 1) 
	     {Middle = PrintError("The number of bits should be odd.")}; 

        parent.frames[1].document.open()
        parent.frames[1].document.write(TheTop);
        parent.frames[1].document.write(Middle);
        parent.frames[1].document.write(Bottom);
        parent.frames[1].document.close()

}

</SCRIPT>
</HEAD>

<BODY bgcolor="#FFFF7C">

<CENTER> <H3> SRT Radix-4 Division</H3>

<p><FORM>
<p><i>Alpha: <EM>2</EM> <INPUT type="radio" name="alpha" value="2">
                 <EM>3</EM> <INPUT type="radio" name="alpha" value="3" checked>
</i><p>
<P>
<EM>bin</EM> <INPUT type="radio" name="Base" value="Binary">
<EM>dec</EM> <INPUT type="radio" name="Base" value="Decimal" checked>
<P>

X: <INPUT type="text" name="X" size=16>
<P>
D: <INPUT type="text" name="D" size=16>
<P>

Number of bits (odd):<BR>
<INPUT type="text" name="NumBits" value="9" size=12>
<P>
<INPUT type="button" value="Compute" onClick="SRT(this.form)">
<P>

</CENTER>
</FORM>

</BODY>
</HTML>
